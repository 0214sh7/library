<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/library/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/library/" rel="alternate" type="text/html" /><updated>2022-07-03T04:34:41+09:00</updated><id>http://localhost:4000/library/feed.xml</id><title type="html">すくライブラリ</title><subtitle>descriptionはない</subtitle><entry><title type="html">反復写像</title><link href="http://localhost:4000/library/posts/iterated-function" rel="alternate" type="text/html" title="反復写像" /><published>2022-07-03T00:00:00+09:00</published><updated>2022-07-03T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/iterated-function</id><content type="html" xml:base="http://localhost:4000/library/posts/iterated-function">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数列\(F\)を与えると、すべての整数 \(x (0 \leq x &amp;lt; \vert F \vert)\) について \(f(x) = F[x]\) となるように関数 \(f\) を設定する&lt;/li&gt;
  &lt;li&gt;計算量は\(N=\vert F \vert\)とし、\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iterated_function&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(0 \leq x &amp;lt; N\) を満たすような整数 \(x\) と非負整数 \(k\) を与えると、\(\overbrace{f(f(\cdots f}^{k}(x)))\) を求め、返す&lt;/li&gt;
  &lt;li&gt;\(k = 0\)なら\(x\)そのものを返す&lt;/li&gt;
  &lt;li&gt;範囲外なら\(-1\)を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N \log k)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/iterated%20function.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class iterated_function{
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; T[64];
    int N;
    
    public:
    void init(std::vector&amp;lt;int&amp;gt; F){
        N = F.size();
        T[0] = F;
        for(int j=1;j&amp;lt;64;j++){
            T[j].resize(N);
            for(int i=0;i&amp;lt;N;i++){
                T[j][i] = T[j-1][T[j-1][i]];
            }
        }
        
    }

    iterated_function(std::vector&amp;lt;int&amp;gt; F){
        init(F);
    }

    int solve(int x,long long k){
        if(!(0&amp;lt;=x &amp;amp;&amp;amp; x&amp;lt;N) || k&amp;lt;0){
            return -1;
        }

        int y = x;
        for(int i=0;(k&amp;gt;&amp;gt;i)&amp;gt;0;i++){
            if((k&amp;gt;&amp;gt;i)%2==1){
                y = T[i][y];
            }
        }

        return y;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class iterated_function{/*省略*/};

int main() {
    
    std::vector&amp;lt;int&amp;gt; F = {1,2,3,4,5,2};
    iterated_function func(F);

    std::cout &amp;lt;&amp;lt; &quot;0からk回辿ったときの頂点&quot; &amp;lt;&amp;lt; std::endl;
    for(int k=0;k&amp;lt;=15;k++){
        std::cout &amp;lt;&amp;lt; func.solve(0,k) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    std::cout &amp;lt;&amp;lt; &quot;各頂点から3回辿ったときの頂点&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;6;i++){
        std::cout &amp;lt;&amp;lt; func.solve(i,3) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0からk回辿ったときの頂点
0 1 2 3 4 5 2 3 4 5 2 3 4 5 2 3 

各頂点から3回辿ったときの頂点
3 4 5 2 3 4 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/07/03&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;反復写像を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した提出&quot;&gt;確認した提出&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ABC167-D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://atcoder.jp/contests/abc167/submissions/32945330&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 数列\(F\)を与えると、すべての整数 \(x (0 \leq x &amp;lt; \vert F \vert)\) について \(f(x) = F[x]\) となるように関数 \(f\) を設定する 計算量は\(N=\vert F \vert\)とし、\(Ο(N)\)</summary></entry><entry><title type="html">ローリングハッシュ</title><link href="http://localhost:4000/library/posts/rollinghash" rel="alternate" type="text/html" title="ローリングハッシュ" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/rollinghash</id><content type="html" xml:base="http://localhost:4000/library/posts/rollinghash">&lt;p&gt;MOD \(2^{61}-1\)と\(2\)基底を採用しています　&lt;a href=&quot;https://trap.jp/post/900/&quot;&gt;例の記事&lt;/a&gt;はいったい･･･&lt;br /&gt;
基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文字列\(S\)を与えると、前計算として\(S\)をハッシュする他、getの計算で使用する数値を計算する&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b\vert S \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rollinghash&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;get&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;半開区間\([l,r)\)を与えると、\(S\)の\([l,r)\)文字目のハッシュ値を返す&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;instant&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文字列\(P\)を与えると、initに与えた\(S\)とは関係なく\(P\)のハッシュ値を計算し返す&lt;/li&gt;
  &lt;li&gt;ただ返すだけで、initで揃えた情報を変更することはない&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b\vert P \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/rollinghash.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class rollinghash{
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    static constexpr long long mod = (1LL &amp;lt;&amp;lt; 61)-1;
    std::vector&amp;lt;long long&amp;gt; Base = {12345,10000000};
    std::vector&amp;lt;long long&amp;gt; BaseInv;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; BaseInvExp;
    static constexpr long long h = 100;
    
    long long product(long long a,long long b){
        static constexpr long long m = 1LL &amp;lt;&amp;lt; 31;
        long long a1 = a/m,a2 = a%m;
        long long b1 = b/m,b2 = b%m;
        
        long long r = 0 , s;
        r = (r + 2*a1*b1) % mod;
        s = (a1*b2 + b1*a2) % mod;
        long long s1 = s/m,s2 = s%m;
        s = (2*s1+m*s2) % mod;
        r = (r + s) % mod;
        r = (r + a2*b2) % mod;
        
        return r;
    }
    
    long long power(long long b,long long e){
        long long r=1;
        while(e){
            if(e&amp;amp;1){
                r=product(r,b)%mod;
            }
                b=product(b,b)%mod;
                e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    public:
    std::string S;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; H,Hsum;
    
    void init(std::string cs){
        S=cs;
        int n=S.size();
        
        BaseInv.resize(Base.size());
        BaseInvExp.resize(Base.size());
        H.resize(Base.size());
        Hsum.resize(Base.size());
        for(int i=0;i&amp;lt;Base.size();i++){
            BaseInvExp[i].assign(n+1,1);
            H[i].assign(n+1,0);
            Hsum[i].assign(n+1,0);
        }
        
        //逆元
        for(int i=0;i&amp;lt;Base.size();i++){
            BaseInv[i]=power(Base[i],mod-2);
        }
        for(int i=0;i&amp;lt;Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                BaseInvExp[i][j+1] = product(BaseInvExp[i][j],BaseInv[i]);
            }
        }
        
        //本体
        for(int i=0;i&amp;lt;Base.size();i++){
            long long b=1;
            for(int j=0;j&amp;lt;n;j++){
                H[i][j]=product(b,S[j]+h);
                b=product(b,Base[i]);
            }
        }
        
        //累積和
        for(int i=0;i&amp;lt;Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                Hsum[i][j+1]=(Hsum[i][j]+H[i][j])%mod;
            }
        }
    }
    
    rollinghash(std::string S){
        init(S);
    }
    
    std::vector&amp;lt;long long&amp;gt; get(int l,int r){
        std::vector&amp;lt;long long&amp;gt; R(Base.size());
        for(int i=0;i&amp;lt;Base.size();i++){
            long long g = (Hsum[i][r]-Hsum[i][l]+mod)%mod;
            g=product(g,BaseInvExp[i][l]);
            R[i] = g;
        }
        return R;
    }
    
    std::vector&amp;lt;long long&amp;gt; instant(std::string P){
        std::vector&amp;lt;long long&amp;gt; R;
        for(int i=0;i&amp;lt;Base.size();i++){
            long long r = 0, b = 1;
            for(int j=0;j&amp;lt;P.size();j++){
                r = (r+product(b,P[j]+h))%mod;
                b = product(b,Base[i]);
            }
            R.push_back(r);
        }
        return R;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class rollinghash{/*省略*/};

int main() {
    
    rollinghash rolihash(&quot;abcab&quot;);
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[0,2)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; a = rolihash.get(0,2);
    for(int i=0;i&amp;lt;a.size();i++){
        std::cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[1,4)文字目、つまり\&quot;bca\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; b = rolihash.get(1,4);
    for(int i=0;i&amp;lt;b.size();i++){
        std::cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[3,5)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; c = rolihash.get(3,5);
    for(int i=0;i&amp;lt;c.size();i++){
        std::cout &amp;lt;&amp;lt; c[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;bca\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; d = rolihash.instant(&quot;bca&quot;);
    for(int i=0;i&amp;lt;d.size();i++){
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;abcab&quot;の[0,2)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 

&quot;abcab&quot;の[1,4)文字目、つまり&quot;bca&quot;のハッシュ値
30025064778 19700001990000198 

&quot;abcab&quot;の[3,5)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 

&quot;bca&quot;のハッシュ値
30025064778 19700001990000198 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/06/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;constexprによる最適化を実行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/08/31&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;instantを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ローリングハッシュを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">MOD \(2^{61}-1\)と\(2\)基底を採用しています　例の記事はいったい･･･ 基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？</summary></entry><entry><title type="html">セグメント木</title><link href="http://localhost:4000/library/posts/segmenttree" rel="alternate" type="text/html" title="セグメント木" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/segment-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/segmenttree">&lt;p&gt;単にセグ木と言えばこれを指す、最も単純なセグ木&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一引数で整数\(N\)を与えると、要素が\(N\)個入る最小サイズの完全二分木を構成し、すべての要素を単位元で初期化する&lt;/li&gt;
  &lt;li&gt;また第二･第三引数でセグ木に乗せる演算とその単位元を与えるとその演算を乗せる&lt;/li&gt;
  &lt;li&gt;演算がモノイドでない場合の動作は保証しない&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;segmenttree&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;update&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(k\)番目(0-indexed)の要素を\(a\)で更新し、それが影響するノードを全て更新する&lt;/li&gt;
  &lt;li&gt;計算量はinitの\(N\)を用いて、\(Ο(logN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;query&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\([a,b)\)の範囲内にある要素をcalcで計算した結果をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(b-a))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
class segmenttree{
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int n;
    
    std::vector&amp;lt;T&amp;gt; dat;
    std::function&amp;lt;T(T,T)&amp;gt; calc;
    T identity;
    public:
    
    void init(int N,std::function&amp;lt;T(T,T)&amp;gt; func,T Identity){
        n=1;
        while(n&amp;lt;N)n*=2;
        dat.resize(2*n-1);
        for(int i=0;i&amp;lt;2*n-1;++i){
            dat[i]=Identity;
        }
        calc = func;
        identity = Identity;
    }
    
    segmenttree(int N,std::function&amp;lt;T(T,T)&amp;gt; func,T Identity){
        init(N,func,Identity);
    }
    
    void update(int k,T a){
        k+=n-1;
        dat[k]=a;
        while(k&amp;gt;0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    T query(int a,int b){
        a+=n-1;
        b+=n-1;
        T L= identity,R = identity;
        while(a &amp;lt; b){
            if(a % 2 == 0){
                L = calc(L,dat[a]);
                a++;
            }
            a = (a-1)/2;
            if(b % 2 == 0){
                R = calc(dat[b-1],R);
                b--;
            }
            b = (b-1)/2;
        }
        R = calc(L,R);
        return R;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

template&amp;lt;typename T&amp;gt;
class segmenttree{/*省略*/};

int main(void){
    
    long long N = 6;
    std::vector&amp;lt;long long&amp;gt; A = {100000,20000,3000,400,50,6};
    std::function&amp;lt;long long(long long,long long)&amp;gt; func = [](long long a,long long b){
        return a+b;
    };
    
    segmenttree&amp;lt;long long&amp;gt; segtree(N,func,0);
    for(int i=0;i&amp;lt;N;i++){
        segtree.update(i,A[i]);
    }
    
    std::cout &amp;lt;&amp;lt; segtree.query(0,3) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(0,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(2,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(3,5) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(5,6) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123000
123456
3456
450
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/01/30&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/01/30&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意の型に対応&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/10/10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;セグメント木を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">単にセグ木と言えばこれを指す、最も単純なセグ木</summary></entry><entry><title type="html">ディニッツ法</title><link href="http://localhost:4000/library/posts/dinic" rel="alternate" type="text/html" title="ディニッツ法" /><published>2021-11-01T00:00:00+09:00</published><updated>2021-11-01T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/dinic</id><content type="html" xml:base="http://localhost:4000/library/posts/dinic">&lt;p&gt;Dinicの読み方これでいいのかな&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、頂点を\(N\)個生成しフローの計算に必要なメモリを確保する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dinic&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;add&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(from\)から\(end\)にかけて容量\(cap\)の有向辺を張る&lt;/li&gt;
  &lt;li&gt;計算量は\(O(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(s\)を始点、頂点\(t\)を終点としてフローの最大値を求める&lt;/li&gt;
  &lt;li&gt;計算量はinitで与えた頂点の数を\(V\)、addで与えた辺の数を\(E\)として\(Ο(E V^2)\)&lt;/li&gt;
  &lt;li&gt;実際はこれよりも高速に動作する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/dinic.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dinic{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    struct edge{
        int end;
        long long cap,rev;
        
    };
    
    const long long INF = (1LL&amp;lt;&amp;lt;61);
    int V;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G;
    std::vector&amp;lt;long long&amp;gt; level;
    std::vector&amp;lt;int&amp;gt; iter;
    
    void Dinic_bfs(int s){
        for(int i=0;i&amp;lt;V;i++){
            level[i]=-1;
        }
        std::queue&amp;lt;int&amp;gt; que;
        level[s]=0;
        que.push(s);
        while(!que.empty()){
            int v=que.front();
            que.pop();
            for(unsigned int i=0;i&amp;lt;G[v].size();i++){
                edge &amp;amp;e = G[v][i];
                if(e.cap&amp;gt;0 &amp;amp;&amp;amp; level[e.end]&amp;lt;0){
                    level[e.end]=level[v]+1;
                    que.push(e.end);
                }
            }
        }
    }
    
    long long Dinic_dfs(int v,int t,long long f){
        if(v==t)return f;
        for(int &amp;amp;i=iter[v];i&amp;lt;G[v].size();i++){
            edge &amp;amp;e = G[v][i];
            if(e.cap&amp;gt;0 &amp;amp;&amp;amp; level[v]&amp;lt;level[e.end]){
                long long d = Dinic_dfs(e.end,t,std::min(f,e.cap));
                if(d&amp;gt;0){
                    e.cap -= d;
                    G[e.end][e.rev].cap+=d;
                    return d;
                }
            }
        }
        return 0;
    }
    
    public:
    
    void init(int N){
        V = N;
        G.clear();
        G.resize(V);
        level.resize(V);
        iter.resize(V);
    }
    
    Dinic(int N){
        init(N);
    }
    
    void add(int from,int end,long long cap){
        G[from].push_back((edge){end,cap,(long long)G[end].size()});
        G[end].push_back((edge){from,0,(long long)G[from].size()-1});
    }
    
    long long solve(int s,int t){
        long long flow=0;
        while(1){
            Dinic_bfs(s);
            if(level[t]&amp;lt;0){return flow;}
            for(int i=0;i&amp;lt;V;i++){
                iter[i]=0;
            }
            long long f;
            while((f=Dinic_dfs(s,t,INF))&amp;gt;0){
                flow+=f;
            }
        }
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class Dinic{/*省略*/};


int main(void){
    
    Dinic dinitz(5);
    dinitz.add(0,1,4);
    dinitz.add(0,2,2);
    dinitz.add(1,2,1);
    dinitz.add(1,3,2);
    dinitz.add(2,3,4);
    dinitz.add(2,4,2);
    dinitz.add(3,4,4);
    
    //このグラフでは頂点0から頂点4へは最大で5つ流れる
    //例えば0-&amp;gt;2-&amp;gt;4に2つ、0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4に1つ、0-&amp;gt;1-&amp;gt;3-&amp;gt;4に2つなどが考えられる
    long long R = dinitz.solve(0,4);
    std::cout &amp;lt;&amp;lt; R &amp;lt;&amp;lt; std::endl;
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;githubリンクを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ディニッツ法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">Dinicの読み方これでいいのかな</summary></entry><entry><title type="html">偏角ソート</title><link href="http://localhost:4000/library/posts/arg-sort" rel="alternate" type="text/html" title="偏角ソート" /><published>2021-10-31T00:00:00+09:00</published><updated>2021-10-31T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/arg-sort</id><content type="html" xml:base="http://localhost:4000/library/posts/arg-sort">&lt;p&gt;数列\(A\)を与えると、以下の並べ方で\(A\)をソートして返す
基準を第二変数\(d\)(デフォルトでは\((1,0)\))で定めることもできる&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;偏角(のうち、\([\arg(d),\arg(d)+2\pi)\)であるもの)が小さい順に並べる&lt;/li&gt;
  &lt;li&gt;それが同じ場合、絶対値が小さい順に並べる&lt;/li&gt;
  &lt;li&gt;\((0,0)\)が含まれる場合assertして停止する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;計算量は\(Ο(\vert A \vert log \vert A \vert)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/arg%20sort.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; arg_sort(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A,std::pair&amp;lt;long long,long long&amp;gt; d = {1,0}){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    long long N = A.size();
    assert(d.first != 0 || d.second != 0);
    long long g = std::gcd(d.first,d.second);
    d.first/=g;d.second/=g;
    A.push_back(d);
    std::sort(A.begin(),A.end(),[&amp;amp;](std::pair&amp;lt;long long,long long&amp;gt; x, std::pair&amp;lt;long long,long long&amp;gt; y){
        assert(x.first != 0 || x.second != 0);
        assert(y.first != 0 || y.second != 0);
        
        long long a,b;
        if(x.first&amp;gt;0 &amp;amp;&amp;amp; x.second==0){
            a=0;
        }else if(x.first&amp;gt;0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=1;
        }else if(x.first==0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=2;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=3;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second==0){
            a=4;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second&amp;lt;0){
            a=5;
        }else if(x.first==0 &amp;amp;&amp;amp; x.second&amp;lt;0){
            a=6;
        }else{
            a=7;
        }
        
        if(y.first&amp;gt;0 &amp;amp;&amp;amp; y.second==0){
            b=0;
        }else if(y.first&amp;gt;0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=1;
        }else if(y.first==0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=2;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=3;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second==0){
            b=4;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second&amp;lt;0){
            b=5;
        }else if(y.first==0 &amp;amp;&amp;amp; y.second&amp;lt;0){
            b=6;
        }else{
            b=7;
        }
        
        if(a!=b){
            return (a&amp;lt;b);
        }
        
        if(a%2==0){
            return (std::abs(x.first+x.second) &amp;lt; std::abs(y.first+y.second));
        }
        
        if(y.first*x.second != x.first*y.second){
           return (y.first*x.second &amp;lt; x.first*y.second);
        }
        
        return abs(x.first) &amp;lt; abs(y.first);
    });
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; B(N);
    for(int i=0;i&amp;lt;N+1;i++){
        if(A[i]==d){
            for(int j=i+1;j&amp;lt;N+1;j++){
                B[j-i-1]=A[j];
            }
            for(int j=0;j&amp;lt;i;j++){
                B[N-i+j]=A[j];
            }
            break;
        }
    }
    
    return B;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;


std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; arg_sort(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A,std::pair&amp;lt;long long,long long&amp;gt; d = {1,0}){/*省略*/}


int main(void){
    
    long long N = 12;
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A={
        {-3,0},
        {-1,-2},
        {1,2},
        {0,-3},
        {3,0},
        {-2,-1},
        {-2,1},
        {1,-2},
        {2,1},
        {2,-1},
        {0,3},
        {-1,2}
    };
    
    //Aを(1,0)を基準にソート
    A = arg_sort(A);
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; A[i].first &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; A[i].second &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; &quot; &quot;; 
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //Aを(-1,1)を基準にソート
    A = arg_sort(A,{-1,1});
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; A[i].first &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; A[i].second &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; &quot; &quot;; 
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(3,0) (2,1) (1,2) (0,3) (-1,2) (-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) 
(-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) (3,0) (2,1) (1,2) (0,3) (-1,2) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/10/31&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;偏角ソートを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">数列\(A\)を与えると、以下の並べ方で\(A\)をソートして返す 基準を第二変数\(d\)(デフォルトでは\((1,0)\))で定めることもできる</summary></entry><entry><title type="html">木の直径</title><link href="http://localhost:4000/library/posts/double-sweep" rel="alternate" type="text/html" title="木の直径" /><published>2021-10-15T00:00:00+09:00</published><updated>2021-10-15T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/double-sweep</id><content type="html" xml:base="http://localhost:4000/library/posts/double-sweep">&lt;p&gt;木ではない一般的なグラフでも近似解が出るらしいけどチェックしてません(え？)&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)と頂点数\(N\)の重み付き木を0-indexedのvector&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long»で与えると前計算をし、木の直径が計算できるようになる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;double_sweep&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vertex&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;最も距離が大きくなるような頂点対\((u,v)\)を一つ返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pass&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(v\)の間のパスを返す&lt;/li&gt;
  &lt;li&gt;このときvectorの先頭が\(u\)、最後尾が\(v\)になる&lt;/li&gt;
  &lt;li&gt;計算量はパスの長さを\(P\)として、\(Ο(P)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;diameter&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(v\)の間のパスの重さを出力する&lt;/li&gt;
  &lt;li&gt;計算量はパスの長さを\(P\)として、\(Ο(P)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/double%20sweep.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class double_sweep{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const long long INF = (1LL&amp;lt;&amp;lt;61);
    int V,V1,V2;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int,long long&amp;gt;&amp;gt;&amp;gt; G;
    std::vector&amp;lt;int&amp;gt; parent;
    std::vector&amp;lt;long long&amp;gt; parent_cost;
    long long diam;
    long long temp;
    
    void dfs(int phase,int v,int p,long long d){
        if(phase==1){
            if(d&amp;gt;temp){
                V1 = v;
                temp = d;
            }
        }
        if(phase==2){
            parent[v] = p;
            if(d&amp;gt;temp){
                V2 = v;
                temp = d;
            }
        }
        for(std::pair&amp;lt;int,long long&amp;gt; E:G[v]){
            int e = E.first;
            long long f = E.second;
            if(e!=p){
                dfs(phase,e,v,d+f);
                if(phase==2){
                    parent_cost[e] = f;
                }
            }
        }
    }
    
    public:
    
    void init(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        V = N;
        V1 = 0,V2 = 0;
        
        G.clear();
        G.resize(V);
        for(int i=0;i&amp;lt;edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({to,cost});
            G[to].push_back({from,cost});
        }
        
        parent.resize(V);
        for(int i=0;i&amp;lt;V;i++){
            parent[i] = -1;
        }
        parent_cost.resize(V);
        for(int i=0;i&amp;lt;V;i++){
            parent_cost[i] = -1;
        }
        
        temp = -INF;
        dfs(1,0,-1,0);
        temp = -INF;
        dfs(2,V1,-1,0);
        diam = -1;
    }
    
    double_sweep(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        init(N,edge);
    }
    
    std::pair&amp;lt;int,int&amp;gt; vertex(void){
        return std::make_pair(V2,V1);
    }
    
    std::vector&amp;lt;int&amp;gt; pass(void){
        std::vector&amp;lt;int&amp;gt; R;
        diam = 0;
        int r = V2;
        while(r!=V1){
            R.push_back(r);
            diam += parent_cost[r];
            r = parent[r];
        }
        R.push_back(r);
        return R;
    }
    
    long long diameter(void){
        if(diam==-1){
            pass();
        }
        return diam;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class double_sweep{/*省略*/};

int main(void){
    
    int N = 8;
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge;
    
    edge.push_back({ {0,1},1});
    edge.push_back({ {0,2},2});
    edge.push_back({ {0,3},4});
    edge.push_back({ {1,4},8});
    edge.push_back({ {1,5},16});
    edge.push_back({ {5,6},32});
    edge.push_back({ {5,7},64});
    
    double_sweep DS(N,edge);
    
    
    //直径の端の頂点は6と7
    std::pair&amp;lt;int,int&amp;gt; V = DS.vertex();
    std::cout &amp;lt;&amp;lt; V.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; V.second &amp;lt;&amp;lt; std::endl;
    
    //そのパスは6-5-7
    std::vector&amp;lt;int&amp;gt; P = DS.pass();
    for(int i=0;i&amp;lt;P.size();i++){
        std::cout &amp;lt;&amp;lt; P[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //重さの和は96
    long long D = DS.diameter();
    std::cout &amp;lt;&amp;lt; D &amp;lt;&amp;lt; std::endl;
    
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6 7
6 5 7 
96
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/10/15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;木の直径を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">木ではない一般的なグラフでも近似解が出るらしいけどチェックしてません(え？)</summary></entry><entry><title type="html">最小共通祖先</title><link href="http://localhost:4000/library/posts/lowest-common-ancestor" rel="alternate" type="text/html" title="最小共通祖先" /><published>2021-10-10T00:00:00+09:00</published><updated>2021-10-10T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/lowest-common-ancestor</id><content type="html" xml:base="http://localhost:4000/library/posts/lowest-common-ancestor">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(r\)と頂点数\(N\)の木を0-indexedのvector&amp;lt;pair&amp;lt;int,int»で与えると前計算をし、\(r\)を根とする木のLCAが計算できるようになる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N \log N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lowest_common_ancestor&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;climb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(k\)を与えると、頂点\(u\)から\(k\)個遡った頂点の番号を返す&lt;/li&gt;
  &lt;li&gt;もし根を超えてしまった場合は\(-1\)を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\log k)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lca&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(v\)を与えると頂点\(u\)と\(v\)のLCA(最小共通祖先)を返す&lt;/li&gt;
  &lt;li&gt;計算量は木の頂点数\(N\)を用いて、\(Ο(\log N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/lowest%20common%20ancestor.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class lowest_common_ancestor{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int V,LOG;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; G,table;
    std::vector&amp;lt;long long&amp;gt; depth;
    
    void dfs(long long v,long long p,long long d){
        depth[v] = d;
        table[v][0] = p;
        for(long long e:G[v]){
            if(e!=p){
                dfs(e,v,d+1);
            }
        }
    }
    
    public:
    void init(long long root,std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; edge){
        V = 1+edge.size();
        LOG = 1;
        while((1&amp;lt;&amp;lt;LOG)&amp;lt;V)LOG++;

        G.clear();
        G.resize(V);
        for(int i=0;i&amp;lt;edge.size();i++){
            G[edge[i].first].push_back(edge[i].second);
            G[edge[i].second].push_back(edge[i].first);
        }
        
        table.resize(V);
        for(int i=0;i&amp;lt;V;i++){
            table[i].resize(LOG);
        }
        depth.resize(V);
        dfs(root,-1,0);
        
        for(int j=0;j&amp;lt;LOG-1;j++){
            for(int i=0;i&amp;lt;V;i++){
                if(table[i][j]==-1){
                    table[i][j+1] = -1;
                }else{
                    table[i][j+1] = table[table[i][j]][j];
                }
                
            }
        }
        
    }
    
    lowest_common_ancestor(long long root,std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; edge){
        init(root,edge);
    }
    
    
    long long climb(long long u,long long k = 1){
        for(int i=0;k&amp;gt;0;k&amp;gt;&amp;gt;=1,i++){
            if(u==-1)return -1;
            if(k&amp;amp;1)u = table[u][i];
        }
        return u;
    }
    
    long long lca(long long u,long long v){
        if(depth[u]&amp;gt;depth[v])std::swap(u,v);
        v = climb(v,depth[v]-depth[u]);
        if(u==v)return u;
        
        for(int i=LOG-1;i&amp;gt;=0;i--){
            if(table[u][i]!=table[v][i]){
                u = table[u][i];
                v = table[v][i];
            }
        }
        return table[u][0];
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class lowest_common_ancestor{/*省略*/};

int main(void){
    
    int N = 8;
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; edge;
    
    edge.push_back({0,1});
    edge.push_back({0,2});
    edge.push_back({0,3});
    edge.push_back({1,4});
    edge.push_back({1,5});
    edge.push_back({5,6});
    edge.push_back({5,7});
    
    //0を根として前計算する
    lowest_common_ancestor LCA(0,edge);
    
    //頂点6から一つずつ遡ったら6→5→1→0になり、それを超えると-1
    for(int i=0;i&amp;lt;5;i++){
        std::cout &amp;lt;&amp;lt; LCA.climb(6,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //頂点6と頂点7のLCAは5
    std::cout &amp;lt;&amp;lt; LCA.lca(6,7) &amp;lt;&amp;lt; std::endl;
    
    //頂点6と頂点1のLCAは1
    std::cout &amp;lt;&amp;lt; LCA.lca(6,1) &amp;lt;&amp;lt; std::endl;
    
    //頂点6と頂点3のLCAは0
    std::cout &amp;lt;&amp;lt; LCA.lca(6,3) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6 5 1 0 -1 
5
1
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/10/10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最小共通祖先を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 整数\(r\)と頂点数\(N\)の木を0-indexedのvector&amp;lt;pair&amp;lt;int,int»で与えると前計算をし、\(r\)を根とする木のLCAが計算できるようになる 計算量は\(Ο(N \log N)\)</summary></entry><entry><title type="html">二次元配列の回転</title><link href="http://localhost:4000/library/posts/vector2d-rotate" rel="alternate" type="text/html" title="二次元配列の回転" /><published>2021-09-12T00:00:00+09:00</published><updated>2021-09-12T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/vector2d-rotate</id><content type="html" xml:base="http://localhost:4000/library/posts/vector2d-rotate">&lt;p&gt;二次元配列\(A\)を与えると、\(A\)を反時計回りに回転させ返す&lt;/p&gt;

&lt;p&gt;第二変数を\(true\)にすると時計回りに回転させる&lt;/p&gt;

&lt;p&gt;もし\(A[i]\)の長さが揃っていない場合は最も長いものに合わせ、足りない部分は第三変数の値(デフォルトは\(0\))で埋める&lt;/p&gt;

&lt;p&gt;計算量は配列を\(N\)行\(M\)列として\(Ο(NM)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; vector2D_rotate(std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; A,bool clockwise=false,char leading = 0){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    int N = A.size();
    if(N==0)return A;
    
    int M = 0;
    for(int i=0;i&amp;lt;N;i++){
        M = std::max(M,(int)A[i].size());
    }
    
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; B(M,std::vector&amp;lt;char&amp;gt;(N,leading));
    
    for(int i=0;i&amp;lt;N;i++){
        for(int j=0;j&amp;lt;A[i].size();j++){
            if(clockwise){
                B[j][N-1-i]=A[i][j];
            }else{
                B[M-1-j][i]=A[i][j];
            }
        }
    }
    
    return B;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; vector2D_rotate(std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; A,bool clockwise=false,char leading = 0){/*省略*/}

int main(){
    
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; A ={
        {'a','b','c'},
        {'d','e','f'},
        {'g','h','i'}
    };
    
    std::cout &amp;lt;&amp;lt; &quot;回転なし&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;A.size();i++){
        for(int j=0;j&amp;lt;A[i].size();j++){
            std::cout &amp;lt;&amp;lt; A[i][j] &amp;lt;&amp;lt; &quot; &quot;;
        }
        std::cout &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; counter = vector2D_rotate(A);
    
    std::cout &amp;lt;&amp;lt; &quot;反時計回り&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;counter.size();i++){
        for(int j=0;j&amp;lt;counter[i].size();j++){
            std::cout &amp;lt;&amp;lt; counter[i][j] &amp;lt;&amp;lt; &quot; &quot;;
        }
        std::cout &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt;&amp;gt; clockwise = vector2D_rotate(A,true);
    
    std::cout &amp;lt;&amp;lt; &quot;時計回り&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;clockwise.size();i++){
        for(int j=0;j&amp;lt;clockwise[i].size();j++){
            std::cout &amp;lt;&amp;lt; clockwise[i][j] &amp;lt;&amp;lt; &quot; &quot;;
        }
        std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;回転なし
a b c 
d e f 
g h i 

反時計回り
c f i 
b e h 
a d g 

時計回り
g d a 
h e b 
i f c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/09/12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二次元配列の回転を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">二次元配列\(A\)を与えると、\(A\)を反時計回りに回転させ返す</summary></entry><entry><title type="html">UnionFind</title><link href="http://localhost:4000/library/posts/unionfind" rel="alternate" type="text/html" title="UnionFind" /><published>2021-08-31T00:00:00+09:00</published><updated>2021-08-31T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/unionfind</id><content type="html" xml:base="http://localhost:4000/library/posts/unionfind">&lt;p&gt;DSU(disjoint set union)とも&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、頂点を\(N\)個生成し全てを独立にした上で全てのランクを\(0\)にする&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unionfind&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;root&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(k\)のその時点での根を求める&lt;/li&gt;
  &lt;li&gt;と同時に経路圧縮する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\(α(x)\)はアッカーマン関数\(Ack(x,x)\)の逆関数&lt;/p&gt;

&lt;p&gt;\(Ack(4,4)=2^{2^{2^{65536}}}-3\)から伺えるように、\(\alpha (x)\)は実用上定数(\(4\))倍と見なせるほどに収束が遅い&lt;/p&gt;

&lt;p&gt;same&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(p\)と頂点\(q\)がその時点で同じ集合に属しているか(=根が同一か)を調べ、同じならtrue、違うならfalseを返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unite&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(p\)と頂点\(q\)が属してる集合を合併する&lt;/li&gt;
  &lt;li&gt;すでに同じ集合に属している場合は無視する&lt;/li&gt;
  &lt;li&gt;\(p\)の属する集合のランクが\(q\)のものと同じか大きいとき\(p\)側が根に、そうでないとき\(q\)側が根になる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;size&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(k\)とその時点で同じ集合に属している頂点の数を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/union%20find.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class unionfind{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; UF,rank,size_;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        size_.clear();
        for(int i=0;i&amp;lt;N;i++){
            UF.push_back(i);
            rank.push_back(0);
            size_.push_back(1);
        }
    }
    
    unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]&amp;lt;rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        size_[p] += size_[q];
        size_[q] = 0;
    }
    
    int size(int k){
        return size_[root(k)];
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class unionfind{/*省略*/};

int main(void){
    
    unionfind UF(13);
    UF.unite(1,3);
    UF.unite(1,5);
    UF.unite(1,7);
    UF.unite(1,8);
    UF.unite(1,10);
    UF.unite(1,12);
    UF.unite(4,6);
    UF.unite(4,9);
    UF.unite(4,11);
    
    for(int i=1;i&amp;lt;=12;i++){
        std::cout &amp;lt;&amp;lt; UF.root(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //1と同じ集合に属しているなら1(true)、そうでないなら0(false)
    for(int i=1;i&amp;lt;=12;i++){
        std::cout &amp;lt;&amp;lt; UF.same(1,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //同じ集合に入っている頂点がいくつあるか
    for(int i=1;i&amp;lt;=12;i++){
        std::cout &amp;lt;&amp;lt; UF.size(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 1 4 1 4 1 1 4 1 4 1 
1 0 1 0 1 0 1 1 0 1 0 1 
7 1 7 4 7 4 7 7 4 7 4 7 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/08/31&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;sizeを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UnionFindを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">DSU(disjoint set union)とも</summary></entry><entry><title type="html">拡張ユークリッドの互除法</title><link href="http://localhost:4000/library/posts/bezout-coef" rel="alternate" type="text/html" title="拡張ユークリッドの互除法" /><published>2021-04-08T00:00:00+09:00</published><updated>2021-04-08T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/bezout-coef</id><content type="html" xml:base="http://localhost:4000/library/posts/bezout-coef">&lt;p&gt;拡張ユークリッドの互除法、extended Euclidean algorithmの対訳感がそんなにないね　どうでもいいね&lt;/p&gt;

&lt;p&gt;整数\(a,b\)を与えると、\(g=gcd(a,b)\)とそれを用いて表される等式&lt;/p&gt;

\[ax+by=g\]

&lt;p&gt;を満たす\((x,y)\)(ベズー係数)を一つ求め、\(g\)とともに返す&lt;/p&gt;

&lt;p&gt;計算量は\(O(log(max(a,b)))\)&lt;/p&gt;

&lt;p&gt;ここで返り値はpair&amp;lt;ll,pair&amp;lt;ll,ll»となっているが、それぞれ\(\{g,\{x,y\}\}\)を表している&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/extended%20Euclidean%20algorithm.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::pair&amp;lt;long long,std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; extgcd(long long a,long long b){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; q;
    while(b!=0){
        long long r = a%b;
        r+=b;
        r%=b;
        long long q_ = (a-r)/b;
        q.push_back(q_);
        a = b;
        b = r;
    }
    
    long long g=a,x=1,y=0;
    if(g&amp;lt;0){
        g*=-1;
        x*=-1;
    }
    for(int i=-1+(int)q.size();i&amp;gt;=0;i--){
        long long tmp = y;
        y = x-q[i]*y;
        x = tmp;
    }
    
    return {g,{x,y}};
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::pair&amp;lt;long long,std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; extgcd(long long a,long long b){/*省略*/}

signed main() {
    
    std::pair&amp;lt;long long,std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; R;
    R = extgcd(111,30);
    long long g = R.first, x = R.second.first, y = R.second.second;
    
    std::cout &amp;lt;&amp;lt; &quot;111と30の最大公約数&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; g &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    
    
    std::cout &amp;lt;&amp;lt; &quot;111x+30y=3を満たすような(x,y)の一例&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    
    
    std::cout &amp;lt;&amp;lt; &quot;111x+30y&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; 111*x+30*y &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111と30の最大公約数
3

111x+30y=3を満たすような(x,y)の一例
(3,-11)

111x+30y
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/08&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;欠落していた計算量を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/08&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;拡張ユークリッドの互除法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">拡張ユークリッドの互除法、extended Euclidean algorithmの対訳感がそんなにないね　どうでもいいね</summary></entry></feed>