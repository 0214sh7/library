<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/library/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/library/" rel="alternate" type="text/html" /><updated>2023-03-25T02:21:30+09:00</updated><id>http://localhost:4000/library/feed.xml</id><title type="html">すくライブラリ</title><subtitle>descriptionはない</subtitle><entry><title type="html">ローリングハッシュ</title><link href="http://localhost:4000/library/posts/rollinghash" rel="alternate" type="text/html" title="ローリングハッシュ" /><published>2023-03-25T00:00:00+09:00</published><updated>2023-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/rollinghash</id><content type="html" xml:base="http://localhost:4000/library/posts/rollinghash">&lt;p&gt;MOD \(2^{61}-1\)と\(2\)基底を採用しています　&lt;a href=&quot;https://trap.jp/post/900/&quot;&gt;例の記事&lt;/a&gt;はいったい･･･&lt;br /&gt;
基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;文字列&lt;/del&gt; long longのvector \(S\) を与えると、前計算として\(S\)をハッシュする他、getの計算で使用する数値を計算する&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b\vert S \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rollinghash&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;get&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;半開区間\([l,r)\)を与えると、\(S\)の\([l,r)\)文字目のハッシュ値を返す&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;instant&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;文字列&lt;/del&gt; long longのvector \(P\)を与えると、initに与えた\(S\)とは関係なく\(P\)のハッシュ値を計算し返す&lt;/li&gt;
  &lt;li&gt;ただ返すだけで、initで揃えた情報を変更することはない&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b\vert P \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;connect&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;文字列&lt;/del&gt; long longのvector \(P,Q\) のハッシュ結果と列の長さを与えると、initに与えた\(S\)とは関係なく\(P,Q\)の結合vector\(P+Q\)のハッシュ値を計算し返す&lt;/li&gt;
  &lt;li&gt;ただ返すだけで、initで揃えた情報を変更することはない&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)、\(P\)の長さを\(p\)として、\(Ο(b \log{p})\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/rollinghash.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class rollinghash{
    /*
    Copyright (c) 2023 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    static constexpr long long mod = (1LL &amp;lt;&amp;lt; 61)-1;
    std::vector&amp;lt;long long&amp;gt; Base = {12345,10000000};
    std::vector&amp;lt;long long&amp;gt; BaseInv;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; BaseInvExp;
    static constexpr long long h = 100;
    
    long long product(long long a,long long b){
        static constexpr long long m = 1LL &amp;lt;&amp;lt; 31;
        long long a1 = a/m,a2 = a%m;
        long long b1 = b/m,b2 = b%m;
        
        long long r = 0 , s;
        r = (r + 2*a1*b1) % mod;
        s = (a1*b2 + b1*a2) % mod;
        long long s1 = s/m,s2 = s%m;
        s = (2*s1+m*s2) % mod;
        r = (r + s) % mod;
        r = (r + a2*b2) % mod;
        
        return r;
    }
    
    long long power(long long b,long long e){
        long long r=1;
        while(e){
            if(e&amp;amp;1){
                r=product(r,b)%mod;
            }
                b=product(b,b)%mod;
                e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    public:
    std::vector&amp;lt;long long&amp;gt; S;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; H,Hsum;
    
    void init(std::vector&amp;lt;long long&amp;gt; cs){
        S=cs;
        int n=S.size();
        
        BaseInv.resize(Base.size());
        BaseInvExp.resize(Base.size());
        H.resize(Base.size());
        Hsum.resize(Base.size());
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            BaseInvExp[i].assign(n+1,1);
            H[i].assign(n+1,0);
            Hsum[i].assign(n+1,0);
        }
        
        //逆元
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            BaseInv[i]=power(Base[i],mod-2);
        }
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                BaseInvExp[i][j+1] = product(BaseInvExp[i][j],BaseInv[i]);
            }
        }
        
        //本体
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            long long b=1;
            for(int j=0;j&amp;lt;n;j++){
                H[i][j]=product(b,S[j]+h);
                b=product(b,Base[i]);
            }
        }
        
        //累積和
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                Hsum[i][j+1]=(Hsum[i][j]+H[i][j])%mod;
            }
        }
    }
    
    rollinghash(std::vector&amp;lt;long long&amp;gt; C){
        init(C);
    }
    
    std::vector&amp;lt;long long&amp;gt; get(int l,int r){
        std::vector&amp;lt;long long&amp;gt; R(Base.size());
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            long long g = (Hsum[i][r]-Hsum[i][l]+mod)%mod;
            g=product(g,BaseInvExp[i][l]);
            R[i] = g;
        }
        return R;
    }
    
    std::vector&amp;lt;long long&amp;gt; instant(std::vector&amp;lt;long long&amp;gt; P){
        std::vector&amp;lt;long long&amp;gt; R;
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            long long r = 0, b = 1;
            for(int j=0;j&amp;lt;(int)P.size();j++){
                r = (r+product(b,P[j]+h))%mod;
                b = product(b,Base[i]);
            }
            R.push_back(r);
        }
        return R;
    }
    
    std::vector&amp;lt;long long&amp;gt; connect(std::vector&amp;lt;long long&amp;gt; P,long long ps,std::vector&amp;lt;long long&amp;gt; Q,long long qs){
        std::vector&amp;lt;long long&amp;gt; R;
        for(int i=0;i&amp;lt;(int)Base.size();i++){
            long long r = (product(Q[i],power(Base[i],ps))+P[i])%mod;
            R.push_back(r);
        }
        return R;
        assert(qs==qs);
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class rollinghash{/*省略*/};

int main() {
    
    rollinghash rolihash({'a','b','c','a','b'});
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[0,2)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; a = rolihash.get(0,2);
    for(int i=0;i&amp;lt;a.size();i++){
        std::cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[1,4)文字目、つまり\&quot;bca\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; b = rolihash.get(1,4);
    for(int i=0;i&amp;lt;b.size();i++){
        std::cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[3,5)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; c = rolihash.get(3,5);
    for(int i=0;i&amp;lt;c.size();i++){
        std::cout &amp;lt;&amp;lt; c[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;bc\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; d = rolihash.instant({'b','c'});
    for(int i=0;i&amp;lt;d.size();i++){
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;a\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; e = rolihash.instant({'a'});
    for(int i=0;i&amp;lt;e.size();i++){
        std::cout &amp;lt;&amp;lt; e[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    std::cout &amp;lt;&amp;lt; &quot;\&quot;bc\&quot;と\&quot;a\&quot;の結合、つまり\&quot;bca\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; f = rolihash.connect(d,2,e,1);
    for(int i=0;i&amp;lt;f.size();i++){
        std::cout &amp;lt;&amp;lt; f[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;abcab&quot;の[0,2)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 

&quot;abcab&quot;の[1,4)文字目、つまり&quot;bca&quot;のハッシュ値
30025064778 19700001990000198 

&quot;abcab&quot;の[3,5)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 

&quot;bc&quot;のハッシュ値
2456853 1990000198 

&quot;a&quot;のハッシュ値
197 197 

&quot;bc&quot;と&quot;a&quot;の結合、つまり&quot;bca&quot;のハッシュ値
30025064778 19700001990000198 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;connectを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ハッシュ対象をstringからvector&lt;long long=&quot;&quot;&gt;に変更&lt;/long&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/06/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;constexprによる最適化を実行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/08/31&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;instantを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ローリングハッシュを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc141/tasks/abc141_e&quot;&gt;ABC141-E&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc141/submissions/39997036&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">MOD \(2^{61}-1\)と\(2\)基底を採用しています　例の記事はいったい･･･ 基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？</summary></entry><entry><title type="html">素数mod二項係数</title><link href="http://localhost:4000/library/posts/binomial-coefficient" rel="alternate" type="text/html" title="素数mod二項係数" /><published>2023-03-18T00:00:00+09:00</published><updated>2023-03-18T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/binomial%20coefficient</id><content type="html" xml:base="http://localhost:4000/library/posts/binomial-coefficient">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、combを実行するのに必要な数値(階乗とその逆元)を前計算する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;binomial_coefficient&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;extension&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initで用意した範囲で足りない場合、整数\(N\)を与えると不足分を追加で前計算する&lt;/li&gt;
  &lt;li&gt;計算量は実行前のサイズを\(s\)として、\(Ο(N-s+log(MOD))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;comb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(n,r\)を与えると、\(\frac{n!}{r!(n-r)!}\)を\(MOD\)で割った余りを返す&lt;/li&gt;
  &lt;li&gt;もしこれを計算するための前計算が不足している場合、ちょうど補完するようにextensionが実行される&lt;/li&gt;
  &lt;li&gt;このため、計算量を気にしなければinitは呼ばなくても良い&lt;/li&gt;
  &lt;li&gt;また最初にinitに十分な値を与えていればextensionは呼ばれない&lt;/li&gt;
  &lt;li&gt;計算量はextensionのもの+\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/binomial%20coefficient.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class binomial_coefficient{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const long long MOD = 998244353;
    int sze = 0;
    std::vector&amp;lt;long long&amp;gt; fact;
    std::vector&amp;lt;long long&amp;gt; factinv;
    
    long long Gfinv(long long b){
        long long r=1;
        long long e=MOD-2;
        while(e){
            if(e&amp;amp;1){
                r=(r*b)%MOD;
            }
                b=(b*b)%MOD;
                e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    public:
    
    void init(int N){
        if(N&amp;lt;0){
            return ;
        }
        sze = N+1;
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[0]=1;
        for(long long i=1;i&amp;lt;=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i&amp;gt;=0;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
    }
    
    binomial_coefficient(int N){
        init(N);
    }
    
    void extension(int N){
        if(sze&amp;gt;N &amp;amp;&amp;amp; sze!=0){
            return ;
        }
        
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[sze]=(sze==0)?1:(fact[sze-1]*sze)%MOD;
        
        for(long long i=sze+1;i&amp;lt;=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i&amp;gt;=sze;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
        sze = N+1;
    }
    
    long long comb(long long n,long long r){
        if(n&amp;lt;0 || r&amp;lt;0 || n&amp;lt;r){
            return 0;
        }
        
        if(n&amp;gt;=sze){
            extension(n);
        }
        
        long long R = fact[n];
        R = (R*factinv[r])%MOD;
        R = (R*factinv[n-r])%MOD;
        return R;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class binomial_coefficient{/*省略*/};

int main(void){
    
    binomial_coefficient BC(10);
    for(int i=0;i&amp;lt;=5;i++){
        for(int j=0;j&amp;lt;=5;j++){
            std::cout &amp;lt;&amp;lt; BC.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 0 0 0 0 0 
1 1 0 0 0 0 
1 2 1 0 0 0 
1 3 3 1 0 0 
1 4 6 4 1 0 
1 5 10 10 5 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;名称を二項係数から素数mod二項係数に変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/02/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;nを指定してvectorを返す形式からclass化しn,rからnCrを返す形式に変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二項係数を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 整数\(N\)を与えると、combを実行するのに必要な数値(階乗とその逆元)を前計算する 計算量は\(Ο(N)\)</summary></entry><entry><title type="html">任意mod二項係数</title><link href="http://localhost:4000/library/posts/composite-binomial-coefficient" rel="alternate" type="text/html" title="任意mod二項係数" /><published>2023-03-18T00:00:00+09:00</published><updated>2023-03-18T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/composite-binomial-coefficient</id><content type="html" xml:base="http://localhost:4000/library/posts/composite-binomial-coefficient">&lt;p&gt;計算量の異なる \(2\) つのコードがある&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/composite%20binomial%20coefficient.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#その１&quot;&gt;その１&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;\(n,r \leq 10^{18}, mod \leq 10^6\) 程度の場合に計算できる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#その２&quot;&gt;その２&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;\(n,r \leq 10^6, mod \leq 10^9\) 程度の場合に計算できる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;その１&quot;&gt;その１&lt;/h2&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mod \(M\)を与えると、combを実行するのに必要な数値を前計算する&lt;/li&gt;
  &lt;li&gt;計算量は \(M\) の素因数分解を \(\prod_{i=1}^{\omega(M)}{ {p_i}^{e_i}}\) とすると \(Ο( \sum_{i=1}^{\omega(M)}{ {p_i}^{e_i}} + \sqrt{M})\)
    &lt;ul&gt;
      &lt;li&gt;\(\omega(m)\) は \(m\) の素因数の個数、\(m \leq 10^9\) のとき \(\omega(m) \leq 10\)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;composite_binomial_coefficient_1&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;comb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(n,r\)を与えると、\(\frac{n!}{r!(n-r)!}\)を\(M\)で割った余りを返す&lt;/li&gt;
  &lt;li&gt;extensionはないため、\(n\) にinitで与えた \(N\) より大きい値を与えた場合の挙動は保証しない&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο( (\log n + \log M) \omega(M) )\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class composite_binomial_coefficient_1{
    /*
    Copyright (c) 2023 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    long long Mod;    
    std::vector&amp;lt;std::array&amp;lt;long long,3&amp;gt;&amp;gt; P;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; fact,factinv;

    std::pair&amp;lt;long long,long long&amp;gt; bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair&amp;lt;long long,long long&amp;gt; D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(long long M){

        if(M&amp;lt;1){
            return;
        }

        Mod = M;

        //Mを素因数分解する
        //Pは{素数,個数,素数^個数}
        P.clear();
        long long m = M;
        for(int i=2;i*i&amp;lt;=m;i++){
            int v = 1;
            int e = 0;
            while(m%i==0){
                e++;
                m /= i;
                v *= i;
            }
            if(e&amp;gt;0){
                P.push_back({i,e,v});
            }
        }
        if(m!=1){
            P.push_back({m,1,m});
        }

        //用いる素数pについて、(x!)_p := (1~xでpと互いに素なものの積)を求める
        fact.clear();
        fact.resize(P.size());
        factinv.clear();
        factinv.resize(P.size());

        for(int i=0;i&amp;lt;(int)P.size();i++){
            fact[i].resize(P[i][2]);
            fact[i][0] = 1;
            for(int j=1;j&amp;lt;P[i][2];j++){
                if(j%P[i][0]==0){
                    fact[i][j] = fact[i][j-1];
                }else{
                    fact[i][j] = (fact[i][j-1]*j)%P[i][2];
                }
            }

            factinv[i].resize(P[i][2]);
            factinv[i][P[i][2]-1] = bezout(fact[i][P[i][2]-1],P[i][2]).first;
            if(factinv[i][P[i][2]-1]&amp;lt;0)factinv[i][P[i][2]-1] += P[i][2];
            
            for(int j=P[i][2]-2;j&amp;gt;=0;j--){
                if((j+1)%P[i][0]==0){
                    factinv[i][j] = factinv[i][j+1];
                }else{
                    factinv[i][j] = (factinv[i][j+1]*(j+1))%P[i][2];
                }
            }
        }
    }

    composite_binomial_coefficient_1(long long mod){
        init(mod);
    }

    long long comb(long long n,long long r){
        
        if(n&amp;lt;0 || r&amp;lt;0 || n&amp;lt;r || Mod==1){
            return 0;
        }
        long long k = n-r;

        //各p^qについてnCr mod p^qを求めてLにまとめる
        std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; L(P.size());

        for(int i=0;i&amp;lt;(int)P.size();i++){
            long long p = P[i][0], q = P[i][1], pq = P[i][2];

            std::vector&amp;lt;long long&amp;gt; N,K,R;
            long long nown = n, nowk = k, nowr = r;
            while(nown&amp;gt;0){
                N.push_back(nown%pq);
                K.push_back(nowk%pq);
                R.push_back(nowr%pq);
                nown /= p;
                nowk /= p;
                nowr /= p;
            }

            long long e0 = 0, e1 = 0;
            nown = n/p, nowk = k/p, nowr = r/p;
            while(nown &amp;gt; 0){
                e0 += nown;
                e0 -= nowk;
                e0 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            nown = n/pq, nowk = k/pq, nowr = r/pq;
            while(nown &amp;gt; 0){
                e1 += nown;
                e1 -= nowk;
                e1 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            
            long long T = 1;
            if((p!=2 || q&amp;lt;3) &amp;amp;&amp;amp; e1%2 == 1){
                T = pq-1;
            }

            for(int j=0;j&amp;lt;(int)N.size();j++){
                T = (T*fact[i][N[j]])%pq;
                T = (T*factinv[i][K[j]])%pq;
                T = (T*factinv[i][R[j]])%pq;
            }

            for(int j=0;j&amp;lt;std::min(q,e0);j++){
                T = (T*p)%pq;
            }

            L[i] = {T,pq};
        }

        //中国剰余定理を用いて復元する
        std::pair&amp;lt;long long,long long&amp;gt; C = L[0];
        for(int i=1;i&amp;lt;(int)P.size();i++){
            long long q = C.second*L[i].second;
            std::pair&amp;lt;long long,long long&amp;gt; u = bezout(C.second,L[i].second);
            long long c = (((C.first*L[i].second)%q)*u.second)%q;
            long long d = (((L[i].first*C.second)%q)*u.first)%q;
            C.first = (c+d+q)%q;
            C.second = q;
        }

        return C.first;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例&quot;&gt;使用例&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;実行コード&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class composite_binomial_coefficient_1{/*省略*/};

int main(void){
    
    std::cout &amp;lt;&amp;lt; &quot;10で割ったあまり&quot; &amp;lt;&amp;lt; std::endl; 
    composite_binomial_coefficient_1 CBC(10);
    for(int i=0;i&amp;lt;=8;i++){
        for(int j=0;j&amp;lt;=i;j++){
            std::cout &amp;lt;&amp;lt; CBC.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;

    std::cout &amp;lt;&amp;lt; &quot;もとの値&quot; &amp;lt;&amp;lt; std::endl;
    composite_binomial_coefficient_1 CBC_origin(1000);
    for(int i=0;i&amp;lt;=8;i++){
        for(int j=0;j&amp;lt;=i;j++){
            std::cout &amp;lt;&amp;lt; CBC_origin.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10で割ったあまり
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

もとの値
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h3&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意mod二項係数を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://judge.yosupo.jp/problem/binomial_coefficient&quot;&gt;Library Checker&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://judge.yosupo.jp/submission/130133&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;その２&quot;&gt;その２&lt;/h2&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)とmod \(M\)を与えると、combを実行するのに必要な数値を前計算する&lt;/li&gt;
  &lt;li&gt;計算量は \(Ο(N \log N + N \omega(M) + \sqrt{M})\)
    &lt;ul&gt;
      &lt;li&gt;\(\omega(m)\) は \(m\) の素因数の個数、\(m \leq 10^9\) のとき \(\omega(m) \leq 10\)
&lt;!-- √M + Nω(M) + Ω(N!) , もっとタイトな評価ができそう --&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;composite_binomial_coefficient_2&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;comb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(n,r\)を与えると、\(\frac{n!}{r!(n-r)!}\)を\(M\)で割った余りを返す&lt;/li&gt;
  &lt;li&gt;extensionはないため、\(n\) にinitで与えた \(N\) より大きい値を与えた場合の挙動は保証しない&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\log M + \omega(M) )\)
    &lt;ul&gt;
      &lt;li&gt;特に、 \(n,r\) に依存しない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class composite_binomial_coefficient_2{
    /*
    Copyright (c) 2023 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int sze = 0;
    long long Mod;
    std::vector&amp;lt;long long&amp;gt; P;
    std::vector&amp;lt;long long&amp;gt; d,prime;
    std::vector&amp;lt;int&amp;gt; index;
    std::vector&amp;lt;long long&amp;gt; factPri;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; factRel;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; power;

    std::pair&amp;lt;long long,long long&amp;gt; bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair&amp;lt;long long,long long&amp;gt; D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(int N,long long M){

        if(N&amp;lt;0 || M&amp;lt;1){
            return;
        }

        if(M==1){
            Mod = M;
            return;
        }

        sze = N+1;
        Mod = M;
        
        //1~Nの非自明な約数を求める
        d.resize(N+1);
        std::fill(d.begin(),d.end(),0);
        prime.clear();
        index.resize(N+1);
        std::fill(index.begin(),index.end(),-1);

        if(N&amp;gt;0){
            d[1] = 1;
        }
        for(long long i=2;i&amp;lt;=N;i++){
            if(d[i]==0){
                d[i]=i;
                prime.push_back(i);
            }
            for(int j=0;j&amp;lt;(int)prime.size() &amp;amp;&amp;amp; prime[j]&amp;lt;=d[i] &amp;amp;&amp;amp; i*prime[j]&amp;lt;=N ;j++){
                d[prime[j]*i]=prime[j];
            }
        }
        
        //法が含む素数のリストを求める
        P.clear();
        for(int i=2;i*i&amp;lt;=M;i++){
            int e = 0;
            while(M%i==0){
                e++;
                M /= i;
            }
            if(e&amp;gt;0){
                if(i&amp;lt;=N)index[i] = P.size();
                P.push_back(i);
            }
        }
        if(M!=1){
            if(M&amp;lt;=N)index[M] = P.size();
            P.push_back(M);
        }

        //k!について、Mと互いに素である部分とそうでない部分に分けてそれぞれ求める
        factPri.resize(N+1);
        std::fill(factPri.begin(),factPri.end(),1);
        factRel.resize(N+1);
        for(int i=0;i&amp;lt;=N;i++){
            factRel[i].resize(P.size());
            std::fill(factRel[i].begin(),factRel[i].end(),0);
        }

        for(int i=2;i&amp;lt;=N;i++){

            factPri[i] = factPri[i-1];
            factRel[i] = factRel[i-1];

            long long now = i;
            while(now&amp;gt;1){
                long long p = d[now];
                if(index[p]==-1){
                    factPri[i] = (factPri[i]*p)%Mod;
                }else{
                    factRel[i][index[p]]++;
                }
                now /= p;
            }
        }

        //p^0,p^1,...,p^(N/p)を前計算する
        power.resize(P.size());
        for(int i=0;i&amp;lt;(int)P.size();i++){
            power[i].resize(1+N/P[i]);
            power[i][0] = 1;
            for(int j=1;j&amp;lt;1+N/P[i];j++){
                power[i][j] = (power[i][j-1]*P[i])%Mod;
            }
        }

    }

    composite_binomial_coefficient_2(int N,long long M){
        init(N,M);
    }

    long long comb(long long n,long long r){
        if(Mod==1){
            return 0;
        }
        if(n&amp;lt;0 || r&amp;lt;0 || n&amp;lt;r){
            return 0;
        }

        long long R = factPri[n];
        long long m = bezout(factPri[r],Mod).first;
        if(m&amp;lt;0)m+=Mod;
        R = (R*m)%Mod;
        m = bezout(factPri[n-r],Mod).first;
        if(m&amp;lt;0)m+=Mod;
        R = (R*m)%Mod;

        for(int i=0;i&amp;lt;(int)P.size();i++){
            int e = factRel[n][i] - factRel[r][i] - factRel[n-r][i];
            assert(e&amp;gt;=0);
            R = (R*power[i][e])%Mod;
        }

        return R;
    }

};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-1&quot;&gt;使用例&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;実行コード-1&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class composite_binomial_coefficient_2{/*省略*/};

int main(void){
    
    std::cout &amp;lt;&amp;lt; &quot;10で割ったあまり&quot; &amp;lt;&amp;lt; std::endl; 
    composite_binomial_coefficient_2 CBC(8,10);
    for(int i=0;i&amp;lt;=8;i++){
        for(int j=0;j&amp;lt;=i;j++){
            std::cout &amp;lt;&amp;lt; CBC.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;

    std::cout &amp;lt;&amp;lt; &quot;もとの値&quot; &amp;lt;&amp;lt; std::endl;
    composite_binomial_coefficient_2 CBC_origin(8,1000);
    for(int i=0;i&amp;lt;=8;i++){
        for(int j=0;j&amp;lt;=i;j++){
            std::cout &amp;lt;&amp;lt; CBC_origin.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-1&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10で割ったあまり
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

もとの値
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新履歴-1&quot;&gt;更新履歴&lt;/h3&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意mod二項係数を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題-1&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc012/tasks/arc012_4&quot;&gt;ARC012-D&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc012/submissions/39798965&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">計算量の異なる \(2\) つのコードがある</summary></entry><entry><title type="html">Moのアルゴリズム</title><link href="http://localhost:4000/library/posts/mos-algorithm" rel="alternate" type="text/html" title="Moのアルゴリズム" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/mos-algorithm</id><content type="html" xml:base="http://localhost:4000/library/posts/mos-algorithm">&lt;p&gt;すもももももももものうち&lt;/p&gt;

&lt;p&gt;いくつかの半開区間 \([l_i,r_i)\) についての答えを高速に求める
\([l,r)\) での答えがわかっているとき、隣接する区間 \([l-1,r),[l+1,r),[l,r-1),[l,r+1)\) についての答えが高速にわかる場合に有効&lt;/p&gt;

&lt;p&gt;第一引数に区間全体の長さ \(N\) 、第二引数にクエリの数 \(Q\) 、第三引数にクエリのリスト、そして第四～第七引数にはそれぞれ&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\([l,r)\) の答えから \([l-1,r)\) の答えを求める関数&lt;/li&gt;
  &lt;li&gt;\([l,r)\) の答えから \([l+1,r)\) の答えを求める関数&lt;/li&gt;
  &lt;li&gt;\([l,r)\) の答えから \([l,r-1)\) の答えを求める関数&lt;/li&gt;
  &lt;li&gt;\([l,r)\) の答えから \([l,r+1)\) の答えを求める関数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を与えると、各クエリに対しての答えをvectorで返す&lt;/p&gt;

&lt;p&gt;計算量は第四～第七引数で与えた関数の計算量を \(f\) とすると \(Ο(Q \log Q + N \sqrt{Q} f)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/mos-algorithm.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; Mo(int N,int Q,std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; X, 
std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lm, std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lp, 
std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rm, std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rp){
    /*
    Copyright (c) 2023 0214sh7
    https://github.com/0214sh7/library/
    */
    int rQ;
    std::map&amp;lt;std::pair&amp;lt;int,int&amp;gt;,std::vector&amp;lt;int&amp;gt;&amp;gt; index;
    std::vector&amp;lt;int&amp;gt; block(N,0);
    std::vector&amp;lt;long long&amp;gt; Ans(Q);

    std::function&amp;lt;bool(std::pair&amp;lt;int,int&amp;gt;, std::pair&amp;lt;int,int&amp;gt;)&amp;gt; comp = [&amp;amp;](std::pair&amp;lt;int,int&amp;gt; A,std::pair&amp;lt;int,int&amp;gt; B){
        if(block[A.first]!=block[B.first]){
            return (block[A.first]&amp;lt;block[B.first]);
        }
        if(A.second != B.second){
            return (A.second &amp;lt; B.second);
        }
        return (A.first &amp;lt; B.first);
    };

    for(int i=0;i&amp;lt;Q;i++){
        index[X[i]].push_back(i+1);
    }
    int q = index.size();

    rQ = 1;
    while((rQ+1)*(rQ+1)&amp;lt;=q)rQ++;

    int now = 0;
    for(int i=0;i&amp;lt;rQ-1;i++){
        now += ((N+rQ-1-i)/rQ);
        block[now]++;
    }
    for(int i=0;i&amp;lt;N-1;i++){
        block[i+1] += block[i];
    }

    std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; Y(q);
    now = 0;
    for(auto e:index){
        Y[now] = e.first;
        now++;
    }

    std::sort(Y.begin(),Y.end(),[&amp;amp;](auto a, auto b){return comp(a, b);});

    int L = 0,R = 0;
    long long Result = 0;

    for(int i=0;i&amp;lt;q;i++){
        
        while(Y[i].first &amp;lt; L){
            lm(L,Result);
            L--;
        }
        while(R &amp;lt; Y[i].second){
            rp(R,Result);
            R++;
        }
        while(L &amp;lt; Y[i].first){
            lp(L,Result);
            L++;
        }
        while(Y[i].second &amp;lt; R){
            rm(R,Result);
            R--;
        }

        for(int k:index[Y[i]]){
            Ans[k-1] = Result;
        }

    }

    return Ans;

    //lm(i): [i,r)を[i-1,r)にする
    //lp(i): [i,r)を[i+1,r)にする
    //rm(i): [i,r)を[i,r-1)にする
    //rp(i): [i,r)を[i,r+1)にする

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
\(A = (1,2,3,4,5)\) の \([l,r)\) の和を求める&lt;/p&gt;

&lt;p&gt;これは \([l,r)\) の和がわかっていれば \([l-1,r),[l+1,r),[l,r-1),[l,r+1)\) の和が \(O(1)\) でわかる&lt;br /&gt;
例えば \([1,3)\) の和が \(A_1 + A_2 = 2 + 3 = 5\) であることがわかっていれば \([1,4)\) の和は \(5 + A_3 = 5 + 4 = 9\) であることがわかる&lt;/p&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;long long&amp;gt; Mo(int N,int Q,std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; X, 
std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lm, std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lp, 
std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rm, std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rp){/*省略*/}

int main(void){
    
    int N = 5, Q = 15;
    std::vector&amp;lt;long long&amp;gt; A = {1,2,3,4,5};
    std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; LR = {
        {0,1},
        {0,2},
        {0,3},
        {0,4},
        {0,5},
        {1,2},
        {1,3},
        {1,4},
        {1,5},
        {2,3},
        {2,4},
        {2,5},
        {3,4},
        {3,5},
        {4,5},
    };
    
    std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lm = [&amp;amp;](int i,long long&amp;amp; res){
        res += A[i-1];
    };

    std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; lp = [&amp;amp;](int i,long long&amp;amp; res){
        res -= A[i];
    };

    std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rm = [&amp;amp;](int i,long long&amp;amp; res){
        res -= A[i-1];
    };

    std::function&amp;lt;void(int,long long&amp;amp;)&amp;gt; rp = [&amp;amp;](int i,long long&amp;amp; res){
        res += A[i];
    };


    std::vector&amp;lt;long long&amp;gt; Ans = Mo(N,Q,LR,lm,lp,rm,rp);

    for(int i=0;i&amp;lt;(int)Ans.size();i++){
        std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; LR[i].first &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; LR[i].second &amp;lt;&amp;lt; &quot;)  &quot; &amp;lt;&amp;lt; Ans[i] &amp;lt;&amp;lt; std::endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[0,1)  1
[0,2)  3
[0,3)  6
[0,4)  10
[0,5)  15
[1,2)  2
[1,3)  5
[1,4)  9
[1,5)  14
[2,3)  3
[2,4)  7
[2,5)  12
[3,4)  4
[3,5)  9
[4,5)  5

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2023/03/13&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Moのアルゴリズムを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc293/tasks/abc293_g&quot;&gt;ABC293-G&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc293/submissions/39690323&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">すもももももももものうち</summary></entry><entry><title type="html">ランレングス圧縮</title><link href="http://localhost:4000/library/posts/run-length-encode" rel="alternate" type="text/html" title="ランレングス圧縮" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/run-length-encode</id><content type="html" xml:base="http://localhost:4000/library/posts/run-length-encode">&lt;p&gt;文字列\(S\)を与えると、\(S\)をランレングス圧縮(連長圧縮)して返す&lt;/p&gt;

&lt;p&gt;ランレングス圧縮とは、文字列を「文字と、それがいくつ続くか」の組に変換するものである
ちなみに可逆変換&lt;/p&gt;

&lt;p&gt;計算量は\(Ο(\vert S \vert)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/runlength%20encode.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;char,int&amp;gt;&amp;gt; runlength_encode(std::string S){
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;std::pair&amp;lt;char,int&amp;gt;&amp;gt; R;
    for(int i=0;i&amp;lt;(int)S.size();i++){
        if(i==0 || S[i]!=S[i-1]){
            R.push_back({S[i],1});
        }else{
            R.back().second++;
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;std::pair&amp;lt;char,int&amp;gt;&amp;gt; runlength_encode(std::string S){/*省略*/}

int main(void){
    
    std::string S = &quot;abbcccddeeeacddd&quot;;
    std::vector&amp;lt;std::pair&amp;lt;char,int&amp;gt;&amp;gt; R = runlength_encode(S);
    for(int i=0;i&amp;lt;(int)R.size();i++){
        std::cout &amp;lt;&amp;lt; R[i].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; R[i].second &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a 1
b 2
c 3
d 2
e 3
a 1
c 1
d 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/07/10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ランレングス圧縮を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc259/tasks/abc259_c&quot;&gt;ABC259-C&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc259/submissions/33129519&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">文字列\(S\)を与えると、\(S\)をランレングス圧縮(連長圧縮)して返す</summary></entry><entry><title type="html">反復写像</title><link href="http://localhost:4000/library/posts/iterated-function" rel="alternate" type="text/html" title="反復写像" /><published>2022-07-03T00:00:00+09:00</published><updated>2022-07-03T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/iterated-function</id><content type="html" xml:base="http://localhost:4000/library/posts/iterated-function">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数列\(F\)を与えると、すべての整数 \(x (0 \leq x &amp;lt; \vert F \vert)\) について \(f(x) = F[x]\) となるように関数 \(f\) を設定する&lt;/li&gt;
  &lt;li&gt;計算量は\(N=\vert F \vert\)とし、\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iterated_function&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数 \(x\) であって\(0 \leq x &amp;lt; N\) を満たすようなものと非負整数 \(k\) を与えると、\(\overbrace{f(f(\cdots f}^{k}(x)))\) を求め、返す&lt;/li&gt;
  &lt;li&gt;もし\(k = 0\)なら\(x\)そのものを返す&lt;/li&gt;
  &lt;li&gt;範囲外なら\(-1\)を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N \log k)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/iterated%20function.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class iterated_function{
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; T[64];
    int N;
    
    public:
    void init(std::vector&amp;lt;int&amp;gt; F){
        N = F.size();
        T[0] = F;
        for(int j=1;j&amp;lt;64;j++){
            T[j].resize(N);
            for(int i=0;i&amp;lt;N;i++){
                T[j][i] = T[j-1][T[j-1][i]];
            }
        }
        
    }

    iterated_function(std::vector&amp;lt;int&amp;gt; F){
        init(F);
    }

    int solve(int x,long long k){
        if(!(0&amp;lt;=x &amp;amp;&amp;amp; x&amp;lt;N) || k&amp;lt;0){
            return -1;
        }

        int y = x;
        for(int i=0;(k&amp;gt;&amp;gt;i)&amp;gt;0;i++){
            if((k&amp;gt;&amp;gt;i)%2==1){
                y = T[i][y];
            }
        }

        return y;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class iterated_function{/*省略*/};

int main() {
    
    std::vector&amp;lt;int&amp;gt; F = {1,2,3,4,5,2};
    iterated_function func(F);

    std::cout &amp;lt;&amp;lt; &quot;0からk回辿ったときの頂点&quot; &amp;lt;&amp;lt; std::endl;
    for(int k=0;k&amp;lt;=15;k++){
        std::cout &amp;lt;&amp;lt; func.solve(0,k) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    std::cout &amp;lt;&amp;lt; &quot;各頂点から3回辿ったときの頂点&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;6;i++){
        std::cout &amp;lt;&amp;lt; func.solve(i,3) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0からk回辿ったときの頂点
0 1 2 3 4 5 2 3 4 5 2 3 4 5 2 3 

各頂点から3回辿ったときの頂点
3 4 5 2 3 4 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/07/03&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;反復写像を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;確認した問題&quot;&gt;確認した問題&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;問題&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;提出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc167/tasks/abc167_d&quot;&gt;ABC167-D&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc167/submissions/32945330&quot;&gt;提出&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 数列\(F\)を与えると、すべての整数 \(x (0 \leq x &amp;lt; \vert F \vert)\) について \(f(x) = F[x]\) となるように関数 \(f\) を設定する 計算量は\(N=\vert F \vert\)とし、\(Ο(N)\)</summary></entry><entry><title type="html">セグメント木</title><link href="http://localhost:4000/library/posts/segmenttree" rel="alternate" type="text/html" title="セグメント木" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/segment-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/segmenttree">&lt;p&gt;単にセグ木と言えばこれを指す、最も単純なセグ木&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一引数で整数\(N\)を与えると、要素が\(N\)個入る最小サイズの完全二分木を構成し、すべての要素を単位元で初期化する&lt;/li&gt;
  &lt;li&gt;また第二･第三引数でセグ木に乗せる演算とその単位元を与えるとその演算を乗せる&lt;/li&gt;
  &lt;li&gt;演算がモノイドでない場合の動作は保証しない&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;segmenttree&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;update&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(k\)番目(0-indexed)の要素を\(a\)で更新し、それが影響するノードを全て更新する&lt;/li&gt;
  &lt;li&gt;計算量はinitの\(N\)を用いて、\(Ο(logN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;query&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\([a,b)\)の範囲内にある要素をcalcで計算した結果をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(b-a))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
class segmenttree{
    /*
    Copyright (c) 2022 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int n;
    
    std::vector&amp;lt;T&amp;gt; dat;
    std::function&amp;lt;T(T,T)&amp;gt; calc;
    T identity;
    public:
    
    void init(int N,std::function&amp;lt;T(T,T)&amp;gt; func,T Identity){
        n=1;
        while(n&amp;lt;N)n*=2;
        dat.resize(2*n-1);
        for(int i=0;i&amp;lt;2*n-1;++i){
            dat[i]=Identity;
        }
        calc = func;
        identity = Identity;
    }
    
    segmenttree(int N,std::function&amp;lt;T(T,T)&amp;gt; func,T Identity){
        init(N,func,Identity);
    }
    
    void update(int k,T a){
        k+=n-1;
        dat[k]=a;
        while(k&amp;gt;0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    T query(int a,int b){
        a+=n-1;
        b+=n-1;
        T L= identity,R = identity;
        while(a &amp;lt; b){
            if(a % 2 == 0){
                L = calc(L,dat[a]);
                a++;
            }
            a = (a-1)/2;
            if(b % 2 == 0){
                R = calc(dat[b-1],R);
                b--;
            }
            b = (b-1)/2;
        }
        R = calc(L,R);
        return R;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

template&amp;lt;typename T&amp;gt;
class segmenttree{/*省略*/};

int main(void){
    
    long long N = 6;
    std::vector&amp;lt;long long&amp;gt; A = {100000,20000,3000,400,50,6};
    std::function&amp;lt;long long(long long,long long)&amp;gt; func = [](long long a,long long b){
        return a+b;
    };
    
    segmenttree&amp;lt;long long&amp;gt; segtree(N,func,0);
    for(int i=0;i&amp;lt;N;i++){
        segtree.update(i,A[i]);
    }
    
    std::cout &amp;lt;&amp;lt; segtree.query(0,3) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(0,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(2,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(3,5) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(5,6) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123000
123456
3456
450
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/01/30&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2022/01/30&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意の型に対応&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/10/10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;セグメント木を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">単にセグ木と言えばこれを指す、最も単純なセグ木</summary></entry><entry><title type="html">ディニッツ法</title><link href="http://localhost:4000/library/posts/dinic" rel="alternate" type="text/html" title="ディニッツ法" /><published>2021-11-01T00:00:00+09:00</published><updated>2021-11-01T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/dinic</id><content type="html" xml:base="http://localhost:4000/library/posts/dinic">&lt;p&gt;Dinicの読み方これでいいのかな&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、頂点を\(N\)個生成しフローの計算に必要なメモリを確保する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dinic&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;add&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(from\)から\(end\)にかけて容量\(cap\)の有向辺を張る&lt;/li&gt;
  &lt;li&gt;計算量は\(O(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(s\)を始点、頂点\(t\)を終点としてフローの最大値を求める&lt;/li&gt;
  &lt;li&gt;計算量はinitで与えた頂点の数を\(V\)、addで与えた辺の数を\(E\)として\(Ο(E V^2)\)&lt;/li&gt;
  &lt;li&gt;実際はこれよりも高速に動作する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/dinic.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dinic{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    struct edge{
        int end;
        long long cap,rev;
        
    };
    
    const long long INF = (1LL&amp;lt;&amp;lt;61);
    int V;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G;
    std::vector&amp;lt;long long&amp;gt; level;
    std::vector&amp;lt;int&amp;gt; iter;
    
    void Dinic_bfs(int s){
        for(int i=0;i&amp;lt;V;i++){
            level[i]=-1;
        }
        std::queue&amp;lt;int&amp;gt; que;
        level[s]=0;
        que.push(s);
        while(!que.empty()){
            int v=que.front();
            que.pop();
            for(unsigned int i=0;i&amp;lt;G[v].size();i++){
                edge &amp;amp;e = G[v][i];
                if(e.cap&amp;gt;0 &amp;amp;&amp;amp; level[e.end]&amp;lt;0){
                    level[e.end]=level[v]+1;
                    que.push(e.end);
                }
            }
        }
    }
    
    long long Dinic_dfs(int v,int t,long long f){
        if(v==t)return f;
        for(int &amp;amp;i=iter[v];i&amp;lt;G[v].size();i++){
            edge &amp;amp;e = G[v][i];
            if(e.cap&amp;gt;0 &amp;amp;&amp;amp; level[v]&amp;lt;level[e.end]){
                long long d = Dinic_dfs(e.end,t,std::min(f,e.cap));
                if(d&amp;gt;0){
                    e.cap -= d;
                    G[e.end][e.rev].cap+=d;
                    return d;
                }
            }
        }
        return 0;
    }
    
    public:
    
    void init(int N){
        V = N;
        G.clear();
        G.resize(V);
        level.resize(V);
        iter.resize(V);
    }
    
    Dinic(int N){
        init(N);
    }
    
    void add(int from,int end,long long cap){
        G[from].push_back((edge){end,cap,(long long)G[end].size()});
        G[end].push_back((edge){from,0,(long long)G[from].size()-1});
    }
    
    long long solve(int s,int t){
        long long flow=0;
        while(1){
            Dinic_bfs(s);
            if(level[t]&amp;lt;0){return flow;}
            for(int i=0;i&amp;lt;V;i++){
                iter[i]=0;
            }
            long long f;
            while((f=Dinic_dfs(s,t,INF))&amp;gt;0){
                flow+=f;
            }
        }
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class Dinic{/*省略*/};


int main(void){
    
    Dinic dinitz(5);
    dinitz.add(0,1,4);
    dinitz.add(0,2,2);
    dinitz.add(1,2,1);
    dinitz.add(1,3,2);
    dinitz.add(2,3,4);
    dinitz.add(2,4,2);
    dinitz.add(3,4,4);
    
    //このグラフでは頂点0から頂点4へは最大で5つ流れる
    //例えば0-&amp;gt;2-&amp;gt;4に2つ、0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4に1つ、0-&amp;gt;1-&amp;gt;3-&amp;gt;4に2つなどが考えられる
    long long R = dinitz.solve(0,4);
    std::cout &amp;lt;&amp;lt; R &amp;lt;&amp;lt; std::endl;
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;githubリンクを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ディニッツ法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">Dinicの読み方これでいいのかな</summary></entry><entry><title type="html">偏角ソート</title><link href="http://localhost:4000/library/posts/arg-sort" rel="alternate" type="text/html" title="偏角ソート" /><published>2021-10-31T00:00:00+09:00</published><updated>2021-10-31T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/arg-sort</id><content type="html" xml:base="http://localhost:4000/library/posts/arg-sort">&lt;p&gt;数列\(A\)を与えると、以下の並べ方で\(A\)をソートして返す
基準を第二変数\(d\)(デフォルトでは\((1,0)\))で定めることもできる&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;偏角(のうち、\([\arg(d),\arg(d)+2\pi)\)であるもの)が小さい順に並べる&lt;/li&gt;
  &lt;li&gt;それが同じ場合、絶対値が小さい順に並べる&lt;/li&gt;
  &lt;li&gt;\((0,0)\)が含まれる場合assertして停止する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;計算量は\(Ο(\vert A \vert log \vert A \vert)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/arg%20sort.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; arg_sort(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A,std::pair&amp;lt;long long,long long&amp;gt; d = {1,0}){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    long long N = A.size();
    assert(d.first != 0 || d.second != 0);
    long long g = std::gcd(d.first,d.second);
    d.first/=g;d.second/=g;
    A.push_back(d);
    std::sort(A.begin(),A.end(),[&amp;amp;](std::pair&amp;lt;long long,long long&amp;gt; x, std::pair&amp;lt;long long,long long&amp;gt; y){
        assert(x.first != 0 || x.second != 0);
        assert(y.first != 0 || y.second != 0);
        
        long long a,b;
        if(x.first&amp;gt;0 &amp;amp;&amp;amp; x.second==0){
            a=0;
        }else if(x.first&amp;gt;0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=1;
        }else if(x.first==0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=2;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second&amp;gt;0){
            a=3;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second==0){
            a=4;
        }else if(x.first&amp;lt;0 &amp;amp;&amp;amp; x.second&amp;lt;0){
            a=5;
        }else if(x.first==0 &amp;amp;&amp;amp; x.second&amp;lt;0){
            a=6;
        }else{
            a=7;
        }
        
        if(y.first&amp;gt;0 &amp;amp;&amp;amp; y.second==0){
            b=0;
        }else if(y.first&amp;gt;0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=1;
        }else if(y.first==0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=2;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second&amp;gt;0){
            b=3;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second==0){
            b=4;
        }else if(y.first&amp;lt;0 &amp;amp;&amp;amp; y.second&amp;lt;0){
            b=5;
        }else if(y.first==0 &amp;amp;&amp;amp; y.second&amp;lt;0){
            b=6;
        }else{
            b=7;
        }
        
        if(a!=b){
            return (a&amp;lt;b);
        }
        
        if(a%2==0){
            return (std::abs(x.first+x.second) &amp;lt; std::abs(y.first+y.second));
        }
        
        if(y.first*x.second != x.first*y.second){
           return (y.first*x.second &amp;lt; x.first*y.second);
        }
        
        return abs(x.first) &amp;lt; abs(y.first);
    });
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; B(N);
    for(int i=0;i&amp;lt;N+1;i++){
        if(A[i]==d){
            for(int j=i+1;j&amp;lt;N+1;j++){
                B[j-i-1]=A[j];
            }
            for(int j=0;j&amp;lt;i;j++){
                B[N-i+j]=A[j];
            }
            break;
        }
    }
    
    return B;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;


std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; arg_sort(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A,std::pair&amp;lt;long long,long long&amp;gt; d = {1,0}){/*省略*/}


int main(void){
    
    long long N = 12;
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; A={
        {-3,0},
        {-1,-2},
        {1,2},
        {0,-3},
        {3,0},
        {-2,-1},
        {-2,1},
        {1,-2},
        {2,1},
        {2,-1},
        {0,3},
        {-1,2}
    };
    
    //Aを(1,0)を基準にソート
    A = arg_sort(A);
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; A[i].first &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; A[i].second &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; &quot; &quot;; 
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //Aを(-1,1)を基準にソート
    A = arg_sort(A,{-1,1});
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; A[i].first &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; A[i].second &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; &quot; &quot;; 
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(3,0) (2,1) (1,2) (0,3) (-1,2) (-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) 
(-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) (3,0) (2,1) (1,2) (0,3) (-1,2) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/11/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/10/31&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;偏角ソートを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">数列\(A\)を与えると、以下の並べ方で\(A\)をソートして返す 基準を第二変数\(d\)(デフォルトでは\((1,0)\))で定めることもできる</summary></entry><entry><title type="html">木の直径</title><link href="http://localhost:4000/library/posts/double-sweep" rel="alternate" type="text/html" title="木の直径" /><published>2021-10-15T00:00:00+09:00</published><updated>2021-10-15T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/double-sweep</id><content type="html" xml:base="http://localhost:4000/library/posts/double-sweep">&lt;p&gt;木ではない一般的なグラフでも近似解が出るらしいけどチェックしてません(え？)&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)と頂点数\(N\)の重み付き木を0-indexedのvector&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long»で与えると前計算をし、木の直径が計算できるようになる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;double_sweep&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vertex&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;最も距離が大きくなるような頂点対\((u,v)\)を一つ返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pass&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(v\)の間のパスを返す&lt;/li&gt;
  &lt;li&gt;このときvectorの先頭が\(u\)、最後尾が\(v\)になる&lt;/li&gt;
  &lt;li&gt;計算量はパスの長さを\(P\)として、\(Ο(P)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;diameter&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(u\)と\(v\)の間のパスの重さを出力する&lt;/li&gt;
  &lt;li&gt;計算量はパスの長さを\(P\)として、\(Ο(P)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/double%20sweep.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class double_sweep{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const long long INF = (1LL&amp;lt;&amp;lt;61);
    int V,V1,V2;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int,long long&amp;gt;&amp;gt;&amp;gt; G;
    std::vector&amp;lt;int&amp;gt; parent;
    std::vector&amp;lt;long long&amp;gt; parent_cost;
    long long diam;
    long long temp;
    
    void dfs(int phase,int v,int p,long long d){
        if(phase==1){
            if(d&amp;gt;temp){
                V1 = v;
                temp = d;
            }
        }
        if(phase==2){
            parent[v] = p;
            if(d&amp;gt;temp){
                V2 = v;
                temp = d;
            }
        }
        for(std::pair&amp;lt;int,long long&amp;gt; E:G[v]){
            int e = E.first;
            long long f = E.second;
            if(e!=p){
                dfs(phase,e,v,d+f);
                if(phase==2){
                    parent_cost[e] = f;
                }
            }
        }
    }
    
    public:
    
    void init(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        V = N;
        V1 = 0,V2 = 0;
        
        G.clear();
        G.resize(V);
        for(int i=0;i&amp;lt;edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({to,cost});
            G[to].push_back({from,cost});
        }
        
        parent.resize(V);
        for(int i=0;i&amp;lt;V;i++){
            parent[i] = -1;
        }
        parent_cost.resize(V);
        for(int i=0;i&amp;lt;V;i++){
            parent_cost[i] = -1;
        }
        
        temp = -INF;
        dfs(1,0,-1,0);
        temp = -INF;
        dfs(2,V1,-1,0);
        diam = -1;
    }
    
    double_sweep(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        init(N,edge);
    }
    
    std::pair&amp;lt;int,int&amp;gt; vertex(void){
        return std::make_pair(V2,V1);
    }
    
    std::vector&amp;lt;int&amp;gt; pass(void){
        std::vector&amp;lt;int&amp;gt; R;
        diam = 0;
        int r = V2;
        while(r!=V1){
            R.push_back(r);
            diam += parent_cost[r];
            r = parent[r];
        }
        R.push_back(r);
        return R;
    }
    
    long long diameter(void){
        if(diam==-1){
            pass();
        }
        return diam;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class double_sweep{/*省略*/};

int main(void){
    
    int N = 8;
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge;
    
    edge.push_back({ {0,1},1});
    edge.push_back({ {0,2},2});
    edge.push_back({ {0,3},4});
    edge.push_back({ {1,4},8});
    edge.push_back({ {1,5},16});
    edge.push_back({ {5,6},32});
    edge.push_back({ {5,7},64});
    
    double_sweep DS(N,edge);
    
    
    //直径の端の頂点は6と7
    std::pair&amp;lt;int,int&amp;gt; V = DS.vertex();
    std::cout &amp;lt;&amp;lt; V.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; V.second &amp;lt;&amp;lt; std::endl;
    
    //そのパスは6-5-7
    std::vector&amp;lt;int&amp;gt; P = DS.pass();
    for(int i=0;i&amp;lt;P.size();i++){
        std::cout &amp;lt;&amp;lt; P[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    //重さの和は96
    long long D = DS.diameter();
    std::cout &amp;lt;&amp;lt; D &amp;lt;&amp;lt; std::endl;
    
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6 7
6 5 7 
96
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/10/15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;木の直径を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">木ではない一般的なグラフでも近似解が出るらしいけどチェックしてません(え？)</summary></entry></feed>