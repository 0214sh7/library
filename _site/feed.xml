<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/library/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/library/" rel="alternate" type="text/html" /><updated>2021-04-05T21:21:34+09:00</updated><id>http://localhost:4000/library/feed.xml</id><title type="html">すくライブラリ</title><subtitle>descriptionはない</subtitle><entry><title type="html">数学詰め合わせパック</title><link href="http://localhost:4000/library/posts/basic-math" rel="alternate" type="text/html" title="数学詰め合わせパック" /><published>2021-04-05T00:00:00+09:00</published><updated>2021-04-05T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/basic-math-assortment</id><content type="html" xml:base="http://localhost:4000/library/posts/basic-math">&lt;p&gt;優柔不断なあなたに&lt;/p&gt;

&lt;p&gt;というのは建前で、それぞれ独立して扱うほどではないが重要なものを一箇所に集めた&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/basic%20math%20assortment.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;もくじ&quot;&gt;もくじ&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#小数点以下切り上げ天井関数&quot;&gt;小数点以下切り上げ(天井関数)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#階乗&quot;&gt;階乗&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#最大公約数&quot;&gt;最大公約数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#最小公倍数&quot;&gt;最小公倍数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#約数列挙&quot;&gt;約数列挙&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#素数判定&quot;&gt;素数判定&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#素数列挙&quot;&gt;素数列挙&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#素因数分解&quot;&gt;素因数分解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#累乗繰り返し二乗法&quot;&gt;累乗(繰り返し二乗法)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#逆元素数mod&quot;&gt;逆元(素数MOD)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;小数点以下切り上げ天井関数&quot;&gt;小数点以下切り上げ(天井関数)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;よくある天井関数&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long roundup(long long a,long long b){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    return (a+b-1)/b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long roundup(long long a,long long b){/*省略*/}

int main(void){
    
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; roundup(i,4) &amp;lt;&amp;lt; &quot; &quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 2 3 4 5 6 7 8 9 10 
0 1 1 1 1 2 2 2 2 3 3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;階乗&quot;&gt;階乗&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(x\)に対し\(x!\)を計算する&lt;/li&gt;
  &lt;li&gt;\(MOD\)も与えるとそれで割った余りをとる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(x)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long fact(long long x,long long MOD=LLONG_MAX){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    long long k=1;
    for(int i=1;i&amp;lt;=x;i++){
        k=(k*i)%MOD;
    }
    return k;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-1&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-1&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long fact(long long x,long long MOD=LLONG_MAX){/*省略*/}

int main(void){
    
    for(int i=0;i&amp;lt;=6;i++){
        std::cout &amp;lt;&amp;lt; fact(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-1&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 1 2 6 24 120 720 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;最大公約数&quot;&gt;最大公約数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;２つの引数のGCDを求める&lt;/li&gt;
  &lt;li&gt;計算量は\(O(log(max(a,b)))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long gcd(long long a,long long b){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    a=std::abs(a);
    b=std::abs(b);
    if(a&amp;gt;b)std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-2&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-2&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long gcd(long long a,long long b){/*省略*/}

int main(void){
    
    std::cout &amp;lt;&amp;lt; gcd(4,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; gcd(3,5) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; gcd(12,18) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; gcd(8,13) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-2&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2
1
6
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;最小公倍数&quot;&gt;最小公倍数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;２つの引数のLCMを求める&lt;/li&gt;
  &lt;li&gt;計算量は\(O(log(max(a,b)))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long lcm(long long a,long long b){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    if(std::abs(a)&amp;gt;std::abs(b))std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long s=a,t=b;
    a=std::abs(a);
    b=std::abs(b);
    if(a&amp;gt;b)std::swap(a,b);
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    
    return s / b * t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-3&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-3&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long lcm(long long a,long long b){/*省略*/}

int main(void){
    
    std::cout &amp;lt;&amp;lt; lcm(4,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; lcm(3,5) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; lcm(12,18) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; lcm(8,13) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-3&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;12
15
36
104
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;約数列挙&quot;&gt;約数列挙&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自然数\(N\)を与えると、\(N\)の正の約数を小さい順に並べたvectorを返す&lt;/li&gt;
  &lt;li&gt;正でない数を与えると空のvectorを返す&lt;/li&gt;
  &lt;li&gt;計算量は\(O(\sqrt{N})\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; divisor_enum(long long N){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; R;
    if(N&amp;lt;=0)return R;
    long long s=0;
    for(long long i=1;i*i&amp;lt;=N;i++){
        if(N%i==0){
            R.push_back(i);
            if(i*i!=N)s++;
        }
    }
    for(long long i = s-1;i&amp;gt;=0;i--){
        R.push_back(N/R[i]);
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-4&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-4&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;long long&amp;gt; divisor_enum(long long N){/*省略*/}

signed main() {
    
    for(long long i=1;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;  &quot;;
        std::vector&amp;lt;long long&amp;gt; K = divisor_enum(i);
        for(long long j=0;j&amp;lt;K.size();j++){
            std::cout &amp;lt;&amp;lt; K[j] &amp;lt;&amp;lt; &quot; &quot;;
        }
        std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-4&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1  1 
2  1 2 
3  1 3 
4  1 2 4 
5  1 5 
6  1 2 3 6 
7  1 7 
8  1 2 4 8 
9  1 3 9 
10  1 2 5 10 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;素数判定&quot;&gt;素数判定&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(x\)に対し、\(x\)が素数ならtrueを、そうでないならfalseを返す&lt;/li&gt;
  &lt;li&gt;計算量は\(O(\sqrt{x})\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool prime(long long X){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    if(X&amp;lt;2)return false;
    for(long long i=2;i*i&amp;lt;=X;i++){
        if(X%i==0){
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-5&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-5&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

bool prime(long long X){/*省略*/}

int main(void){
    
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; prime(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-5&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 2 3 4 5 6 7 8 9 10 
0 0 1 1 0 1 0 1 0 0 0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;素数列挙&quot;&gt;素数列挙&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(N\)に対し、\(N\)以下の素数を列挙し、小さい順にvectorとして返す&lt;/li&gt;
  &lt;li&gt;計算量は\(O(NloglogN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; primearray(long long N){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; R;
    std::vector&amp;lt;bool&amp;gt; prime;
    for(int i=0;i&amp;lt;=N;i++){
        prime.push_back(true);
    }
    if(N&amp;lt;2){
        return R;
    }
    prime[0]=false;
    prime[1]=false;
    for(long long i=2;i*i&amp;lt;=N;i++){
        if(!prime[i])continue;
        for(int j=2*i;j&amp;lt;=N;j+=i){
            prime[j]=false;
        }
    }
    for(long long i=0;i&amp;lt;prime.size();i++){
        if(prime[i]){
            R.push_back(i);
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-6&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-6&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;long long&amp;gt; primearray(long long N){/*省略*/}

int main(void){
    
    std::vector&amp;lt;long long&amp;gt; P = primearray(100);
    for(int i=0;i&amp;lt;P.size();i++){
        std::cout &amp;lt;&amp;lt; P[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-6&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;素因数分解&quot;&gt;素因数分解&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(N\)に対し、\(N\)を素因数分解し、小さい順にvectorとして返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\sqrt{N})\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; prime_factorization(long long N){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; R;
    if(N&amp;lt;2)return R;
    for(long long i=2;i*i&amp;lt;=N;i++){
        while(N%i==0){
            R.push_back(i);
            N/=i;
        }
    }
    if(N!=1){
          R.push_back(N);
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-7&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-7&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;long long&amp;gt; prime_factorization(long long N){/*省略*/}

int main(void){
    
    std::vector&amp;lt;long long&amp;gt; number={4,12,57,97,210};
    for(int j=0;j&amp;lt;5;j++){
        std::cout &amp;lt;&amp;lt; number[j] &amp;lt;&amp;lt; &quot;  &quot;;
        std::vector&amp;lt;long long&amp;gt; F = prime_factorization(number[j]);
        for(int i=0;i&amp;lt;F.size();i++){
            std::cout &amp;lt;&amp;lt; F[i] &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-7&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4  2 2 
12  2 2 3 
57  3 19 
97  97 
210  2 3 5 7 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;累乗繰り返し二乗法&quot;&gt;累乗(繰り返し二乗法)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(b,e\)に対し、\(b^e\)を返す&lt;/li&gt;
  &lt;li&gt;\(MOD\)も与えるとそれで割った余りをとる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(e))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long power(long long b,long long e,long long MOD=LLONG_MAX){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    long long r=1;
    while(e){
        if(e&amp;amp;1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e &amp;gt;&amp;gt;=1;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-8&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-8&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long power(long long b,long long e,long long MOD=LLONG_MAX){/*省略*/}

int main(void){
    
    std::cout &amp;lt;&amp;lt; &quot;2のi乗&quot;&amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; power(2,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;2のi乗を100で割ったあまり&quot;&amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; power(2,i,100) &amp;lt;&amp;lt; &quot; &quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-8&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2のi乗
1 2 4 8 16 32 64 128 256 512 1024 
2のi乗を100で割ったあまり
1 2 4 8 16 32 64 28 56 12 24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;逆元素数mod&quot;&gt;逆元(素数MOD)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;与えられた\(b,MOD\)に対し、\(MOD\)を法とした整数環上での逆元(\(bx=1\)を満たす\(x\))を返す&lt;/li&gt;
  &lt;li&gt;MODが素数でない場合の動作は未確認&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(MOD))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long inverse(long long b,long long MOD){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    long long r=1,e=MOD-2;
    while(e){
        if(e&amp;amp;1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e &amp;gt;&amp;gt;=1;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例-9&quot;&gt;使用例&lt;/h3&gt;

&lt;h4 id=&quot;実行コード-9&quot;&gt;実行コード&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long inverse(long long b,long long MOD){/*省略*/}

int main(void){
    
    std::cout &amp;lt;&amp;lt; &quot;mod 7でのiの逆元&quot;&amp;lt;&amp;lt; std::endl;
    for(int i=1;i&amp;lt;7;i++){
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; inverse(i,7) &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; (i*inverse(i,7))%7 &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;出力-9&quot;&gt;出力&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mod 7でのiの逆元
1 1 1
2 4 1
3 5 1
4 2 1
5 3 1
6 6 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#もくじ&quot;&gt;もくじに戻る&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/05&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;約数列挙を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/27&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;軽微なバグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;アンカーリンクを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/06/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;素因数分解のバグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/03&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数学詰め合わせパックを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">優柔不断なあなたに</summary></entry><entry><title type="html">ローリングハッシュ</title><link href="http://localhost:4000/library/posts/rollinghash" rel="alternate" type="text/html" title="ローリングハッシュ" /><published>2021-04-01T00:00:00+09:00</published><updated>2021-04-01T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/rollinghash</id><content type="html" xml:base="http://localhost:4000/library/posts/rollinghash">&lt;p&gt;MOD \(2^{61}-1\)と\(2\)基底を採用しています　&lt;a href=&quot;https://trap.jp/post/900/&quot;&gt;例の記事&lt;/a&gt;はいったい･･･&lt;br /&gt;
基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文字列\(S\)を与えると、前計算として\(S\)をハッシュする他、getの計算で使用する数値を計算する&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b\vert S \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rollinghash&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;get&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;半開区間\([l,r)\)を与えると、\(S\)の\([l,r)\)文字目のハッシュ値を返す&lt;/li&gt;
  &lt;li&gt;計算量は基底の数を\(b\)として、\(Ο(b)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/rollinghash.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class rollinghash{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const long long mod = (1LL &amp;lt;&amp;lt; 61)-1;
    std::vector&amp;lt;long long&amp;gt; Base = {12345,10000000};
    std::vector&amp;lt;long long&amp;gt; BaseInv;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; BaseInvExp;
    const long long h = 100;
    
    long long product(long long a,long long b){
        const long long m = 1LL &amp;lt;&amp;lt; 31;
        long long a1 = a/m,a2 = a%m;
        long long b1 = b/m,b2 = b%m;
        
        long long r = 0 , s;
        r = (r + 2*a1*b1) % mod;
        s = (a1*b2 + b1*a2) % mod;
        long long s1 = s/m,s2 = s%m;
        s = (2*s1+m*s2) % mod;
        r = (r + s) % mod;
        r = (r + a2*b2) % mod;
        
        return r;
    }
    
    long long power(long long b,long long e){
        long long r=1;
        while(e){
            if(e&amp;amp;1){
                r=product(r,b)%mod;
            }
                b=product(b,b)%mod;
                e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    public:
    std::string S;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt;&amp;gt; H,Hsum;
    
    void init(std::string cs){
        S=cs;
        int n=S.size();
        
        BaseInv.resize(Base.size());
        BaseInvExp.resize(Base.size());
        H.resize(Base.size());
        Hsum.resize(Base.size());
        for(int i=0;i&amp;lt;Base.size();i++){
            BaseInvExp[i].assign(n+1,1);
            H[i].assign(n+1,0);
            Hsum[i].assign(n+1,0);
        }
        
        //逆元
        for(int i=0;i&amp;lt;Base.size();i++){
            BaseInv[i]=power(Base[i],mod-2);
        }
        for(int i=0;i&amp;lt;Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                BaseInvExp[i][j+1] = product(BaseInvExp[i][j],BaseInv[i]);
            }
        }
        
        //本体
        for(int i=0;i&amp;lt;Base.size();i++){
            long long b=1;
            for(int j=0;j&amp;lt;n;j++){
                H[i][j]=product(b,S[j]+h);
                b=product(b,Base[i]);
            }
        }
        
        //累積和
        for(int i=0;i&amp;lt;Base.size();i++){
            for(int j=0;j&amp;lt;n;j++){
                Hsum[i][j+1]=(Hsum[i][j]+H[i][j])%mod;
            }
        }
    }
    
    rollinghash(std::string S){
        init(S);
    }
    
    std::vector&amp;lt;long long&amp;gt; get(int l,int r){
        std::vector&amp;lt;long long&amp;gt; R;
        for(int i=0;i&amp;lt;Base.size();i++){
            long long g = (Hsum[i][r]-Hsum[i][l]+mod)%mod;
            g=product(g,BaseInvExp[i][l]);
            R.push_back(g);
        }
        return R;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class rollinghash{/*省略*/};

signed main() {
    
    rollinghash rolihash(&quot;abcab&quot;);
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[0,2)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; a = rolihash.get(0,2);
    for(int i=0;i&amp;lt;a.size();i++){
        std::cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[1,4)文字目、つまり\&quot;bca\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; b = rolihash.get(1,4);
    for(int i=0;i&amp;lt;b.size();i++){
        std::cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;\&quot;abcab\&quot;の[3,5)文字目、つまり\&quot;ab\&quot;のハッシュ値&quot; &amp;lt;&amp;lt; std::endl;
    std::vector&amp;lt;long long&amp;gt; c = rolihash.get(3,5);
    for(int i=0;i&amp;lt;c.size();i++){
        std::cout &amp;lt;&amp;lt; c[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;abcab&quot;の[0,2)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 

&quot;abcab&quot;の[1,4)文字目、つまり&quot;bca&quot;のハッシュ値
30025064778 19700001990000198 

&quot;abcab&quot;の[3,5)文字目、つまり&quot;ab&quot;のハッシュ値
2444507 1980000197 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/04/01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ローリングハッシュを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">MOD \(2^{61}-1\)と\(2\)基底を採用しています　例の記事はいったい･･･ 基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？</summary></entry><entry><title type="html">二部グラフ判定</title><link href="http://localhost:4000/library/posts/bipartite" rel="alternate" type="text/html" title="二部グラフ判定" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/bipartite%20graph</id><content type="html" xml:base="http://localhost:4000/library/posts/bipartite">&lt;p&gt;無向グラフを、辺の始点と終点を表現したpair&amp;lt;int,int&amp;gt;のvectorとして与える。&lt;br /&gt;
すると、sizeが\(max(点の番号)+1\)のvectorが返ってくる。すべての要素は\(0\)または\(1\)である。&lt;br /&gt;
これは、与えられたグラフを二部グラフとして表現するとき\(i\)番目の要素は\(0\)と\(1\)どちらに属するかを表している。&lt;br /&gt;
また二部グラフでないとき全ての要素は\(0\)である。&lt;br /&gt;
計算量は\(Ο(V+E)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/bipartite%20graph.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; bipartite(std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; edge){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    int E = edge.size();
    if(E==0)return {};
    int V = 0;
    for(int i=0;i&amp;lt;E;i++){
        V=std::max(V,edge[i].first+1);
        V=std::max(V,edge[i].second+1);
    }
    std::vector&amp;lt;int&amp;gt; R(V,-1);
    std::vector&amp;lt;int&amp;gt; S(V,0);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; es(V,std::vector&amp;lt;int&amp;gt;(0));
    for(int i=0;i&amp;lt;E;i++){
        es[edge[i].first].push_back(edge[i].second);
        es[edge[i].second].push_back(edge[i].first);
    }
    std::queue&amp;lt;int&amp;gt; Q;
    std::vector&amp;lt;bool&amp;gt; visited(V,false);
    for(int j=0;j&amp;lt;V;j++){
        if(visited[j])continue;
        Q.push(j);
        R[j]=0;
        visited[j]=true;
        while(!Q.empty()){
            int q=Q.front();
            Q.pop();
            visited[q]=true;
            for(int i=0;i&amp;lt;es[q].size();i++){
                if(R[es[q][i]]==R[q]){
                    return S;
                }
                if(visited[es[q][i]])continue;
                Q.push(es[q][i]);
                R[es[q][i]]=1-R[q];
            }
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;int&amp;gt; bipartite(std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; edge){/*省略*/}

int main(void){
    
    std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; E,F;
    
    E.push_back({0,1});
    E.push_back({1,2});
    E.push_back({2,3});
    E.push_back({3,0});
    E.push_back({0,4});
    
    F.push_back({0,1});
    F.push_back({1,2});
    F.push_back({2,3});
    F.push_back({2,4});
    F.push_back({3,4});
    
    std::vector&amp;lt;int&amp;gt; Es = bipartite(E), Fs = bipartite(F);
    
    for(int i=0;i&amp;lt;Es.size();i++){
        std::cout &amp;lt;&amp;lt; Es[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    for(int i=0;i&amp;lt;Fs.size();i++){
        std::cout &amp;lt;&amp;lt; Fs[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 0 1 1 
0 0 0 0 0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正/計算量表記を修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/02&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二部グラフ判定を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">無向グラフを、辺の始点と終点を表現したpair&amp;lt;int,int&amp;gt;のvectorとして与える。 すると、sizeが\(max(点の番号)+1\)のvectorが返ってくる。すべての要素は\(0\)または\(1\)である。 これは、与えられたグラフを二部グラフとして表現するとき\(i\)番目の要素は\(0\)と\(1\)どちらに属するかを表している。 また二部グラフでないとき全ての要素は\(0\)である。 計算量は\(Ο(V+E)\)</summary></entry><entry><title type="html">座標圧縮</title><link href="http://localhost:4000/library/posts/compress" rel="alternate" type="text/html" title="座標圧縮" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/compress</id><content type="html" xml:base="http://localhost:4000/library/posts/compress">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数列\(A\)を与えると、クラスを\(A\)で初期化する&lt;/li&gt;
  &lt;li&gt;このとき、\(A\)の全ての\(2\)つの要素について大小関係が維持され、かつindexの最大値が最小になるように\(A\)の各要素にindexという非負整数が割り振られる&lt;/li&gt;
  &lt;li&gt;計算量は\(N=\vert A \vert\)とし、\(Ο(NlogN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;compress&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;size&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initで与えられた数列の中に含まれる値の種類数を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;index&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;値を与えると、その値に対応するindexを返す&lt;/li&gt;
  &lt;li&gt;もし数列に存在しない値が与えられたら、数列に存在する値の中で、与えられた値より小さい最大の値についてのindexを返す(つまり、小さい値に寄せる)&lt;/li&gt;
  &lt;li&gt;もし列のいかなる値よりも小さければ\(-1\)を返す&lt;/li&gt;
  &lt;li&gt;計算量はinitの\(N\)を用いて、\(Ο(logN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;value&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;indexを与えると値を返す&lt;/li&gt;
  &lt;li&gt;範囲外なら\(0\)を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(1)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/coordinate%20compression.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class compress{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; E;
    
    public:
    void init(std::vector&amp;lt;long long&amp;gt; A){
        E.clear();
        sort(A.begin(),A.end());
        for(int i=0;i&amp;lt;A.size();i++){
            if(i==0 || A[i]!=A[i-1]){
                E.push_back(A[i]);
            }
        }
    }
    
    compress(std::vector&amp;lt;long long&amp;gt; A){
        init(A);
    }
    
    int size(){
        return (int)E.size();
    }
    
    int value(int x){
        if(0&amp;lt;=x &amp;amp;&amp;amp; x&amp;lt;(int)E.size()){
            return E[x];
        }else{
            return 0;
        }
    }
    
    int index(int X){
        return (upper_bound(E.begin(),E.end(),X))-E.begin()-1;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class compress{/*省略*/};

int main(void){
    
    std::vector&amp;lt;long long&amp;gt; A={1,2,4,8,16,32,64,128};
    compress zaatsu(A);
    
    std::cout &amp;lt;&amp;lt; &quot;uniqueな要素の個数&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; zaatsu.size() &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;Aの各要素に対応する数&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;A.size();i++){
        std::cout &amp;lt;&amp;lt; zaatsu.index(A[i]) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;0~7に対応する要素&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;zaatsu.size();i++){
        std::cout &amp;lt;&amp;lt; zaatsu.value(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uniqueな要素の個数
8

Aの各要素に対応する数
0 1 2 3 4 5 6 7 

0~7に対応する要素
1 2 4 8 16 32 64 128 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/05/20&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mapで処理しvectorで返す形式から、class化し二分探索を行う形式に変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/05&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;座標圧縮を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 数列\(A\)を与えると、クラスを\(A\)で初期化する このとき、\(A\)の全ての\(2\)つの要素について大小関係が維持され、かつindexの最大値が最小になるように\(A\)の各要素にindexという非負整数が割り振られる 計算量は\(N=\vert A \vert\)とし、\(Ο(NlogN)\)</summary></entry><entry><title type="html">UnionFind</title><link href="http://localhost:4000/library/posts/unionfind" rel="alternate" type="text/html" title="UnionFind" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/unionfind</id><content type="html" xml:base="http://localhost:4000/library/posts/unionfind">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、頂点を\(N\)個生成し全てを独立にした上で全てのランクを\(0\)にする&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unionfind&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;root&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(k\)のその時点での根を求める&lt;/li&gt;
  &lt;li&gt;と同時に経路圧縮する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\(α(x)\)はアッカーマン関数\(Ack(x,x)\)の逆関数&lt;/p&gt;

&lt;p&gt;\(Ack(4,4)=2^{2^{2^{65536}}}-3\)から伺えるように、\(\alpha (x)\)は実用上定数(\(4\))倍と見なせるほどに収束が遅い&lt;/p&gt;

&lt;p&gt;same&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点pと頂点qがその時点で同じ集合に属しているか(=根が同一か)を調べ、同じならtrue、違うならfalseを返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unite&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点pと頂点qが属してる集合を合併する&lt;/li&gt;
  &lt;li&gt;すでに同じ集合に属している場合は無視する&lt;/li&gt;
  &lt;li&gt;pの属する集合のランクがqのものと同じか大きいときp側が根に、そうでないときq側が根になる&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/union%20find.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class unionfind{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; UF,rank;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i&amp;lt;N;i++){
            UF.push_back(i);
            rank.push_back(0);
        }
    }
    
    unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]&amp;lt;rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class unionfind{/*省略*/};

int main(void){
    
    unionfind UF(12);
    UF.unite(1,3);
    UF.unite(1,5);
    UF.unite(1,7);
    UF.unite(1,8);
    UF.unite(1,10);
    UF.unite(1,12);
    UF.unite(4,6);
    UF.unite(4,9);
    UF.unite(4,11);
    
    for(int i=1;i&amp;lt;=12;i++){
        std::cout &amp;lt;&amp;lt; UF.root(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    for(int i=1;i&amp;lt;=12;i++){
        std::cout &amp;lt;&amp;lt; UF.same(1,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 1 4 1 4 1 1 4 1 4 1 
1 0 1 0 1 0 1 1 0 1 0 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UnionFindを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 整数\(N\)を与えると、頂点を\(N\)個生成し全てを独立にした上で全てのランクを\(0\)にする 計算量は\(Ο(N)\)</summary></entry><entry><title type="html">スライド最小値</title><link href="http://localhost:4000/library/posts/slideminimum" rel="alternate" type="text/html" title="スライド最小値" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/slide-minimum</id><content type="html" xml:base="http://localhost:4000/library/posts/slideminimum">&lt;p&gt;数列\(A\)と整数\(K\)を与えると、以下の数式を満たす要素数が\(\vert A \vert -K+1\)の数列\(R\)を構成し、返す&lt;/p&gt;

\[R_i = min(A_i , A_{i+1} , ... , A_{i+K-1})\]

&lt;p&gt;計算量は\(O(\vert A \vert)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/slide%20minimum.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; slide_minimum(std::vector&amp;lt;long long&amp;gt; A,int K){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; R;
    int N = A.size();
    std::deque&amp;lt;int&amp;gt; D;
    for(int i=0;i&amp;lt;N;i++){
        while(!D.empty() &amp;amp;&amp;amp; A[D.back()]&amp;gt;=A[i]){D.pop_back();}
        D.push_back(i);
        if(i-K+1&amp;gt;=0){
            R.push_back(A[D.front()]);
            if(D.front()==i-K+1){
                D.pop_front();
            }
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;long long&amp;gt; slide_minimum(std::vector&amp;lt;long long&amp;gt; A,int K){/*省略*/}

int main(void){
    
    std::vector&amp;lt;long long&amp;gt; A = {3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3},B;
    long long K = 3;
    
    B = slide_minimum(A,K);
    for(int i=0;i&amp;lt;B.size();i++){
        std::cout &amp;lt;&amp;lt; B[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 1 1 1 2 2 2 3 3 3 5 7 7 3 2 2 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/23&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;スライド最小値を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">数列\(A\)と整数\(K\)を与えると、以下の数式を満たす要素数が\(\vert A \vert -K+1\)の数列\(R\)を構成し、返す</summary></entry><entry><title type="html">セグメント木</title><link href="http://localhost:4000/library/posts/segmenttree" rel="alternate" type="text/html" title="セグメント木" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/segment-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/segmenttree">&lt;p&gt;単にセグ木と言えばこれを指す、最も単純なセグ木&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、要素が\(N\)個入る最小サイズの完全二分木を構成し、すべての要素を単位元で初期化する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;segmenttree&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;calc&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;セグ木に乗せる演算を書く&lt;/li&gt;
  &lt;li&gt;場合によって使いたい演算を書き換える&lt;/li&gt;
  &lt;li&gt;演算はモノイドである必要がある&lt;/li&gt;
  &lt;li&gt;long long×long long→long longにしか対応してない　は？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;update&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(k\)番目(0-indexed)の要素を\(a\)で更新し、それが影響するノードを全て更新する&lt;/li&gt;
  &lt;li&gt;計算量はinitの\(N\)を用いて、\(Ο(logN)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;query&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\([a,b)\)の範囲内にある要素をcalcで計算した結果をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(b-a))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class segmenttree{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int n;
    long long identity = 0;//単位元
    std::vector&amp;lt;long long&amp;gt; dat;
    public:
    
    void init(int N){
        n=1;
        while(n&amp;lt;N)n*=2;
        dat.clear();
        for(int i=0;i&amp;lt;2*n-1;++i){
            dat.push_back(identity);
        }
    }
    
    segmenttree(int N){
        init(N);
    }

    long long calc();
    
    void update(int k,long long a){
        k+=n-1;
        dat[k]=a;
        while(k&amp;gt;0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    long long query(long long a,long long b){
        a+=n;
        b+=n;
        long long R=0;
        while(a &amp;lt; b){
            if(a % 2 == 1){
                R = calc(R, dat[a - 1]);
                a += 1;
            }
            a /= 2;
            if(b % 2 == 1){
                b -= 1;
                R = calc(R, dat[b - 1]);
            }
            b /= 2;
        }
        return R;
    }
    
    long long calc(long long a,long long b){
        //your monoid here
        return a+b;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class segmenttree{
    /*calcを除き省略*/

    long long calc(long long a,long long b){
        //your monoid here
        return a+b;
    }
    
};

int main(void){
    
    long long N = 6;
    std::vector&amp;lt;long long&amp;gt; A = {100000,20000,3000,400,50,6};
    
    segmenttree segtree(N);
    for(int i=0;i&amp;lt;N;i++){
        segtree.update(i,A[i]);
    }
    
    std::cout &amp;lt;&amp;lt; segtree.query(0,3) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(0,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(2,6) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(3,5) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; segtree.query(5,6) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123000
123456
3456
450
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;セグメント木を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">単にセグ木と言えばこれを指す、最も単純なセグ木</summary></entry><entry><title type="html">ポテンシャル付きUnionFind</title><link href="http://localhost:4000/library/posts/pot-unionfind" rel="alternate" type="text/html" title="ポテンシャル付きUnionFind" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/pot-unionfind</id><content type="html" xml:base="http://localhost:4000/library/posts/pot-unionfind">&lt;p&gt;重み付きUnionFindって言ったほうがいいのかな？正直わからない&lt;/p&gt;

&lt;p&gt;大体の機能は&lt;a href=&quot;./unionfind&quot;&gt;UnionFind&lt;/a&gt;と同じで違う点は&lt;/p&gt;

&lt;p&gt;potential&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点\(k\)のその時点でのポテンシャルを求める&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unite&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;集合を合併する際に、\((Qのポテンシャル)-(Pのポテンシャル)=d\)になるように指定する&lt;/li&gt;
  &lt;li&gt;P,Qが同じ集合にある場合にfalseを返す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;diff&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\((Qのポテンシャル)-(Pのポテンシャル)\)を返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\alpha (N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/potentialized%20unionfind.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class potentialized_unionfind{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; UF,rank,pot;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i&amp;lt;N;i++){
            UF.push_back(i);
            rank.push_back(0);
            pot.push_back(0);
        }
    }

    potentialized_unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            int r = root(UF[k]);
            pot[k] += pot[UF[k]];
            UF[k] = r;
            return UF[k];
        }
    }
    
    int potential(int k){
        root(k);
        return pot[k];
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    bool unite(int P,int Q,int d){
        //pot(Q)-pot(P)=dを満たす
        d+=potential(P);
        d-=potential(Q);
        int p=root(P), q=root(Q);
        if(p==q)return false;
        if(rank[p]&amp;lt;rank[q]){
            std::swap(p,q);
            d = -d;
        }
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        pot[q]=d;
        
        return true;
    }
    
    int diff(int P,int Q){
        return potential(Q)-potential(P);
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class potentialized_unionfind{/*省略*/};

int main(void){
    
    potentialized_unionfind potUF(5);
    
    potUF.unite(0,1,1);
    potUF.unite(1,2,2);
    potUF.unite(2,3,4);
    potUF.unite(2,4,8);
    
    std::cout &amp;lt;&amp;lt; &quot;頂点3と頂点4の結合はできているか&quot; &amp;lt;&amp;lt; std::endl;
    bool c = potUF.unite(3,4,4);
    if(c==true){
        std::cout &amp;lt;&amp;lt; &quot;true&quot; &amp;lt;&amp;lt; std::endl;
    }else{
        std::cout &amp;lt;&amp;lt; &quot;false&quot; &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;頂点0とのポテンシャルの差は何か&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;5;i++){
        std::cout &amp;lt;&amp;lt; potUF.diff(0,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
    
    std::cout &amp;lt;&amp;lt; &quot;頂点2とのポテンシャルの差は何か&quot; &amp;lt;&amp;lt; std::endl;
    for(int i=0;i&amp;lt;5;i++){
        std::cout &amp;lt;&amp;lt; potUF.diff(2,i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;頂点3と頂点4の結合はできているか
false

頂点0とのポテンシャルの差は何か
0 1 3 7 11 

頂点2とのポテンシャルの差は何か
-3 -2 0 4 8 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ポテンシャル付きUnionFindを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">重み付きUnionFindって言ったほうがいいのかな？正直わからない</summary></entry><entry><title type="html">最長増加部分列</title><link href="http://localhost:4000/library/posts/lis" rel="alternate" type="text/html" title="最長増加部分列" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/lis</id><content type="html" xml:base="http://localhost:4000/library/posts/lis">&lt;p&gt;数列\(A\)を与えると、\(A\)の最長増加部分列の長さを求め、long longで返す&lt;/p&gt;

&lt;p&gt;計算量は\(Ο(\vert A \vert log \vert A \vert)\)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/longest%20increasing%20subsequence.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long LIS(std::vector&amp;lt;long long&amp;gt; A){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    int N=A.size();
    std::vector&amp;lt;long long&amp;gt; D;
    for(int i=0;i&amp;lt;N;i++){
        int pos=distance(D.begin(),lower_bound(D.begin(), D.end(),A[i]));
        if(pos==D.size()){
            D.push_back(A[i]);
        }else{
            D[pos]=A[i];
        }
    }
    return D.size();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

long long LIS(std::vector&amp;lt;long long&amp;gt; A){/*省略*/}

int main(void){
    
    std::vector&amp;lt;long long&amp;gt; A={1,4,2,5,3},B={5,3,1,4,2};
    std::cout &amp;lt;&amp;lt; LIS(A) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; LIS(B) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/05&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最長増加部分列を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">数列\(A\)を与えると、\(A\)の最長増加部分列の長さを求め、long longで返す</summary></entry><entry><title type="html">フェニック木</title><link href="http://localhost:4000/library/posts/fenwicktree" rel="alternate" type="text/html" title="フェニック木" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/fenwick-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/fenwicktree">&lt;p&gt;BIT(Binary Indexed Tree)とも&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数\(N\)を与えると、要素が\(N\)個のフェニック木を構成し、すべての要素を\(0\)で初期化する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(N)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fenwick_tree&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;add&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(a\)番目(0-indexed)の要素に\(w\)を加算する&lt;/li&gt;
  &lt;li&gt;計算量はinitの\(N\)を用いて、\(Ο(log(N))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sum&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\([0,a)\)の範囲内にある要素の和をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(log(a))\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;inversion&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数列\(V\)を与えると\(V\)の転倒数を計算し、long longで返す&lt;/li&gt;
  &lt;li&gt;この際、initし直すため今までの内容をすべて削除する&lt;/li&gt;
  &lt;li&gt;計算量は\(Ο(\vert V \vert log \vert V \vert)\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/Fenwick%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Fenwick_tree{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;long long&amp;gt; BIT;
    
    public:
    
    void add(int a,long long w){
        for(int x=a;x&amp;lt;BIT.size();x|=(x+1)){
            BIT[x]+=w;
        }
    }
    
    void init(int n){
        BIT.clear();
        for(int i=0;i&amp;lt;n;i++){
            BIT.push_back(0);
        }
    }
    
    Fenwick_tree(int n){
        init(n);
    }
    
    long long sum(int a){
        long long r=0;
        for(int x=a-1;x&amp;gt;=0;x=(x&amp;amp;(x+1))-1){
            r+=BIT[x];
        }
        return r;
    }
    
    long long inversion(std::vector&amp;lt;long long&amp;gt; V){
        long long r=0;
        init(V.size());
        for(int i=0;i&amp;lt;V.size();i++){
            add(V[i],1);
            r+=i-sum(V[i]);
        }
        return r;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class Fenwick_tree{/*省略*/};

int main(void){
    
    long long N = 6;
    std::vector&amp;lt;long long&amp;gt; A = {100000,20000,3000,400,50,6};
    
    Fenwick_tree BIT(N);
    for(int i=0;i&amp;lt;N;i++){
        BIT.add(i,A[i]);
    }
    
    for(int i=0;i&amp;lt;=N;i++){
        std::cout &amp;lt;&amp;lt; BIT.sum(i) &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;long long&amp;gt; B = {3,1,4,2};
    std::cout &amp;lt;&amp;lt; BIT.inversion(B) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0
100000
120000
123000
123400
123450
123456

3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/26&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/06&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;フェニック木を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">BIT(Binary Indexed Tree)とも</summary></entry></feed>