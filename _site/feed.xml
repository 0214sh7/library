<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/library/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/library/" rel="alternate" type="text/html" /><updated>2021-03-26T00:26:19+09:00</updated><id>http://localhost:4000/library/feed.xml</id><title type="html">すくライブラリ</title><subtitle>descriptionはない</subtitle><entry><title type="html">数論変換</title><link href="http://localhost:4000/library/posts/ntt" rel="alternate" type="text/html" title="数論変換" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/ntt</id><content type="html" xml:base="http://localhost:4000/library/posts/ntt">&lt;p&gt;整数環FFTとも&lt;/p&gt;

&lt;p&gt;基本的には&lt;a href=&quot;./fft&quot;&gt;FFT&lt;/a&gt;と同じだが、あちらが実数を使って計算するのに対しこちらは有理数を素数で割った余りを使って計算する&lt;/p&gt;

&lt;p&gt;誤差がないというメリットがあるが、&lt;script type=&quot;math/tex&quot;&gt;MOD&lt;/script&gt;素数より大きい整数を扱えないというデメリットがある&lt;/p&gt;

&lt;p&gt;ここで用いる素数は、&lt;script type=&quot;math/tex&quot;&gt;P-1&lt;/script&gt;が素因数に&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;を多く含むような&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;であることが望ましい(例えばNTTでよく使われる&lt;script type=&quot;math/tex&quot;&gt;998244353&lt;/script&gt;は&lt;script type=&quot;math/tex&quot;&gt;119 \cdot 2^{23}+1&lt;/script&gt;である)&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;N=max(\vert A \vert,\vert B \vert)&lt;/script&gt;として、&lt;script type=&quot;math/tex&quot;&gt;Ο(NlogNlogMOD)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/number%20theoretic%20transform.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class number_theoretic_transform{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    
    const long long MOD = 998244353;
    const long long k = 119;
    const long long n = 23;
    const long long pri_root = 3;
    //MOD=k*2^n+1
    
    long long BE(long long b,long long e){
        long long r=1;
        while(e){
            if(e&amp;amp;1){
                r=(r*b)%MOD;
            }
            b=(b*b)%MOD;
            e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    std::vector&amp;lt;long long&amp;gt; DFT(std::vector&amp;lt;long long&amp;gt; A){
        int N=A.size();
        if(N==1)return A;
        std::vector&amp;lt;long long&amp;gt; A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i&amp;lt;N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        long long omega=BE(pri_root,k*(1&amp;lt;&amp;lt;n)/N);
        long long ith_zeta = 1;
        for(int i=0;i&amp;lt;N;i++){
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)])%MOD;
            ith_zeta = (ith_zeta*omega)%MOD;
        }
        return iA;
    }
     
    std::vector&amp;lt;long long&amp;gt; iDFT(std::vector&amp;lt;long long&amp;gt; iA){
        int N=iA.size();
        long long N_inverse = BE(N,MOD-2);
        std::vector&amp;lt;long long&amp;gt; A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i&amp;lt;N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back((rA[i]*N_inverse)%MOD);
        }
        return A;
    }
    
    
    public:
    
    std::vector&amp;lt;long long&amp;gt; convolution(std::vector&amp;lt;long long&amp;gt; A,std::vector&amp;lt;long long&amp;gt; B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N&amp;lt;deg){N&amp;lt;&amp;lt;=1;}
        A.resize(N);B.resize(N);
        for(int i=0;i&amp;lt;A.size();i++){
            A[i]%=MOD;
        }
        for(int i=0;i&amp;lt;B.size();i++){
            B[i]%=MOD;
        }
        std::vector&amp;lt;long long&amp;gt; C(N),iC(N),iA,iB;
        iA=DFT(A);iB=DFT(B);
        for(int i=0;i&amp;lt;N;i++){
            iC[i]=(iA[i]*iB[i])%MOD;
        }
        C=iDFT(iC);
        C.resize(deg);
        return C;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class number_theoretic_transform{/*省略*/};

int main(void){
    
    number_theoretic_transform NTT;
    std::vector&amp;lt;long long&amp;gt; A={1,2,3},B={1,3,5},C;
    
    C = NTT.convolution(A,B);
    for(int i=0;i&amp;lt;C.size();i++){
        std::cout &amp;lt;&amp;lt; C[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 5 14 19 15 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加/vectorをstd::vectorに変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数論変換を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">整数環FFTとも</summary></entry><entry><title type="html">高速フーリエ変換</title><link href="http://localhost:4000/library/posts/fft" rel="alternate" type="text/html" title="高速フーリエ変換" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/fft</id><content type="html" xml:base="http://localhost:4000/library/posts/fft">&lt;p&gt;クラスで実装されているが、実行するときはconvolutionを呼び出せばいい&lt;/p&gt;

&lt;p&gt;多項式に見立てたvectorを&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;つ与えると、それらに対し高速フーリエ変換を用いた畳み込み演算を行い一つの多項式にし、vectorとして返す&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\{1,2,3\}*\{1,3,5\}=\{1,5,14,19,15\}&lt;/script&gt;といった調子&lt;/p&gt;

&lt;p&gt;実装上doubleを経由しているので誤差死が怖い&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;N=max(\vert A \vert,\vert B\vert)&lt;/script&gt;として、&lt;script type=&quot;math/tex&quot;&gt;Ο(NlogN)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/fast%20Fourier%20transform.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class fast_Fourier_transform{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const double PI=3.14159265358979; 
    
    std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; DFT(std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; A){
        int N=A.size();
        if(N==1)return A;
        std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i&amp;lt;N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        for(int i=0;i&amp;lt;N;i++){
            std::complex&amp;lt;double&amp;gt; ith_zeta = std::complex&amp;lt;double&amp;gt;(cos(2*PI*i/N),sin(2*PI*i/N));
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)]);
        }
        return iA;
    }
    
    std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; iDFT(std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; iA){
        int N=iA.size();
        std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i&amp;lt;N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back(rA[i]/std::complex&amp;lt;double&amp;gt;(N,0));
        }
        return A;
    }
    
    public:
    std::vector&amp;lt;long long&amp;gt; convolution(std::vector&amp;lt;long long&amp;gt; A,std::vector&amp;lt;long long&amp;gt; B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N&amp;lt;deg){N&amp;lt;&amp;lt;=1;}
        A.resize(N);B.resize(N);
        std::vector&amp;lt;std::complex&amp;lt;double&amp;gt;&amp;gt; dC(N),iC(N),dA,iA,dB,iB;
        std::vector&amp;lt;long long&amp;gt; C(N);
        for(int i=0;i&amp;lt;A.size();i++){
            dA.push_back(A[i]);
        }
        for(int i=0;i&amp;lt;B.size();i++){
            dB.push_back(B[i]);
        }
        iA=DFT(dA);iB=DFT(dB);
        for(int i=0;i&amp;lt;N;i++){
            iC[i]=iA[i]*iB[i];
        }
        dC=iDFT(iC);
        for(int i=0;i&amp;lt;dC.size();i++){
            C[i]=(0.1+dC[i].real());
        }
        C.resize(deg);
        return C;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class fast_Fourier_transform{/*省略*/};

int main(void){
    
    fast_Fourier_transform FFT;
    std::vector&amp;lt;long long&amp;gt; A={1,2,3},B={1,3,5},C;
    
    C = FFT.convolution(A,B);
    for(int i=0;i&amp;lt;C.size();i++){
        std::cout &amp;lt;&amp;lt; C[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 5 14 19 15 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;高速フーリエ変換を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">クラスで実装されているが、実行するときはconvolutionを呼び出せばいい</summary></entry><entry><title type="html">オイラーのφ関数</title><link href="http://localhost:4000/library/posts/totient" rel="alternate" type="text/html" title="オイラーのφ関数" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/euler-totient</id><content type="html" xml:base="http://localhost:4000/library/posts/totient">&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt;はトーシェントと読むらしい&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\varphi(n)&lt;/script&gt;とは、&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;から&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;までの整数で、&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;と互いに素であるものの個数&lt;/p&gt;

&lt;p&gt;これは、&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;が相違な素因数&lt;script type=&quot;math/tex&quot;&gt;p_1,p_2,...,p_d&lt;/script&gt;を含むとして&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi(n) = n\prod_{k=1}^d (1-\frac{1}{p_k})&lt;/script&gt;

&lt;p&gt;と計算することができる&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/Euler's%20totient%20function.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;単体&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;\varphi(N)&lt;/script&gt;を計算し整数で返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\sqrt{N})&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int totient(int N){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    if(N&amp;lt;0){
        return 0;
    }
    int R = N;
    for(int i=2;i*i&amp;lt;=N;i++){
        if(N%i==0){
            R -= R/i;
            while(N%i==0){
                N/=i;
            }
        }
    }
    if(N&amp;gt;1){
        R -= R/N;
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;列挙&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;から&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;までの&lt;script type=&quot;math/tex&quot;&gt;\varphi(i)&lt;/script&gt;を計算し,要素数が&lt;script type=&quot;math/tex&quot;&gt;N+1&lt;/script&gt;のvectorで返す&lt;/li&gt;
  &lt;li&gt;ここで、&lt;script type=&quot;math/tex&quot;&gt;\varphi(0)=0&lt;/script&gt;としている&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(NloglogN)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; totient_array(int N){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;int&amp;gt; R(N+1);
    for(int i=0;i&amp;lt;=N;i++){
        R[i]=i;
    }
    for(int i=2;i&amp;lt;=N;i++){
        if(R[i]!=i)continue;
        for(int j=i;j&amp;lt;=N;j+=i){
            R[j]-=(R[j]/i);
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

int totient(int N){/*省略*/}
std::vector&amp;lt;int&amp;gt; totient_array(int N){/*省略*/}

int main(void){
    
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; totient(i) &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;int&amp;gt; T = totient_array(10);
    for(int i=0;i&amp;lt;=10;i++){
        std::cout &amp;lt;&amp;lt; T[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 1 2 2 4 2 6 4 6 4 
0 1 1 2 2 4 2 6 4 6 4 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/16&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;オイラーのφ関数を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">はトーシェントと読むらしい</summary></entry><entry><title type="html">draft</title><link href="http://localhost:4000/library/posts/draft" rel="alternate" type="text/html" title="draft" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/draft</id><content type="html" xml:base="http://localhost:4000/library/posts/draft">&lt;p&gt;よく見つけましたね　これは下書きです&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;あ&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(N)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;draft&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;&lt;summary&gt;あえ～&lt;/summary&gt;&lt;div&gt;

---

おえ～
計算量は$$Ο(1)$$です

---

&lt;/div&gt;&lt;/details&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class draft{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class draft{/*省略*/};

int main(void){
    
    std::cout &amp;lt;&amp;lt; &quot;draft&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;draft
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/02/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;draftを追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">よく見つけましたね　これは下書きです</summary></entry><entry><title type="html">ダイクストラ法</title><link href="http://localhost:4000/library/posts/dijkstra" rel="alternate" type="text/html" title="ダイクストラ法" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/dijkstra</id><content type="html" xml:base="http://localhost:4000/library/posts/dijkstra">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;無向グラフを、頂点数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;と、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。&lt;/li&gt;
  &lt;li&gt;すると、グラフをsolve()が扱えるようになる&lt;/li&gt;
  &lt;li&gt;多始点などで何回も回す場合、initの実行は&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;回でよい&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\vert E \vert)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dijkstra&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initでできたグラフに対し、与えられた&lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;を始点としてダイクストラ法を実行する&lt;/li&gt;
  &lt;li&gt;得られた最小コストを要素数が&lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;のvectorとして返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο((E+V)logV)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/Dijkstra.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dijkstra{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    typedef std::pair&amp;lt;long long,int&amp;gt; P;
    std::vector&amp;lt;std::vector&amp;lt;P&amp;gt;&amp;gt; G;
    int V;
    long long INF = (1LL&amp;lt;&amp;lt;61);
    std::priority_queue&amp;lt;P,std::vector&amp;lt;P&amp;gt;,std::greater&amp;lt;P&amp;gt;&amp;gt; que;
    
    public:
    void init(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        //頂点数を決定する
        V=N;
        
        //辺集合を扱いやすい形式に変換する
        G.resize(V);
        for(int i=0;i&amp;lt;edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({cost,to});
        }
    }
    
    Dijkstra(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        init(N,edge);
    }

    std::vector&amp;lt;long long&amp;gt; solve(int s){
        std::vector&amp;lt;long long&amp;gt; d;
        //INFで初期化する
        for(int i=0;i&amp;lt;V;i++){
            d.push_back(INF);
        }
        d[s]=0;
        que.push({0,s});
        //queは{cost,to}をコストが小さい順に出す
        while(!que.empty()){
            P p = que.top();
            que.pop();
            int v=p.second;
            if(d[v]&amp;lt;p.first)continue;
            for(int i=0;i&amp;lt;G[v].size();i++){
                P e = G[v][i];
                if(d[e.second]&amp;gt;d[v]+e.first){
                    d[e.second] = d[v]+e.first;
                    que.push({d[e.second],e.second});
                }
            }
        }
        return d;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class Dijkstra{/*省略*/};

int main(void){
    
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Dijkstra dijkstra(N,E);
    std::vector&amp;lt;long long&amp;gt; D = dijkstra.solve(0);
    
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; D[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;long long&amp;gt; F = dijkstra.solve(1);
    
    for(int i=0;i&amp;lt;N;i++){
        std::cout &amp;lt;&amp;lt; F[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 3 7 11 
2305843009213693952 0 2 6 10 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加/コメントを削除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/02/12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正/いくつかの表記変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ダイクストラ法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 無向グラフを、頂点数と、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。 すると、グラフをsolve()が扱えるようになる 多始点などで何回も回す場合、initの実行は回でよい 計算量は</summary></entry><entry><title type="html">凸包</title><link href="http://localhost:4000/library/posts/convexhull" rel="alternate" type="text/html" title="凸包" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/convex-hull</id><content type="html" xml:base="http://localhost:4000/library/posts/convexhull">&lt;p&gt;アルゴリズムはAndrewのmonotone chainという名前らしい&lt;/p&gt;

&lt;p&gt;二次元上の点集合をvector&amp;lt;pair&amp;lt;long long,long long»で与える&lt;/p&gt;

&lt;p&gt;するとその点集合の凸包を求め、x座標が最も小さい点のうちy座標が最も小さい点から始めて反時計回りに並べてvector&amp;lt;pair&amp;lt;long long,long long»で返す&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\vert P \vert log \vert P \vert)&lt;/script&gt;(ソートがネックになっており、ソートがなければ&lt;script type=&quot;math/tex&quot;&gt;O(\vert P \vert)&lt;/script&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/convex%20hull.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; convex_hull(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; P){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    if(P.size()&amp;lt;=2){
        return P;
    }
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; H,L,R;
    sort(P.begin(),P.end());
    
    //下半分
    for(int i=0;i&amp;lt;P.size();i++){
        int j=L.size();
        while(j&amp;gt;=2 &amp;amp;&amp;amp; (L[j-1].first-L[j-2].first)*(P[i].second-L[j-2].second)&amp;lt;=(L[j-1].second-L[j-2].second)*(P[i].first-L[j-2].first)){
            L.pop_back();
            j--;
        }
        L.push_back(P[i]);
    }
    
    //上半分
    for(int i=P.size()-1;i&amp;gt;=0;i--){
        int j=H.size();
        while(j&amp;gt;=2 &amp;amp;&amp;amp; (H[j-1].first-H[j-2].first)*(P[i].second-H[j-2].second)&amp;lt;=(H[j-1].second-H[j-2].second)*(P[i].first-H[j-2].first)){
            H.pop_back();
            j--;
        }
        H.push_back(P[i]);
    }
    
    
    R=L;
    for(int i=1;i&amp;lt;H.size()-1;i++){
        R.push_back(H[i]);
    }
    
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; convex_hull(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; P){/*省略*/}

int main(void){
    
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; P,Q;
    P.push_back({0,0});
    P.push_back({2,0});
    P.push_back({1,1});
    P.push_back({0,2});
    P.push_back({2,2});
    
    Q = convex_hull(P);
    for(int i=0;i&amp;lt;Q.size();i++){
        std::cout &amp;lt;&amp;lt; Q[i].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; Q[i].second &amp;lt;&amp;lt; std::endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 0
2 0
2 2
0 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/22&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;凸包を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">アルゴリズムはAndrewのmonotone chainという名前らしい</summary></entry><entry><title type="html">二項係数</title><link href="http://localhost:4000/library/posts/binomial-coefficient" rel="alternate" type="text/html" title="二項係数" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/binomial%20coefficient</id><content type="html" xml:base="http://localhost:4000/library/posts/binomial-coefficient">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、combを実行するのに必要な数値(階乗とその逆元)を前計算する&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(N)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;binomial_coefficient&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;extension&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initで用意した範囲で足りない場合、整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると不足分を追加で前計算する&lt;/li&gt;
  &lt;li&gt;計算量は実行前のサイズを&lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;として、&lt;script type=&quot;math/tex&quot;&gt;Ο(N-s+log(MOD))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;comb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;n,r&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;\frac{n!}{r!(n-r)!}&lt;/script&gt;を&lt;script type=&quot;math/tex&quot;&gt;MOD&lt;/script&gt;で割った余りを返す&lt;/li&gt;
  &lt;li&gt;もしこれを計算するための前計算が不足している場合、ちょうど補完するようにextensionが実行される&lt;/li&gt;
  &lt;li&gt;このため、計算量を気にしなければinitは呼ばなくても良い&lt;/li&gt;
  &lt;li&gt;また最初にinitに十分な値を与えていればextensionは呼ばれない&lt;/li&gt;
  &lt;li&gt;計算量はextensionのもの+&lt;script type=&quot;math/tex&quot;&gt;Ο(1)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/binomial%20coefficient.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class binomial_coefficient{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    const long long MOD = 998244353;
    int sze = 0;
    std::vector&amp;lt;long long&amp;gt; fact;
    std::vector&amp;lt;long long&amp;gt; factinv;
    
    long long Gfinv(long long b){
        long long r=1;
        long long e=MOD-2;
        while(e){
            if(e&amp;amp;1){
                r=(r*b)%MOD;
            }
                b=(b*b)%MOD;
                e &amp;gt;&amp;gt;=1;
        }
        return r;
    }
    
    public:
    
    void init(int N){
        if(N&amp;lt;0){
            return ;
        }
        sze = N+1;
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[0]=1;
        for(long long i=1;i&amp;lt;=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i&amp;gt;=0;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
    }
    
    binomial_coefficient(int N){
        init(N);
    }
    
    void extension(int N){
        if(sze&amp;gt;N &amp;amp;&amp;amp; sze!=0){
            return ;
        }
        
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[sze]=(sze==0)?1:(fact[sze-1]*sze)%MOD;
        
        for(long long i=sze+1;i&amp;lt;=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i&amp;gt;=sze;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
        sze = N+1;
    }
    
    long long comb(long long n,long long r){
        if(n&amp;lt;0 || r&amp;lt;0 || n&amp;lt;r){
            return 0;
        }
        
        if(n&amp;gt;=sze){
            extension(n);
        }
        
        long long R = fact[n];
        R = (R*factinv[r])%MOD;
        R = (R*factinv[n-r])%MOD;
        return R;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class binomial_coefficient{/*省略*/};

int main(void){
    
    binomial_coefficient BC(10);
    for(int i=0;i&amp;lt;=5;i++){
        for(int j=0;j&amp;lt;=5;j++){
            std::cout &amp;lt;&amp;lt; BC.comb(i,j) &amp;lt;&amp;lt; &quot; &quot;;
        }std::cout &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 0 0 0 0 0 
1 1 0 0 0 0 
1 2 1 0 0 0 
1 3 3 1 0 0 
1 4 6 4 1 0 
1 5 10 10 5 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/02/18&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;nを指定してvectorを返す形式からclass化しn,rからnCrを返す形式に変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二項係数を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 整数を与えると、combを実行するのに必要な数値(階乗とその逆元)を前計算する 計算量は</summary></entry><entry><title type="html">ベルマンフォード法</title><link href="http://localhost:4000/library/posts/bellmanford" rel="alternate" type="text/html" title="ベルマンフォード法" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/bellmanford</id><content type="html" xml:base="http://localhost:4000/library/posts/bellmanford">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;無向グラフを、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。&lt;/li&gt;
  &lt;li&gt;すると、グラフをsolve()が扱えるようになる&lt;/li&gt;
  &lt;li&gt;多始点などで何回も回す場合、initの実行は&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;回でよい&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(max(E,V))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BellmanFord&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンストラクタ。initを呼ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;solve&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initでできたグラフに対し、与えられた&lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;を始点としてベルマンフォード法を実行する&lt;/li&gt;
  &lt;li&gt;得られた最小コストを要素数が&lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;のvectorとして返す&lt;/li&gt;
  &lt;li&gt;vectorの要素はpair&amp;lt;long long,bool&amp;gt;である　firstは最小コストを表しており、secondがtrueの場合最小コストが存在せずfirstの値は適当&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(VE)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/BellmanFord.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BellmanFord{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    typedef std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt; P;
    int V,E;
    long long INF = (1LL&amp;lt;&amp;lt;61);
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; es;
    
    public:
    void init(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        //辺数をもとめる　
        E=edge.size();
        //頂点数を決定する
        V=N;
        es=edge;
    }
    
    BellmanFord(int N,std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; edge){
        init(N,edge);
    }

    std::vector&amp;lt;std::pair&amp;lt;long long,bool&amp;gt;&amp;gt; solve(int s){
        std::vector&amp;lt;std::pair&amp;lt;long long,bool&amp;gt;&amp;gt; d;
        //INFで初期化する
        for(int i=0;i&amp;lt;V;i++){
            d.push_back({INF,false});
        }
        d[s].first=0;
        for(int j=0;j&amp;lt;2*V;j++){
             bool update=false;
            for(int i=0;i&amp;lt;E;i++){
                P k=es[i];
                if(d[k.first.first].first!=INF &amp;amp;&amp;amp; d[k.first.second].first&amp;gt;d[k.first.first].first+k.second){
                    d[k.first.second].first=d[k.first.first].first+k.second;
                    if(j&amp;gt;=V){
                        d[k.first.second].second=true;
                    }
                    update=true;
                }
            }
            if(!update)break;
        }
        return d;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class BellmanFord{/*省略*/};

int main(void){
    
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    BellmanFord bellmanford(N,E);
    std::vector&amp;lt;std::pair&amp;lt;long long,bool&amp;gt;&amp;gt; B = bellmanford.solve(0);
    
    for(int i=0;i&amp;lt;N;i++){
        if(B[i].second==true){
            std::cout &amp;lt;&amp;lt; &quot;-INF&quot; &amp;lt;&amp;lt; &quot; &quot;;
        }else{
            std::cout &amp;lt;&amp;lt; B[i].first &amp;lt;&amp;lt; &quot; &quot;;
        }
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;std::pair&amp;lt;long long,bool&amp;gt;&amp;gt; C = bellmanford.solve(1);
    
    for(int i=0;i&amp;lt;N;i++){
        if(C[i].second==true){
            std::cout &amp;lt;&amp;lt; &quot;-INF&quot; &amp;lt;&amp;lt; &quot; &quot;;
        }else{
            std::cout &amp;lt;&amp;lt; C[i].first &amp;lt;&amp;lt; &quot; &quot;;
        }
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1 3 7 11 
2305843009213693952 0 2 6 10 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例、コンストラクタを追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バグを修正/コメントを削除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/04&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ベルマンフォード法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">init 無向グラフを、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。 すると、グラフをsolve()が扱えるようになる 多始点などで何回も回す場合、initの実行は回でよい 計算量は</summary></entry><entry><title type="html">数学詰め合わせパック</title><link href="http://localhost:4000/library/posts/basic-math" rel="alternate" type="text/html" title="数学詰め合わせパック" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/basic-math-assortment</id><content type="html" xml:base="http://localhost:4000/library/posts/basic-math">&lt;p&gt;優柔不断なあなたに&lt;/p&gt;

&lt;p&gt;というのは建前で、それぞれ独立して扱うほどではないが重要なものを一箇所に集めた&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/basic%20math%20assortment.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注記:ページ内のコードを使用する際は、以下の表記を同時に添付してください。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
Copyright (c) 2020 0214sh7
https://github.com/0214sh7/library/
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;小数点以下切り上げ(天井関数)&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;クリックで開く&lt;/summary&gt;&lt;div&gt;

---
&lt;br /&gt;
小数点以下切り上げ
- よくある天井関数
- 計算量は$$Ο(1)$$

```
//小数点以下切り上げ
long long roundup(long long a,long long b){
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    return (a+b-1)/b;
}
```
---
&lt;/div&gt;&lt;/details&gt;

&lt;p&gt;階乗&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;に対し&lt;script type=&quot;math/tex&quot;&gt;x!&lt;/script&gt;を計算する&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;MOD&lt;/script&gt;も与えるとそれで割った余りをとる&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(x)&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//階乗
long long fact(long long x,long long MOD=INT_MAX){
  long long k=1;
  for(int i=1;i&amp;lt;=x;i++){
      k=(k*i)%MOD;
  }
  return k;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最大公約数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;２つの引数のGCDを求める&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(log(max(a,b)))&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//最大公約数
long long gcd(long long a,long long b){
  a=std::abs(a);
  b=std::abs(b);
  if(a&amp;gt;b)std::swap(a,b);
  if(a==0){
      return b;
  }
    
  long long r=a%b;
  while(r){
      a=b;
      b=r;
      r=a%b;
  }
  return b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最小公倍数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;２つの引数のLCMを求める&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(log(max(a,b)))&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//最小公倍数
long long lcm(long long a,long long b){
  if(std::abs(a)&amp;gt;std::abs(b))std::swap(a,b);
  if(a==0){
      return b;
  }
    
  long long s=a,t=b;
  a=std::abs(a);
  b=std::abs(b);
  if(a&amp;gt;b)std::swap(a,b);
    
  long long r=a%b;
  while(r){
      a=b;
      b=r;
      r=a%b;
  }
    
  return s / b * t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;素数判定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;に対し、&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;が素数ならtrueを、そうでないならfalseを返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\sqrt{x})&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//素数判定
bool prime(long long X){
  if(X&amp;lt;2)return false;
  for(long long i=2;i*i&amp;lt;=X;i++){
      if(X%i==0){
          return false;
      }
  }
  return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;素数列挙&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;に対し、&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;以下の素数を列挙し、小さい順にvectorとして返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(NloglogN)&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//素数列挙
std::vector&amp;lt;long long&amp;gt; primearray(long long N){
  std::vector&amp;lt;long long&amp;gt; R;
  std::vector&amp;lt;bool&amp;gt; prime;
  for(int i=0;i&amp;lt;=N;i++){
      prime.push_back(true);
  }
  if(N&amp;lt;2){
      return R;
  }
  prime[0]=false;
  prime[1]=false;
  for(long long i=2;i*i&amp;lt;=N;i++){
      if(!prime[i])continue;
      for(int j=2*i;j&amp;lt;=N;j+=i){
          prime[j]=false;
      }
  }
  for(long long i=0;i&amp;lt;prime.size();i++){
      if(prime[i]){
          R.push_back(i);
      }
  }
  return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;素因数分解&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;に対し、&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を素因数分解し、小さい順にvectorとして返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\sqrt{N})&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//素因数分解
std::vector&amp;lt;long long&amp;gt; prime_factorization(long long N){
  std::vector&amp;lt;long long&amp;gt; R;
  if(N&amp;lt;2)return R;
  for(long long i=2;i*i&amp;lt;=N;i++){
      while(N%i==0){
          R.push_back(i);
          N/=i;
      }
  }
  if(N!=1){
        R.push_back(N);
  }
  return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;累乗(繰り返し二乗法)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;b,e&lt;/script&gt;に対し、&lt;script type=&quot;math/tex&quot;&gt;b^e&lt;/script&gt;を返す&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;MOD&lt;/script&gt;も与えるとそれで割った余りをとる&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(log(e))&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//累乗(繰り返し二乗法)
long long power(long long b,long long e,long long MOD=INT_MAX){
  long long r=1;
  while(e){
      if(e&amp;amp;1){
          r=(r*b)%MOD;
      }
      b=(b*b)%MOD;
      e &amp;gt;&amp;gt;=1;
  }
  return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;逆元(素数MOD)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与えられた&lt;script type=&quot;math/tex&quot;&gt;b,MOD&lt;/script&gt;に対し、&lt;script type=&quot;math/tex&quot;&gt;MOD&lt;/script&gt;を法とした整数環上での逆元(&lt;script type=&quot;math/tex&quot;&gt;bx=1&lt;/script&gt;を満たす&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;)を返す&lt;/li&gt;
  &lt;li&gt;MODが素数でない場合の動作は未確認&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(log(MOD))&lt;/script&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//逆元(素数MOD)
long long inverse(long long b,long long MOD){
  long long r=1,e=MOD-2;
  while(e){
      if(e&amp;amp;1){
          r=(r*b)%MOD;
      }
      b=(b*b)%MOD;
      e &amp;gt;&amp;gt;=1;
  }
  return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">優柔不断なあなたに</summary></entry><entry><title type="html">クラスカル法</title><link href="http://localhost:4000/library/posts/kruskal" rel="alternate" type="text/html" title="クラスカル法" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-25T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/Kruskal</id><content type="html" xml:base="http://localhost:4000/library/posts/kruskal">&lt;p&gt;無向グラフを、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。&lt;/p&gt;

&lt;p&gt;すると、コストの和が最小になるような全域木を一つ構成し、その木を構成する辺をvectorとして返す&lt;/p&gt;

&lt;p&gt;辺がつなぐ&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;頂点が連結かどうかを&lt;a href=&quot;./unionfind&quot;&gt;UnionFind&lt;/a&gt;を用いて判定している&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(ElogE)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/Kruskal.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Kruskal{
    /*
    Copyright (c) 2021 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int V=0,E=0;
    typedef std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt; P;
    std::vector&amp;lt;int&amp;gt; UF,rank;
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; es;
    
    bool comp(P F,P G){
        return F.second&amp;lt;G.second;
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]&amp;lt;rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
    }
    
    public:
    
    std::vector&amp;lt;P&amp;gt; solve(std::vector&amp;lt;P&amp;gt; edge){
        //頂点数を決定する
        V=0;
        for(int i=0;i&amp;lt;edge.size();i++){
            V=std::max(V,edge[i].first.first+1);
            V=std::max(V,edge[i].first.second+1);
        }
        //辺数をもとめる　
        E=edge.size();
        //unionfindを初期化する
        UF.clear();
        rank.clear();
        for(int i=0;i&amp;lt;V;i++){
            UF.push_back(i);
            rank.push_back(0);
        }
        //辺をソートして代入しておく
        std::sort(edge.begin(),edge.end(),[&amp;amp;](P x, P y){return comp(x, y);});
        es=edge;
        
        std::vector&amp;lt;P&amp;gt; R;
        for(int i=0;i&amp;lt;E;i++){
            if(!same(es[i].first.first,es[i].first.second)){
                unite(es[i].first.first,es[i].first.second);
                R.push_back(es[i]);
            }
        }
        return R;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用例&quot;&gt;使用例&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;実行コード&quot;&gt;実行コード&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

class Kruskal{/*省略*/};

int main(void){
    
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Kruskal kruskal;
    std::vector&amp;lt;std::pair&amp;lt;std::pair&amp;lt;int,int&amp;gt;,long long&amp;gt;&amp;gt; K = kruskal.solve(E);
    
    for(int i=0;i&amp;lt;K.size();i++){
        std::cout &amp;lt;&amp;lt; K[i].first.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; K[i].first.second;
        std::cout &amp;lt;&amp;lt; &quot;  &quot; &amp;lt;&amp;lt; K[i].second &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;出力&quot;&gt;出力&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 1  1
1 2  2
2 3  4
2 4  8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更新履歴&quot;&gt;更新履歴&lt;/h2&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;日時&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用例を追加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2021/03/25&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;コメントを削除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2020/04/05&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;クラスカル法を追加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">無向グラフを、辺の始点と終点とコストを表現したpair&amp;lt;pair&amp;lt;int,int&amp;gt;,long long&amp;gt;のvectorとして与える。</summary></entry></feed>