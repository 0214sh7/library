<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/library/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/library/" rel="alternate" type="text/html" /><updated>2020-05-20T22:45:56+09:00</updated><id>http://localhost:4000/library/feed.xml</id><title type="html">すくライブラリ</title><subtitle>descriptionなんも考えてない</subtitle><entry><title type="html">座標圧縮</title><link href="http://localhost:4000/library/posts/compress" rel="alternate" type="text/html" title="座標圧縮" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/compress</id><content type="html" xml:base="http://localhost:4000/library/posts/compress">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数列&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;を与えると、クラスを&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;で初期化する&lt;/li&gt;
  &lt;li&gt;このとき、&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;の全ての&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;つの要素について大小関係が維持され、かつindexの最大値が最小になるように&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;の各要素にindexという非負整数が割り振られる&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;N=\vert A \vert&lt;/script&gt;とし、&lt;script type=&quot;math/tex&quot;&gt;Ο(NlogN)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;size&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initで与えられた数列の中に含まれる値の種類数を返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(1)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;index&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;値を与えると、その値に対応するindexを返す&lt;/li&gt;
  &lt;li&gt;もし数列に存在しない値が与えられたら、数列に存在する値の中で、与えられた値より小さい最大の値についてのindexを返す(つまり、小さい値に寄せる)&lt;/li&gt;
  &lt;li&gt;もし列のいかなる値よりも小さければ&lt;script type=&quot;math/tex&quot;&gt;-1&lt;/script&gt;を返す&lt;/li&gt;
  &lt;li&gt;計算量はinitの&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を用いて、&lt;script type=&quot;math/tex&quot;&gt;Ο(logN)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;value&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;indexを与えると値を返す&lt;/li&gt;
  &lt;li&gt;範囲外なら&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;を返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(1)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/coordinate%20compression.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class compress{
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; E;
    
    public:
    void init(std::vector&amp;lt;long long&amp;gt; A){
        E.clear();
        sort(A.begin(),A.end());
        for(int i=0;i&amp;lt;A.size();i++){
            if(i==0 || A[i]!=A[i-1]){
                E.push_back(A[i]);
            }
        }
    }
    
    int size(){
        return (int)E.size();
    }
    
    int value(int x){
        if(0&amp;lt;=x &amp;amp;&amp;amp; x&amp;lt;(int)E.size()){
            return E[x];
        }else{
            return 0;
        }
    }
    
    int index(int X){
        return (upper_bound(E.begin(),E.end(),X))-E.begin()-1;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">init 数列を与えると、クラスをで初期化する このとき、の全てのつの要素について大小関係が維持され、かつindexの最大値が最小になるようにの各要素にindexという非負整数が割り振られる 計算量はとし、</summary></entry><entry><title type="html">スライド最小値</title><link href="http://localhost:4000/library/posts/slideminimum" rel="alternate" type="text/html" title="スライド最小値" /><published>2020-04-23T00:00:00+09:00</published><updated>2020-04-23T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/slide-minimum</id><content type="html" xml:base="http://localhost:4000/library/posts/slideminimum">&lt;p&gt;数列&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;と整数&lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;を与えると、以下の数式を満たす要素数が&lt;script type=&quot;math/tex&quot;&gt;\vert A \vert -K+1&lt;/script&gt;の数列&lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt;を構成し、返す&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_i = min(A_i , A_{i+1} , ... , A_{i+K-1})&lt;/script&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\vert A \vert)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/slide%20minimum.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;long long&amp;gt; slide_minimum(std::vector&amp;lt;long long&amp;gt; A,int K){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;long long&amp;gt; R;
    int N = A.size();
    std::deque&amp;lt;int&amp;gt; D;
    for(int i=0;i&amp;lt;N;i++){
        while(!D.empty() &amp;amp;&amp;amp; A[D.back()]&amp;gt;=A[i]){D.pop_back();}
        D.push_back(i);
        if(i-K+1&amp;gt;=0){
            R.push_back(A[D.front()]);
            if(D.front()==i-K+1){
                D.pop_front();
            }
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">数列と整数を与えると、以下の数式を満たす要素数がの数列を構成し、返す</summary></entry><entry><title type="html">凸包</title><link href="http://localhost:4000/library/posts/convexhull" rel="alternate" type="text/html" title="凸包" /><published>2020-04-22T00:00:00+09:00</published><updated>2020-04-22T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/convex-hull</id><content type="html" xml:base="http://localhost:4000/library/posts/convexhull">&lt;p&gt;アルゴリズムはAndrewのmonotone chainという名前らしい&lt;/p&gt;

&lt;p&gt;二次元上の点集合をvector&amp;lt;pair&amp;lt;long long,long long»で与える&lt;/p&gt;

&lt;p&gt;するとその点集合の凸包を求め、x座標が最も小さい点のうちy座標が最も小さい点から始めて反時計回りに並べてvector&amp;lt;pair&amp;lt;long long,long long»で返す&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\vert P \vert log \vert P \vert)&lt;/script&gt;(ソートがネックになっており、ソートがなければ&lt;script type=&quot;math/tex&quot;&gt;O(\vert P \vert)&lt;/script&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/convex%20hull.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; convex_hull(std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; P){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    if(P.size()&amp;lt;=2){
        return P;
    }
    std::vector&amp;lt;std::pair&amp;lt;long long,long long&amp;gt;&amp;gt; H,L,R;
    sort(P.begin(),P.end());
    
    //下半分
    for(int i=0;i&amp;lt;P.size();i++){
        int j=L.size();
        while(j&amp;gt;=2 &amp;amp;&amp;amp; (L[j-1].first-L[j-2].first)*(P[i].second-L[j-2].second)&amp;lt;=(L[j-1].second-L[j-2].second)*(P[i].first-L[j-2].first)){
            L.pop_back();
            j--;
        }
        L.push_back(P[i]);
    }
    
    //上半分
    for(int i=P.size()-1;i&amp;gt;=0;i--){
        int j=H.size();
        while(j&amp;gt;=2 &amp;amp;&amp;amp; (H[j-1].first-H[j-2].first)*(P[i].second-H[j-2].second)&amp;lt;=(H[j-1].second-H[j-2].second)*(P[i].first-H[j-2].first)){
            H.pop_back();
            j--;
        }
        H.push_back(P[i]);
    }
    
    
    R=L;
    for(int i=1;i&amp;lt;H.size()-1;i++){
        R.push_back(H[i]);
    }
    
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">アルゴリズムはAndrewのmonotone chainという名前らしい</summary></entry><entry><title type="html">オイラーのφ関数</title><link href="http://localhost:4000/library/posts/totient" rel="alternate" type="text/html" title="オイラーのφ関数" /><published>2020-04-16T00:00:00+09:00</published><updated>2020-04-16T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/euler-totient</id><content type="html" xml:base="http://localhost:4000/library/posts/totient">&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt;はトーシェントと読むらしい&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\varphi(n)&lt;/script&gt;とは、&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;から&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;までの整数で、&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;と互いに素であるものの個数&lt;/p&gt;

&lt;p&gt;これは、&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;が相違な素因数&lt;script type=&quot;math/tex&quot;&gt;p_1,p_2,...,p_d&lt;/script&gt;を含むとして&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi(n) = n\prod_{k=1}^d (1-\frac{1}{p_k})&lt;/script&gt;

&lt;p&gt;と計算することができる&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/math/Euler's%20totient%20function.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;単体&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;\varphi(N)&lt;/script&gt;を計算し整数で返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(\sqrt{N})&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int totient(int N){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    if(N&amp;lt;0){
        return 0;
    }
    int R = N;
    for(int i=2;i*i&amp;lt;=N;i++){
        if(N%i==0){
            R -= R/i;
            while(N%i==0){
                N/=i;
            }
        }
    }
    if(N&amp;gt;1){
        R -= R/N;
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;列挙&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;から&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;までの&lt;script type=&quot;math/tex&quot;&gt;\varphi(i)&lt;/script&gt;を計算し,要素数が&lt;script type=&quot;math/tex&quot;&gt;N+1&lt;/script&gt;のvectorで返す&lt;/li&gt;
  &lt;li&gt;ここで、&lt;script type=&quot;math/tex&quot;&gt;\varphi(0)=0&lt;/script&gt;としている&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;O(NloglogN)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; totient_array(int N){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    std::vector&amp;lt;int&amp;gt; R(N+1);
    for(int i=0;i&amp;lt;=N;i++){
        R[i]=i;
    }
    for(int i=2;i&amp;lt;=N;i++){
        if(R[i]!=i)continue;
        for(int j=i;j&amp;lt;=N;j+=i){
            R[j]-=(R[j]/i);
        }
    }
    return R;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">はトーシェントと読むらしい</summary></entry><entry><title type="html">フェニック木</title><link href="http://localhost:4000/library/posts/fenwicktree" rel="alternate" type="text/html" title="フェニック木" /><published>2020-04-06T00:00:00+09:00</published><updated>2020-04-06T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/fenwick-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/fenwicktree">&lt;p&gt;BIT(Binary Indexed Tree)とも&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、要素が&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;個のフェニック木を構成し、すべての要素を&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;で初期化する&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(N)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;add&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;番目(0-indexed)の要素に&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;を加算する&lt;/li&gt;
  &lt;li&gt;計算量はinitの&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を用いて、&lt;script type=&quot;math/tex&quot;&gt;Ο(log(N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sum&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;[0,a)&lt;/script&gt;の範囲内にある要素の和をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(log(a))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;inversion&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;転　倒　数って知ってる？&lt;/li&gt;
  &lt;li&gt;数列&lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;を与えると&lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;の転倒数を計算し、long longで返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\vert V \vert log \vert V \vert)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/Fenwick%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Fenwick_tree{
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;long long&amp;gt; BIT;
    
    public:
    
    void add(int a,long long w){
        for(int x=a;x&amp;lt;BIT.size();x|=(x+1)){
            BIT[x]+=w;
        }
    }
    
    void init(int n){
        BIT.clear();
        for(int i=0;i&amp;lt;n;i++){
            BIT.push_back(0);
        }
    }
    
    long long sum(int a){
        long long r=0;
        for(int x=a-1;x&amp;gt;=0;x=(x&amp;amp;(x+1))-1){
            r+=BIT[x];
        }
        return r;
    }
    
    long long inversion(std::vector&amp;lt;long long&amp;gt; V){
        long long r=0;
        init(V.size());
        for(int i=0;i&amp;lt;V.size();i++){
            add(V[i],1);
            r+=i-sum(V[i]);
        }
        return r;
    }
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">BIT(Binary Indexed Tree)とも</summary></entry><entry><title type="html">UnionFind</title><link href="http://localhost:4000/library/posts/unionfind" rel="alternate" type="text/html" title="UnionFind" /><published>2020-04-06T00:00:00+09:00</published><updated>2020-04-06T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/unionfind</id><content type="html" xml:base="http://localhost:4000/library/posts/unionfind">&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、頂点を&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;個生成し全てを独立にした上で全てのランクを&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;にする&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(N)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;root&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;のその時点での根を求める&lt;/li&gt;
  &lt;li&gt;と同時に経路圧縮する&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\alpha (N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;α(x)&lt;/script&gt;はアッカーマン関数&lt;script type=&quot;math/tex&quot;&gt;Ack(x,x)&lt;/script&gt;の逆関数&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;Ack(4,4)=2^{2^{2^{65536}}}-3&lt;/script&gt;から伺えるように、&lt;script type=&quot;math/tex&quot;&gt;\alpha (x)&lt;/script&gt;は実用上定数(&lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt;)倍と見なせるほどに収束が遅い&lt;/p&gt;

&lt;p&gt;same&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点pと頂点qがその時点で同じ集合に属しているか(=根が同一か)を調べ、同じならtrue、違うならfalseを返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\alpha (N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unite&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点pと頂点qが属してる集合を合併する&lt;/li&gt;
  &lt;li&gt;すでに同じ集合に属している場合は無視する&lt;/li&gt;
  &lt;li&gt;pの属する集合のランクがqのものと同じか大きいときp側が根に、そうでないときq側が根になる&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\alpha (N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/union%20find.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class unionfind{
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; UF,rank;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i&amp;lt;N;i++){
            UF.push_back(i);
            rank.push_back(0);
        }
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]&amp;lt;rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">init 整数を与えると、頂点を個生成し全てを独立にした上で全てのランクをにする 計算量は</summary></entry><entry><title type="html">セグメント木</title><link href="http://localhost:4000/library/posts/segmenttree" rel="alternate" type="text/html" title="セグメント木" /><published>2020-04-06T00:00:00+09:00</published><updated>2020-04-06T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/segment-tree</id><content type="html" xml:base="http://localhost:4000/library/posts/segmenttree">&lt;p&gt;単にセグ木と言えばこれを指す、最も単純なセグ木&lt;/p&gt;

&lt;p&gt;init&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整数&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を与えると、要素が&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;個入る最小サイズの完全二分木を構成し、すべての要素を単位元で初期化する&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(N)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;calc&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;セグ木に乗せる演算を書く&lt;/li&gt;
  &lt;li&gt;場合によって使いたい演算を書き換える&lt;/li&gt;
  &lt;li&gt;演算はモノイドである必要がある&lt;/li&gt;
  &lt;li&gt;long long×long long→long longにしか対応してない　は？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;update&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;番目(0-indexed)の要素を&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;で更新し、それが影響するノードを全て更新する&lt;/li&gt;
  &lt;li&gt;計算量はinitの&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;を用いて、&lt;script type=&quot;math/tex&quot;&gt;Ο(logN)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;query&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;[a,b)&lt;/script&gt;の範囲内にある要素をcalcで計算した結果をlong longで返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(log(b-a))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class segmenttree{
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    int n;
    long long identity = 0;//単位元
    std::vector&amp;lt;long long&amp;gt; dat;
    public:
    
    void init(int N){
        n=1;
        while(n&amp;lt;N)n*=2;
        dat.clear();
        for(int i=0;i&amp;lt;2*n-1;++i){
            dat.push_back(identity);
        }
    }
    
    long long calc();
    
    void update(int k,long long a){
        k+=n-1;
        dat[k]=a;
        while(k&amp;gt;0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    long long query(long long a,long long b){
        a+=n;
        b+=n;
        long long R=0;
        while(a &amp;lt; b){
            if(a % 2 == 1){
                R = calc(R, dat[a - 1]);
                a += 1;
            }
            a /= 2;
            if(b % 2 == 1){
                b -= 1;
                R = calc(R, dat[b - 1]);
            }
            b /= 2;
        }
        return R;
    }
    
    long long calc(long long a,long long b){
        //your monoid here
        return a+b;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">単にセグ木と言えばこれを指す、最も単純なセグ木</summary></entry><entry><title type="html">ポテンシャル付きUnionFind</title><link href="http://localhost:4000/library/posts/pot-unionfind" rel="alternate" type="text/html" title="ポテンシャル付きUnionFind" /><published>2020-04-06T00:00:00+09:00</published><updated>2020-04-06T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/pot-unionfind</id><content type="html" xml:base="http://localhost:4000/library/posts/pot-unionfind">&lt;p&gt;重み付きUnionFindって言ったほうがいいのかな？正直わからない&lt;/p&gt;

&lt;p&gt;大体の機能は&lt;a href=&quot;./unionfind&quot;&gt;UnionFind&lt;/a&gt;と同じで違う点は&lt;/p&gt;

&lt;p&gt;potential&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;頂点&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;のその時点でのポテンシャルを求める&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\alpha (N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unite&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;集合を合併する際に、&lt;script type=&quot;math/tex&quot;&gt;(Qのポテンシャル)-(Pのポテンシャル)=d&lt;/script&gt;になるように指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;diff&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;(Qのポテンシャル)-(Pのポテンシャル)&lt;/script&gt;を返す&lt;/li&gt;
  &lt;li&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\alpha (N))&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/data%20structure/potentialized%20unionfind.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class potentialized_unionfind{
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    private:
    std::vector&amp;lt;int&amp;gt; UF,rank,pot;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i&amp;lt;N;i++){
            UF.push_back(i);
            rank.push_back(0);
            pot.push_back(0);
        }
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            int r = root(UF[k]);
            pot[k] += pot[UF[k]];
            UF[k] = r;
            return UF[k];
        }
    }
    
    int potential(int k){
        root(k);
        return pot[k];
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    bool unite(int P,int Q,int d){
        //pot(Q)-pot(P)=dを満たす
        d+=potential(P);
        d-=potential(Q);
        int p=root(P), q=root(Q);
        if(p==q)return false;
        if(rank[p]&amp;lt;rank[q]){
            std::swap(p,q);
            d = -d;
        }
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        pot[q]=d;
        
        return true;
    }
    
    int diff(int P,int Q){
        return potential(Q)-potential(P);
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">重み付きUnionFindって言ったほうがいいのかな？正直わからない</summary></entry><entry><title type="html">座標圧縮</title><link href="http://localhost:4000/library/posts/compress" rel="alternate" type="text/html" title="座標圧縮" /><published>2020-04-05T00:00:00+09:00</published><updated>2020-04-05T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/compress</id><content type="html" xml:base="http://localhost:4000/library/posts/compress">&lt;p&gt;数列&lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;を与えると、数列の全ての&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;つの要素について大小関係が維持される・かつ要素の最大値が最小になるように要素を非負整数に置き換える&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\vert D \vert log \vert D \vert )&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/coordinate%20compression.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; compress(std::vector&amp;lt;int&amp;gt; D){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    std::map&amp;lt;int,int&amp;gt; G;
    std::vector&amp;lt;int&amp;gt; E,r;
    int s=D.size();
    for(int i=0;i&amp;lt;s;i++){
        E.push_back(D[i]);
    }
    sort(E.begin(),E.end());
    int t=0;
    for(int i=0;i&amp;lt;s;i++){
        if(i!=0 &amp;amp;&amp;amp; E[i]!=E[i-1]){
            t++;
        }
        G[E[i]]=t;
    }
    for(int i=0;i&amp;lt;s;i++){
        r.push_back(G[D[i]]);
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">数列を与えると、数列の全てのつの要素について大小関係が維持される・かつ要素の最大値が最小になるように要素を非負整数に置き換える</summary></entry><entry><title type="html">最長増加部分列</title><link href="http://localhost:4000/library/posts/lis" rel="alternate" type="text/html" title="最長増加部分列" /><published>2020-04-05T00:00:00+09:00</published><updated>2020-04-05T00:00:00+09:00</updated><id>http://localhost:4000/library/posts/lis</id><content type="html" xml:base="http://localhost:4000/library/posts/lis">&lt;p&gt;数列&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;を与えると、&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;の最長増加部分列の長さを求め、long longで返す&lt;/p&gt;

&lt;p&gt;計算量は&lt;script type=&quot;math/tex&quot;&gt;Ο(\vert A \vert log \vert A \vert)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/0214sh7/procon-library/blob/master/algorithm/longest%20increasing%20subsequence.cpp&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long LIS(std::vector&amp;lt;long long&amp;gt; A){
    /*
    Copyright (c) 2020 0214sh7
    https://github.com/0214sh7/library/
    */
    int N=A.size();
    std::vector&amp;lt;long long&amp;gt; D;
    for(int i=0;i&amp;lt;N;i++){
        int pos=distance(D.begin(),lower_bound(D.begin(), D.end(),A[i]));
        if(pos==D.size()){
            D.push_back(A[i]);
        }else{
            D[pos]=A[i];
        }
    }
    return D.size();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">数列を与えると、の最長増加部分列の長さを求め、long longで返す</summary></entry></feed>