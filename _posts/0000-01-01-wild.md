---
title: "すくライブラリ"
permalink: /posts/wild
writer: 0214sh7
layout: library
---

<style>
    pre, code {
        white-space: pre-wrap;
    }
</style>

<h2>数学</h2>
- [数学詰め合わせパック](./posts/basic-math)
- [素数mod二項係数](./posts/binomial-coefficient)
- [素因数分解(線形篩)](./posts/sieve)
- [拡張ユークリッドの互除法](./posts/bezout-coef)
- [凸包](./posts/convexhull)
- [オイラーのφ関数](./posts/totient)
- [高速フーリエ変換(FFT)](./posts/fft)
- [数論変換(NTT)](./posts/ntt)
- [任意mod二項係数](./posts/composite-binomial-coefficient)

<h2>アルゴリズム</h2>
- [二次元配列の回転](./posts/vector2d-rotate)
- [ランレングス圧縮](./posts/run-length-encode)
- [偏角ソート](./posts/arg-sort)
- [反復写像](./posts/iterated-function)
- [スライド最小値](./posts/slideminimum)
- [座標圧縮](./posts/compress)
- [最長増加部分列](./posts/lis)
- [Moのアルゴリズム](./posts/mos-algorithm)
- [ローリングハッシュ](./posts/rollinghash)

<h2>グラフ</h2>
- [ダイクストラ法](./posts/dijkstra)
- [ベルマンフォード法](./posts/bellmanford)
- [クラスカル法](./posts/kruskal)
- [二部グラフ判定](./posts/bipartite)
- [木の直径](./posts/double-sweep)
- [最小共通祖先](./posts/lowest-common-ancestor)
- [ディニッツ法](./posts/dinic)

<h2>データ構造</h2>
- [セグメント木](./posts/segmenttree)
- [フェニック木](./posts/fenwicktree)
- [UnionFind](./posts/unionfind)
- [ポテンシャル付きUnionFind](./posts/pot-unionfind)


---
<div style="page-break-after: always;"></div>

# 🔴 数学詰め合わせパック 🔴

優柔不断なあなたに

というのは建前で、それぞれ独立して扱うほどではないが重要なものを一箇所に集めた

[github](https://github.com/0214sh7/procon-library/blob/master/math/basic%20math%20assortment.cpp)



# もくじ
- [小数点以下切り上げ(天井関数)]( #小数点以下切り上げ天井関数 )
- [階乗]( #階乗 )
- [最大公約数]( #最大公約数 )
- [最小公倍数]( #最小公倍数 )
- [約数列挙]( #約数列挙 )
- [素数判定]( #素数判定 )
- [素数列挙]( #素数列挙 )
- [素因数分解]( #素因数分解 )
- [累乗(繰り返し二乗法)]( #累乗繰り返し二乗法 )
- [逆元(素数MOD)]( #逆元素数mod )


---

## 小数点以下切り上げ(天井関数)

- よくある天井関数
- 計算量は$$Ο(1)$$

```cpp
long long roundup(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    return (a+b-1)/b;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long roundup(long long a,long long b){/*省略*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << i << " ";
    }
    std::cout << std::endl;
    for(int i=0;i<=10;i++){
        std::cout << roundup(i,4) << " ";
    }
    
    return 0;
}
```

#### 出力
```
0 1 2 3 4 5 6 7 8 9 10 
0 1 1 1 1 2 2 2 2 3 3 
```

[もくじに戻る](#もくじ)

---

## 階乗

- 与えられた$$x$$に対し$$x!$$を計算する
- $$MOD$$も与えるとそれで割った余りをとる
- 計算量は$$Ο(x)$$

```cpp
long long fact(long long x,long long MOD=LLONG_MAX){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long k=1;
    for(int i=1;i<=x;i++){
        k=(k*i)%MOD;
    }
    return k;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long fact(long long x,long long MOD=LLONG_MAX){/*省略*/}

int main(void){
    
    for(int i=0;i<=6;i++){
        std::cout << fact(i) << " ";
    }
    
    return 0;
}
```

#### 出力
```
1 1 2 6 24 120 720 
```

[もくじに戻る](#もくじ)

---

## 最大公約数

- ２つの引数のGCDを求める
- 計算量は$$O(log(max(a,b)))$$

```cpp
long long gcd(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    a=std::abs(a);
    b=std::abs(b);
    if(a>b)std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long gcd(long long a,long long b){/*省略*/}

int main(void){
    
    std::cout << gcd(4,6) << std::endl;
    std::cout << gcd(3,5) << std::endl;
    std::cout << gcd(12,18) << std::endl;
    std::cout << gcd(8,13) << std::endl;
    
    return 0;
}
```

#### 出力
```
2
1
6
1
```

[もくじに戻る](#もくじ)

---

## 最小公倍数

- ２つの引数のLCMを求める
- 計算量は$$O(log(max(a,b)))$$

```cpp
long long lcm(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(std::abs(a)>std::abs(b))std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long s=a,t=b;
    a=std::abs(a);
    b=std::abs(b);
    if(a>b)std::swap(a,b);
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    
    return s / b * t;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long lcm(long long a,long long b){/*省略*/}

int main(void){
    
    std::cout << lcm(4,6) << std::endl;
    std::cout << lcm(3,5) << std::endl;
    std::cout << lcm(12,18) << std::endl;
    std::cout << lcm(8,13) << std::endl;
    
    return 0;
}
```

#### 出力
```
12
15
36
104
```

[もくじに戻る](#もくじ)

---

## 約数列挙

- 自然数$$N$$を与えると、$$N$$の正の約数を小さい順に並べたvectorを返す
- 正でない数を与えると空のvectorを返す
- 計算量は$$O(\sqrt{N})$$

```cpp
std::vector<long long> divisor_enum(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    if(N<=0)return R;
    long long s=0;
    for(long long i=1;i*i<=N;i++){
        if(N%i==0){
            R.push_back(i);
            if(i*i!=N)s++;
        }
    }
    for(long long i = s-1;i>=0;i--){
        R.push_back(N/R[i]);
    }
    return R;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<long long> divisor_enum(long long N){/*省略*/}

signed main() {
    
    for(long long i=1;i<=10;i++){
        std::cout << i << "  ";
        std::vector<long long> K = divisor_enum(i);
        for(long long j=0;j<K.size();j++){
            std::cout << K[j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

#### 出力
```
1  1 
2  1 2 
3  1 3 
4  1 2 4 
5  1 5 
6  1 2 3 6 
7  1 7 
8  1 2 4 8 
9  1 3 9 
10  1 2 5 10 
```

[もくじに戻る](#もくじ)

---

## 素数判定

- 与えられた$$x$$に対し、$$x$$が素数ならtrueを、そうでないならfalseを返す
- 計算量は$$O(\sqrt{x})$$

```cpp
bool prime(long long X){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(X<2)return false;
    for(long long i=2;i*i<=X;i++){
        if(X%i==0){
            return false;
        }
    }
    return true;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

bool prime(long long X){/*省略*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << i << " ";
    }
    std::cout << std::endl;
    
    for(int i=0;i<=10;i++){
        std::cout << prime(i) << " ";
    }
    
    return 0;
}
```

#### 出力
```
0 1 2 3 4 5 6 7 8 9 10 
0 0 1 1 0 1 0 1 0 0 0 
```

[もくじに戻る](#もくじ)

---

## 素数列挙

- 与えられた$$N$$に対し、$$N$$以下の素数を列挙し、小さい順にvectorとして返す
- 計算量は$$O(NloglogN)$$

```cpp
std::vector<long long> primearray(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    std::vector<bool> prime;
    for(int i=0;i<=N;i++){
        prime.push_back(true);
    }
    if(N<2){
        return R;
    }
    prime[0]=false;
    prime[1]=false;
    for(long long i=2;i*i<=N;i++){
        if(!prime[i])continue;
        for(int j=2*i;j<=N;j+=i){
            prime[j]=false;
        }
    }
    for(long long i=0;i<prime.size();i++){
        if(prime[i]){
            R.push_back(i);
        }
    }
    return R;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<long long> primearray(long long N){/*省略*/}

int main(void){
    
    std::vector<long long> P = primearray(100);
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 出力
```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```

[もくじに戻る](#もくじ)

---

## 素因数分解

- 与えられた$$N$$に対し、$$N$$を素因数分解し、小さい順にvectorとして返す
- 計算量は$$Ο(\sqrt{N})$$

```cpp
std::vector<long long> prime_factorization(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    if(N<2)return R;
    for(long long i=2;i*i<=N;i++){
        while(N%i==0){
            R.push_back(i);
            N/=i;
        }
    }
    if(N!=1){
          R.push_back(N);
    }
    return R;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<long long> prime_factorization(long long N){/*省略*/}

int main(void){
    
    std::vector<long long> number={4,12,57,97,210};
    for(int j=0;j<5;j++){
        std::cout << number[j] << "  ";
        std::vector<long long> F = prime_factorization(number[j]);
        for(int i=0;i<F.size();i++){
            std::cout << F[i] << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 出力
```
4  2 2 
12  2 2 3 
57  3 19 
97  97 
210  2 3 5 7 
```

[もくじに戻る](#もくじ)

---

## 累乗(繰り返し二乗法)

- 与えられた$$b,e$$に対し、$$b^e$$を返す
- $$MOD$$も与えるとそれで割った余りをとる
- 計算量は$$Ο(log(e))$$

```cpp
long long power(long long b,long long e,long long MOD=LLONG_MAX){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long r=1;
    while(e){
        if(e&1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e >>=1;
    }
    return r;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long power(long long b,long long e,long long MOD=LLONG_MAX){/*省略*/}

int main(void){
    
    std::cout << "2のi乗"<< std::endl;
    for(int i=0;i<=10;i++){
        std::cout << power(2,i) << " ";
    }
    std::cout << std::endl;
    
    std::cout << "2のi乗を100で割ったあまり"<< std::endl;
    for(int i=0;i<=10;i++){
        std::cout << power(2,i,100) << " ";
    }
    
    return 0;
}
```

#### 出力
```
2のi乗
1 2 4 8 16 32 64 128 256 512 1024 
2のi乗を100で割ったあまり
1 2 4 8 16 32 64 28 56 12 24
```

[もくじに戻る](#もくじ)

---

## 逆元(素数MOD)

- 与えられた$$b,MOD$$に対し、$$MOD$$を法とした整数環上での逆元($$bx=1$$を満たす$$x$$)を返す
- MODが素数でない場合の動作は未確認
- 計算量は$$Ο(log(MOD))$$

```cpp
long long inverse(long long b,long long MOD){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long r=1,e=MOD-2;
    while(e){
        if(e&1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e >>=1;
    }
    return r;
}
```

### 使用例

#### 実行コード
```cpp
#include <bits/stdc++.h>

long long inverse(long long b,long long MOD){/*省略*/}

int main(void){
    
    std::cout << "mod 7でのiの逆元"<< std::endl;
    for(int i=1;i<7;i++){
        std::cout << i << " " << inverse(i,7) << " " << (i*inverse(i,7))%7 << std::endl;
    }
    
    return 0;
}
```

#### 出力
```
mod 7でのiの逆元
1 1 1
2 4 1
3 5 1
4 2 1
5 3 1
6 6 1
```

[もくじに戻る](#もくじ)

---

## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/04/05 | 約数列挙を追加 |
| 2021/03/27 | 使用例を追加 |
| 2021/03/26 | 軽微なバグを修正 |
| 2021/03/26 | アンカーリンクを追加 |
| 2021/06/01 | 素因数分解のバグを修正 |
| 2020/04/03 | 数学詰め合わせパックを追加 |

<div style="page-break-after: always;"></div>

# 🔴 素数mod二項係数 🔴


init
- 整数$$N$$を与えると、combを実行するのに必要な数値(階乗とその逆元)を前計算する
- 計算量は$$Ο(N)$$

binomial_coefficient
- コンストラクタ。initを呼ぶ

extension
- initで用意した範囲で足りない場合、整数$$N$$を与えると不足分を追加で前計算する
- 計算量は実行前のサイズを$$s$$として、$$Ο(N-s+log(MOD))$$

comb
- 整数$$n,r$$を与えると、$$\frac{n!}{r!(n-r)!}$$を$$MOD$$で割った余りを返す
- もしこれを計算するための前計算が不足している場合、ちょうど補完するようにextensionが実行される
- このため、計算量を気にしなければinitは呼ばなくても良い
- また最初にinitに十分な値を与えていればextensionは呼ばれない
- 計算量はextensionのもの+$$Ο(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/binomial%20coefficient.cpp)

```cpp
class binomial_coefficient{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const long long MOD = 998244353;
    int sze = 0;
    std::vector<long long> fact;
    std::vector<long long> factinv;
    
    long long Gfinv(long long b){
        long long r=1;
        long long e=MOD-2;
        while(e){
            if(e&1){
                r=(r*b)%MOD;
            }
                b=(b*b)%MOD;
                e >>=1;
        }
        return r;
    }
    
    public:
    
    void init(int N){
        if(N<0){
            return ;
        }
        sze = N+1;
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[0]=1;
        for(long long i=1;i<=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i>=0;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
    }
    
    binomial_coefficient(int N){
        init(N);
    }
    
    void extension(int N){
        if(sze>N && sze!=0){
            return ;
        }
        
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[sze]=(sze==0)?1:(fact[sze-1]*sze)%MOD;
        
        for(long long i=sze+1;i<=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i>=sze;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
        sze = N+1;
    }
    
    long long comb(long long n,long long r){
        if(n<0 || r<0 || n<r){
            return 0;
        }
        
        if(n>=sze){
            extension(n);
        }
        
        long long R = fact[n];
        R = (R*factinv[r])%MOD;
        R = (R*factinv[n-r])%MOD;
        return R;
    }
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class binomial_coefficient{/*省略*/};

int main(void){
    
    binomial_coefficient BC(10);
    for(int i=0;i<=5;i++){
        for(int j=0;j<=5;j++){
            std::cout << BC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

### 出力
```
1 0 0 0 0 0 
1 1 0 0 0 0 
1 2 1 0 0 0 
1 3 3 1 0 0 
1 4 6 4 1 0 
1 5 10 10 5 1 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2023/03/18 | 名称を二項係数から素数mod二項係数に変更 |
| 2021/03/25 | 使用例、コンストラクタを追加 |
| 2021/02/18 | nを指定してvectorを返す形式からclass化しn,rからnCrを返す形式に変更 |
| 2020/04/04 | 二項係数を追加 |

<div style="page-break-after: always;"></div>

# 🔴 素因数分解(線形篩) 🔴


init
- 整数$$N$$を与えると、前計算として$$N$$以下の合成数$$i$$について$$i$$の自明でない($$1$$でも$$i$$でもない)約数の1つを求める
- それと同時に、$$N$$以下の素数のリストも求める
- 以降の関数に$$N$$より大きい値を与えると補完のためにinitが呼ばれる。これは最初にinitに十分大きい値を与えることで回避できる
- 計算量は$$Ο(N)$$

linear_sieve
- コンストラクタ。initを呼ぶ

primearray
- 整数$$N$$を与えると、$$N$$以下の素数を昇順に並べたvectorを返す
- もし前計算が足りない場合、ちょうど補完するようにinitが実行される
- 計算量はinitのもの+$$Ο(N/log(N))$$

divisor
- 整数$$N$$を与えると、前計算した$$N$$の自明でない約数の1つを返す
- もし$$N$$が素数なら$$N$$を、$$1$$なら$$1$$を、正でないなら$$-1$$を返す
- もし前計算が足りない場合、ちょうど補完するようにinitが実行される
- 計算量はinitのもの+$$Ο(1)$$

factorization
- 整数$$X$$を与えると、$$X$$を素因数分解し、結果を**大きい順に**並べ、vectorとして返す
- もし前計算が足りない場合、ちょうど補完するようにinitが実行される
- 計算量はinitのもの+$$Ο(log(N))$$

exp_enum
- 整数$$N,M,mod$$を与えると、$$0^M,1^M,...,N^M$$をそれぞれ$$mod$$で割ったあまりを計算し、vectorとして返す
- $$N,M$$が負である場合、空のvectorを返す
- もし前計算が足りない場合、ちょうど補完するようにinitが実行される
- 計算量はinitのもの+$$Ο(N + N \frac{log(M)}{log(N)})$$


[github](https://github.com/0214sh7/procon-library/blob/master/math/linear%20sieve.cpp)

```cpp
class linear_sieve{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    long long S=0;
    std::vector<long long> divisor_,prime;
    
    public:
    void init(long long N){
        S=N;
        prime.clear();
        divisor_.resize(N+1);
        for(long long i=0;i<N+1;i++){
            divisor_[i]=0;
        }
        
        if(N>=1){
            divisor_[1]=1;
        }
        
        
        for(long long i=2;i<=N;i++){
            if(divisor_[i]==0){
                divisor_[i]=i;
                prime.push_back(i);
            }
            for(long long j=0;j<=prime.size() && prime[j]<=divisor_[i] && i*prime[j]<=N ;j++){
                divisor_[prime[j]*i]=prime[j];
            }
        }
    }
    
    linear_sieve(long long N){
        init(N);
    }
    
    std::vector<long long> primearray(long long X){
        std::vector<long long> R;
        if(X<=1)return R;
        if(S<X)init(X);
        for(long long i=0;i<prime.size();i++){
            if(prime[i]<=X){
                R.push_back(prime[i]);
            }
        }
        return R;
    }
    
    long long divisor(long long X){
        if(X<=0)return -1;
        if(S<X)init(X);
        return divisor_[X];
    }
    
    std::vector<long long> factorization(long long X){
        std::vector<long long> R;
        if(X<=1)return R;
        if(S<X)init(X);
        R = factorization(X/divisor_[X]);
        R.push_back(divisor_[X]);
        return R;
    }
    
    std::vector<long long> exp_enum(long long N,long long M,long long mod=LLONG_MAX){
        std::vector<long long> R;
        if(N<0 || M<0)return R;
        if(S<N)init(N);
        
        for(long long i=0;i<=N;i++){
            R.push_back(-1);
        }
        R[0]=0;
        if(N>=1)R[1]=1;
        
        for(long long i=0;i<prime.size();i++){
            if(prime[i]>N)continue;
            long long r=1,b=prime[i],e=M;
            while(e){
                if(e&1){
                    r=(r*b)%mod;
                }
                b=(b*b)%mod;
                e >>=1;
            }
            R[prime[i]]=r;
        }
        
        for(long long i=0;i<=N;i++){
            if(R[i]!=-1)continue;
            R[i] = (R[i/divisor_[i]]*R[divisor_[i]])%mod;
        }
        return R;
    }
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class linear_sieve{/*省略*/};

int main(void){
    
    linear_sieve sieve(1000);
    
    std::cout << "100以下の素数のリスト" << std::endl;
    std::vector<long long> P = sieve.primearray(100);
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "1~10の約数の一つ" << std::endl;
    for(int i=1;i<=10;i++){
        std::cout << sieve.divisor(i) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "4,12,57,97,210の素因数分解" << std::endl;
    std::vector<long long> number={4,12,57,97,210};
    for(int j=0;j<5;j++){
        std::vector<long long> F = sieve.factorization(number[j]);
        for(int i=0;i<F.size();i++){
            std::cout << F[i] << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::cout << "0~10について、i^3" << std::endl;
    std::vector<long long> E = sieve.exp_enum(10,3);
    for(int i=0;i<E.size();i++){
        std::cout << E[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
100以下の素数のリスト
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 

1~10の約数の一つ
1 2 3 2 5 2 7 2 3 2 

4,12,57,97,210の素因数分解
2 2 
3 2 2 
19 3 
97 
7 5 3 2 

0~10について、i^3
0 1 8 27 64 125 216 343 512 729 1000 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/24 | 素因数分解(線形篩)を追加 |

<div style="page-break-after: always;"></div>

# 🔴 拡張ユークリッドの互除法 🔴

拡張ユークリッドの互除法、extended Euclidean algorithmの対訳感がそんなにないね　どうでもいいね

整数$$a,b$$を与えると、$$g=gcd(a,b)$$とそれを用いて表される等式

$$ax+by=g$$

を満たす$$(x,y)$$(ベズー係数)を一つ求め、$$g$$とともに返す

計算量は$$O(log(max(a,b)))$$

ここで返り値はpair<ll,pair<ll,ll>>となっているが、それぞれ$$ \{g,\{x,y\}\} $$を表している

[github](https://github.com/0214sh7/procon-library/blob/master/math/extended%20Euclidean%20algorithm.cpp)

```cpp
std::pair<long long,std::pair<long long,long long>> extgcd(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> q;
    while(b!=0){
        long long r = a%b;
        r+=b;
        r%=b;
        long long q_ = (a-r)/b;
        q.push_back(q_);
        a = b;
        b = r;
    }
    
    long long g=a,x=1,y=0;
    if(g<0){
        g*=-1;
        x*=-1;
    }
    for(int i=-1+(int)q.size();i>=0;i--){
        long long tmp = y;
        y = x-q[i]*y;
        x = tmp;
    }
    
    return {g,{x,y}};
}
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::pair<long long,std::pair<long long,long long>> extgcd(long long a,long long b){/*省略*/}

signed main() {
    
    std::pair<long long,std::pair<long long,long long>> R;
    R = extgcd(111,30);
    long long g = R.first, x = R.second.first, y = R.second.second;
    
    std::cout << "111と30の最大公約数" << std::endl;
    std::cout << g << std::endl;
    std::cout << std::endl;
    
    
    std::cout << "111x+30y=3を満たすような(x,y)の一例" << std::endl;
    std::cout << "(" << x << "," << y << ")" << std::endl;
    std::cout << std::endl;
    
    
    std::cout << "111x+30y" << std::endl;
    std::cout << 111*x+30*y << std::endl;
    
    return 0;
}
```

### 出力
```
111と30の最大公約数
3

111x+30y=3を満たすような(x,y)の一例
(3,-11)

111x+30y
3
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/04/08 | 欠落していた計算量を追加 |
| 2021/04/08 | 拡張ユークリッドの互除法を追加 |

<div style="page-break-after: always;"></div>

# 🔴 凸包 🔴

アルゴリズムはAndrewのmonotone chainという名前らしい

二次元上の点集合をvector<pair<long long,long long>>で与える

するとその点集合の凸包を求め、x座標が最も小さい点のうちy座標が最も小さい点から始めて反時計回りに並べてvector<pair<long long,long long>>で返す

計算量は$$O(\vert P \vert log \vert P \vert)$$(ソートがネックになっており、ソートがなければ$$O(\vert P \vert)$$)

[github](https://github.com/0214sh7/procon-library/blob/master/math/convex%20hull.cpp)

```cpp
std::vector<std::pair<long long,long long>> convex_hull(std::vector<std::pair<long long,long long>> P){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(P.size()<=2){
        return P;
    }
    std::vector<std::pair<long long,long long>> H,L,R;
    sort(P.begin(),P.end());
    
    //下半分
    for(int i=0;i<P.size();i++){
        int j=L.size();
        while(j>=2 && (L[j-1].first-L[j-2].first)*(P[i].second-L[j-2].second)<=(L[j-1].second-L[j-2].second)*(P[i].first-L[j-2].first)){
            L.pop_back();
            j--;
        }
        L.push_back(P[i]);
    }
    
    //上半分
    for(int i=P.size()-1;i>=0;i--){
        int j=H.size();
        while(j>=2 && (H[j-1].first-H[j-2].first)*(P[i].second-H[j-2].second)<=(H[j-1].second-H[j-2].second)*(P[i].first-H[j-2].first)){
            H.pop_back();
            j--;
        }
        H.push_back(P[i]);
    }
    
    
    R=L;
    for(int i=1;i<H.size()-1;i++){
        R.push_back(H[i]);
    }
    
    return R;
}
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<std::pair<long long,long long>> convex_hull(std::vector<std::pair<long long,long long>> P){/*省略*/}

int main(void){
    
    std::vector<std::pair<long long,long long>> P,Q;
    P.push_back({0,0});
    P.push_back({2,0});
    P.push_back({1,1});
    P.push_back({0,2});
    P.push_back({2,2});
    
    Q = convex_hull(P);
    for(int i=0;i<Q.size();i++){
        std::cout << Q[i].first << " " << Q[i].second << std::endl;
    }
    return 0;
}
```

### 出力
```
0 0
2 0
2 2
0 2
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例を追加 |
| 2020/04/22 | 凸包を追加 |

<div style="page-break-after: always;"></div>

# 🔴 オイラーのφ関数 🔴

$$\varphi$$はトーシェントと読むらしい

$$\varphi(n)$$とは、$$1$$から$$n$$までの整数で、$$n$$と互いに素であるものの個数

これは、$$n$$が相違な素因数$$p_1,p_2,...,p_d$$を含むとして

$$\varphi(n) = n\prod_{k=1}^d (1-\frac{1}{p_k})$$

と計算することができる

[github](https://github.com/0214sh7/procon-library/blob/master/math/Euler's%20totient%20function.cpp)


単体
- 整数$$N$$を与えると、$$\varphi(N)$$を計算し整数で返す
- 計算量は$$O(\sqrt{N})$$

```cpp
int totient(int N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(N<0){
        return 0;
    }
    int R = N;
    for(int i=2;i*i<=N;i++){
        if(N%i==0){
            R -= R/i;
            while(N%i==0){
                N/=i;
            }
        }
    }
    if(N>1){
        R -= R/N;
    }
    return R;
}
```


列挙
- 整数$$N$$を与えると、$$0$$から$$N$$までの$$\varphi(i)$$を計算し,要素数が$$N+1$$のvectorで返す
- ここで、$$\varphi(0)=0$$としている
- 計算量は$$O(NloglogN)$$

```cpp
std::vector<int> totient_array(int N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<int> R(N+1);
    for(int i=0;i<=N;i++){
        R[i]=i;
    }
    for(int i=2;i<=N;i++){
        if(R[i]!=i)continue;
        for(int j=i;j<=N;j+=i){
            R[j]-=(R[j]/i);
        }
    }
    return R;
}
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

int totient(int N){/*省略*/}
std::vector<int> totient_array(int N){/*省略*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << totient(i) << " ";
    }
    std::cout << std::endl;
    
    std::vector<int> T = totient_array(10);
    for(int i=0;i<=10;i++){
        std::cout << T[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
0 1 1 2 2 4 2 6 4 6 4 
0 1 1 2 2 4 2 6 4 6 4 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例を追加 |
| 2020/04/16 | オイラーのφ関数を追加 |

<div style="page-break-after: always;"></div>

# 🔴 高速フーリエ変換 🔴

クラスで実装されているが、実行するときはconvolutionを呼び出せばいい

多項式に見立てたvectorを$$2$$つ与えると、それらに対し高速フーリエ変換を用いた畳み込み演算を行い一つの多項式にし、vectorとして返す

$$\{1,2,3\}*\{1,3,5\}=\{1,5,14,19,15\}$$といった調子

実装上doubleを経由しているので誤差死が怖い

計算量は$$N=max(\vert A \vert,\vert B\vert)$$として、$$Ο(NlogN)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/fast%20Fourier%20transform.cpp)

```cpp
class fast_Fourier_transform{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const double PI=3.14159265358979; 
    
    std::vector<std::complex<double>> DFT(std::vector<std::complex<double>> A){
        int N=A.size();
        if(N==1)return A;
        std::vector<std::complex<double>> A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i<N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        for(int i=0;i<N;i++){
            std::complex<double> ith_zeta = std::complex<double>(cos(2*PI*i/N),sin(2*PI*i/N));
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)]);
        }
        return iA;
    }
    
    std::vector<std::complex<double>> iDFT(std::vector<std::complex<double>> iA){
        int N=iA.size();
        std::vector<std::complex<double>> A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i<N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back(rA[i]/std::complex<double>(N,0));
        }
        return A;
    }
    
    public:
    std::vector<long long> convolution(std::vector<long long> A,std::vector<long long> B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N<deg){N<<=1;}
        A.resize(N);B.resize(N);
        std::vector<std::complex<double>> dC(N),iC(N),dA,iA,dB,iB;
        std::vector<long long> C(N);
        for(int i=0;i<A.size();i++){
            dA.push_back(A[i]);
        }
        for(int i=0;i<B.size();i++){
            dB.push_back(B[i]);
        }
        iA=DFT(dA);iB=DFT(dB);
        for(int i=0;i<N;i++){
            iC[i]=iA[i]*iB[i];
        }
        dC=iDFT(iC);
        for(int i=0;i<dC.size();i++){
            C[i]=(0.1+dC[i].real());
        }
        C.resize(deg);
        return C;
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class fast_Fourier_transform{/*省略*/};

int main(void){
    
    fast_Fourier_transform FFT;
    std::vector<long long> A={1,2,3},B={1,3,5},C;
    
    C = FFT.convolution(A,B);
    for(int i=0;i<C.size();i++){
        std::cout << C[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
1 5 14 19 15 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | バグを修正 |
| 2021/03/25 | 使用例を追加 |
| 2020/04/04 | 高速フーリエ変換を追加 |

<div style="page-break-after: always;"></div>

# 🔴 数論変換 🔴

整数環FFTとも

基本的には[FFT](./fft)と同じだが、あちらが実数を使って計算するのに対しこちらは有理数を素数で割った余りを使って計算する

誤差がないというメリットがあるが、$$MOD$$素数より大きい整数を扱えないというデメリットがある

ここで用いる素数は、$$P-1$$が素因数に$$2$$を多く含むような$$P$$であることが望ましい(例えばNTTでよく使われる$$998244353$$は$$119 \cdot 2^{23}+1$$である)


計算量は$$N=max(\vert A \vert,\vert B \vert)$$として、$$Ο(NlogNlogMOD)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/number%20theoretic%20transform.cpp)

```cpp
class number_theoretic_transform{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    
    const long long MOD = 998244353;
    const long long k = 119;
    const long long n = 23;
    const long long pri_root = 3;
    //MOD=k*2^n+1
    
    long long BE(long long b,long long e){
        long long r=1;
        while(e){
            if(e&1){
                r=(r*b)%MOD;
            }
            b=(b*b)%MOD;
            e >>=1;
        }
        return r;
    }
    
    std::vector<long long> DFT(std::vector<long long> A){
        int N=A.size();
        if(N==1)return A;
        std::vector<long long> A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i<N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        long long omega=BE(pri_root,k*(1<<n)/N);
        long long ith_zeta = 1;
        for(int i=0;i<N;i++){
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)])%MOD;
            ith_zeta = (ith_zeta*omega)%MOD;
        }
        return iA;
    }
     
    std::vector<long long> iDFT(std::vector<long long> iA){
        int N=iA.size();
        long long N_inverse = BE(N,MOD-2);
        std::vector<long long> A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i<N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back((rA[i]*N_inverse)%MOD);
        }
        return A;
    }
    
    
    public:
    
    std::vector<long long> convolution(std::vector<long long> A,std::vector<long long> B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N<deg){N<<=1;}
        A.resize(N);B.resize(N);
        for(int i=0;i<A.size();i++){
            A[i]%=MOD;
        }
        for(int i=0;i<B.size();i++){
            B[i]%=MOD;
        }
        std::vector<long long> C(N),iC(N),iA,iB;
        iA=DFT(A);iB=DFT(B);
        for(int i=0;i<N;i++){
            iC[i]=(iA[i]*iB[i])%MOD;
        }
        C=iDFT(iC);
        C.resize(deg);
        return C;
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class number_theoretic_transform{/*省略*/};

int main(void){
    
    number_theoretic_transform NTT;
    std::vector<long long> A={1,2,3},B={1,3,5},C;
    
    C = NTT.convolution(A,B);
    for(int i=0;i<C.size();i++){
        std::cout << C[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
1 5 14 19 15 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例を追加/vectorをstd::vectorに変更 |
| 2020/04/04 | 数論変換を追加 |

<div style="page-break-after: always;"></div>

# 🔴 任意mod二項係数 🔴

計算量の異なる $$2$$ つのコードがある

[github](https://github.com/0214sh7/procon-library/blob/master/math/composite%20binomial%20coefficient.cpp)


- [その１]( #その１ )
  - $$n,r \leq 10^{18}, mod \leq 10^6$$ 程度の場合に計算できる
- [その２]( #その２ )
  - $$n,r \leq 10^6, mod \leq 10^9$$ 程度の場合に計算できる 

***

## その１

init
- mod $$M$$を与えると、combを実行するのに必要な数値を前計算する
- 計算量は $$M$$ の素因数分解を $$ \prod_{i=1}^{\omega(M)}{ {p_i}^{e_i}} $$ とすると $$Ο( \sum_{i=1}^{\omega(M)}{ {p_i}^{e_i}} + \sqrt{M})$$
  - $$\omega(m)$$ は $$m$$ の素因数の個数、$$m \leq 10^9$$ のとき $$\omega(m) \leq 10$$

composite_binomial_coefficient_1
- コンストラクタ。initを呼ぶ

comb
- 整数$$n,r$$を与えると、$$\frac{n!}{r!(n-r)!}$$を$$M$$で割った余りを返す
- extensionはないため、$$n$$ にinitで与えた $$N$$ より大きい値を与えた場合の挙動は保証しない
- 計算量は$$Ο( (\log n + \log M) \omega(M) )$$


```cpp
class composite_binomial_coefficient_1{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    long long Mod;    
    std::vector<std::array<long long,3>> P;
    std::vector<std::vector<long long>> fact,factinv;

    std::pair<long long,long long> bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair<long long,long long> D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(long long M){

        if(M<1){
            return;
        }

        Mod = M;

        //Mを素因数分解する
        //Pは{素数,個数,素数^個数}
        P.clear();
        long long m = M;
        for(int i=2;i*i<=m;i++){
            int v = 1;
            int e = 0;
            while(m%i==0){
                e++;
                m /= i;
                v *= i;
            }
            if(e>0){
                P.push_back({i,e,v});
            }
        }
        if(m!=1){
            P.push_back({m,1,m});
        }

        //用いる素数pについて、(x!)_p := (1~xでpと互いに素なものの積)を求める
        fact.clear();
        fact.resize(P.size());
        factinv.clear();
        factinv.resize(P.size());

        for(int i=0;i<(int)P.size();i++){
            fact[i].resize(P[i][2]);
            fact[i][0] = 1;
            for(int j=1;j<P[i][2];j++){
                if(j%P[i][0]==0){
                    fact[i][j] = fact[i][j-1];
                }else{
                    fact[i][j] = (fact[i][j-1]*j)%P[i][2];
                }
            }

            factinv[i].resize(P[i][2]);
            factinv[i][P[i][2]-1] = bezout(fact[i][P[i][2]-1],P[i][2]).first;
            if(factinv[i][P[i][2]-1]<0)factinv[i][P[i][2]-1] += P[i][2];
            
            for(int j=P[i][2]-2;j>=0;j--){
                if((j+1)%P[i][0]==0){
                    factinv[i][j] = factinv[i][j+1];
                }else{
                    factinv[i][j] = (factinv[i][j+1]*(j+1))%P[i][2];
                }
            }
        }
    }

    composite_binomial_coefficient_1(long long mod){
        init(mod);
    }

    long long comb(long long n,long long r){
        
        if(n<0 || r<0 || n<r || Mod==1){
            return 0;
        }
        long long k = n-r;

        //各p^qについてnCr mod p^qを求めてLにまとめる
        std::vector<std::pair<long long,long long>> L(P.size());

        for(int i=0;i<(int)P.size();i++){
            long long p = P[i][0], q = P[i][1], pq = P[i][2];

            std::vector<long long> N,K,R;
            long long nown = n, nowk = k, nowr = r;
            while(nown>0){
                N.push_back(nown%pq);
                K.push_back(nowk%pq);
                R.push_back(nowr%pq);
                nown /= p;
                nowk /= p;
                nowr /= p;
            }

            long long e0 = 0, e1 = 0;
            nown = n/p, nowk = k/p, nowr = r/p;
            while(nown > 0){
                e0 += nown;
                e0 -= nowk;
                e0 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            nown = n/pq, nowk = k/pq, nowr = r/pq;
            while(nown > 0){
                e1 += nown;
                e1 -= nowk;
                e1 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            
            long long T = 1;
            if((p!=2 || q<3) && e1%2 == 1){
                T = pq-1;
            }

            for(int j=0;j<(int)N.size();j++){
                T = (T*fact[i][N[j]])%pq;
                T = (T*factinv[i][K[j]])%pq;
                T = (T*factinv[i][R[j]])%pq;
            }

            for(int j=0;j<std::min(q,e0);j++){
                T = (T*p)%pq;
            }

            L[i] = {T,pq};
        }

        //中国剰余定理を用いて復元する
        std::pair<long long,long long> C = L[0];
        for(int i=1;i<(int)P.size();i++){
            long long q = C.second*L[i].second;
            std::pair<long long,long long> u = bezout(C.second,L[i].second);
            long long c = (((C.first*L[i].second)%q)*u.second)%q;
            long long d = (((L[i].first*C.second)%q)*u.first)%q;
            C.first = (c+d+q)%q;
            C.second = q;
        }

        return C.first;
    }
};
```


### 使用例
***

#### 実行コード
```cpp
#include <bits/stdc++.h>

class composite_binomial_coefficient_1{/*省略*/};

int main(void){
    
    std::cout << "10で割ったあまり" << std::endl; 
    composite_binomial_coefficient_1 CBC(10);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;

    std::cout << "もとの値" << std::endl;
    composite_binomial_coefficient_1 CBC_origin(1000);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC_origin.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

#### 出力
```
10で割ったあまり
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

もとの値
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

```

### 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2023/03/18 | 任意mod二項係数を追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [Library Checker](https://judge.yosupo.jp/problem/binomial_coefficient) | [提出](https://judge.yosupo.jp/submission/130133) |

***


## その２

init
- 整数$$N$$とmod $$M$$を与えると、combを実行するのに必要な数値を前計算する
- 計算量は $$Ο(N \log N + N \omega(M) + \sqrt{M})$$
  - $$\omega(m)$$ は $$m$$ の素因数の個数、$$m \leq 10^9$$ のとき $$\omega(m) \leq 10$$
<!-- √M + Nω(M) + Ω(N!) , もっとタイトな評価ができそう -->

composite_binomial_coefficient_2
- コンストラクタ。initを呼ぶ

comb
- 整数$$n,r$$を与えると、$$\frac{n!}{r!(n-r)!}$$を$$M$$で割った余りを返す
- extensionはないため、$$n$$ にinitで与えた $$N$$ より大きい値を与えた場合の挙動は保証しない
- 計算量は$$Ο(\log M + \omega(M) )$$
  - 特に、 $$n,r$$ に依存しない


```cpp
class composite_binomial_coefficient_2{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int sze = 0;
    long long Mod;
    std::vector<long long> P;
    std::vector<long long> d,prime;
    std::vector<int> index;
    std::vector<long long> factPri;
    std::vector<std::vector<long long>> factRel;
    std::vector<std::vector<long long>> power;

    std::pair<long long,long long> bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair<long long,long long> D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(int N,long long M){

        if(N<0 || M<1){
            return;
        }

        if(M==1){
            Mod = M;
            return;
        }

        sze = N+1;
        Mod = M;
        
        //1~Nの非自明な約数を求める
        d.resize(N+1);
        std::fill(d.begin(),d.end(),0);
        prime.clear();
        index.resize(N+1);
        std::fill(index.begin(),index.end(),-1);

        if(N>0){
            d[1] = 1;
        }
        for(long long i=2;i<=N;i++){
            if(d[i]==0){
                d[i]=i;
                prime.push_back(i);
            }
            for(int j=0;j<(int)prime.size() && prime[j]<=d[i] && i*prime[j]<=N ;j++){
                d[prime[j]*i]=prime[j];
            }
        }
        
        //法が含む素数のリストを求める
        P.clear();
        for(int i=2;i*i<=M;i++){
            int e = 0;
            while(M%i==0){
                e++;
                M /= i;
            }
            if(e>0){
                if(i<=N)index[i] = P.size();
                P.push_back(i);
            }
        }
        if(M!=1){
            if(M<=N)index[M] = P.size();
            P.push_back(M);
        }

        //k!について、Mと互いに素である部分とそうでない部分に分けてそれぞれ求める
        factPri.resize(N+1);
        std::fill(factPri.begin(),factPri.end(),1);
        factRel.resize(N+1);
        for(int i=0;i<=N;i++){
            factRel[i].resize(P.size());
            std::fill(factRel[i].begin(),factRel[i].end(),0);
        }

        for(int i=2;i<=N;i++){

            factPri[i] = factPri[i-1];
            factRel[i] = factRel[i-1];

            long long now = i;
            while(now>1){
                long long p = d[now];
                if(index[p]==-1){
                    factPri[i] = (factPri[i]*p)%Mod;
                }else{
                    factRel[i][index[p]]++;
                }
                now /= p;
            }
        }

        //p^0,p^1,...,p^(N/p)を前計算する
        power.resize(P.size());
        for(int i=0;i<(int)P.size();i++){
            power[i].resize(1+N/P[i]);
            power[i][0] = 1;
            for(int j=1;j<1+N/P[i];j++){
                power[i][j] = (power[i][j-1]*P[i])%Mod;
            }
        }

    }

    composite_binomial_coefficient_2(int N,long long M){
        init(N,M);
    }

    long long comb(long long n,long long r){
        if(Mod==1){
            return 0;
        }
        if(n<0 || r<0 || n<r){
            return 0;
        }

        long long R = factPri[n];
        long long m = bezout(factPri[r],Mod).first;
        if(m<0)m+=Mod;
        R = (R*m)%Mod;
        m = bezout(factPri[n-r],Mod).first;
        if(m<0)m+=Mod;
        R = (R*m)%Mod;

        for(int i=0;i<(int)P.size();i++){
            int e = factRel[n][i] - factRel[r][i] - factRel[n-r][i];
            assert(e>=0);
            R = (R*power[i][e])%Mod;
        }

        return R;
    }

};
```


### 使用例
***

#### 実行コード
```cpp
#include <bits/stdc++.h>

class composite_binomial_coefficient_2{/*省略*/};

int main(void){
    
    std::cout << "10で割ったあまり" << std::endl; 
    composite_binomial_coefficient_2 CBC(8,10);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;

    std::cout << "もとの値" << std::endl;
    composite_binomial_coefficient_2 CBC_origin(8,1000);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC_origin.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

#### 出力
```
10で割ったあまり
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

もとの値
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

```

### 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2023/03/18 | 任意mod二項係数を追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [ARC012-D](https://atcoder.jp/contests/arc012/tasks/arc012_4) | [提出](https://atcoder.jp/contests/arc012/submissions/39798965) |

<div style="page-break-after: always;"></div>

# 🔴 二次元配列の回転 🔴

二次元配列$$A$$を与えると、$$A$$を反時計回りに回転させ返す

第二変数を$$true$$にすると時計回りに回転させる

もし$$A[i]$$の長さが揃っていない場合は最も長いものに合わせ、足りない部分は第三変数の値(デフォルトは$$0$$)で埋める

計算量は配列を$$N$$行$$M$$列として$$Ο(NM)$$

[github]()

```cpp
std::vector<std::vector<char>> vector2D_rotate(std::vector<std::vector<char>> A,bool clockwise=false,char leading = 0){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int N = A.size();
    if(N==0)return A;
    
    int M = 0;
    for(int i=0;i<N;i++){
        M = std::max(M,(int)A[i].size());
    }
    
    std::vector<std::vector<char>> B(M,std::vector<char>(N,leading));
    
    for(int i=0;i<N;i++){
        for(int j=0;j<A[i].size();j++){
            if(clockwise){
                B[j][N-1-i]=A[i][j];
            }else{
                B[M-1-j][i]=A[i][j];
            }
        }
    }
    
    return B;
}
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<std::vector<char>> vector2D_rotate(std::vector<std::vector<char>> A,bool clockwise=false,char leading = 0){/*省略*/}

int main(){
    
    std::vector<std::vector<char>> A ={
        {'a','b','c'},
        {'d','e','f'},
        {'g','h','i'}
    };
    
    std::cout << "回転なし" << std::endl;
    for(int i=0;i<A.size();i++){
        for(int j=0;j<A[i].size();j++){
            std::cout << A[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<std::vector<char>> counter = vector2D_rotate(A);
    
    std::cout << "反時計回り" << std::endl;
    for(int i=0;i<counter.size();i++){
        for(int j=0;j<counter[i].size();j++){
            std::cout << counter[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<std::vector<char>> clockwise = vector2D_rotate(A,true);
    
    std::cout << "時計回り" << std::endl;
    for(int i=0;i<clockwise.size();i++){
        for(int j=0;j<clockwise[i].size();j++){
            std::cout << clockwise[i][j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### 出力
```
回転なし
a b c 
d e f 
g h i 

反時計回り
c f i 
b e h 
a d g 

時計回り
g d a 
h e b 
i f c
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/09/12 | 二次元配列の回転を追加 |

<div style="page-break-after: always;"></div>

# 🔴 ランレングス圧縮 🔴

文字列$$S$$を与えると、$$S$$をランレングス圧縮(連長圧縮)して返す

ランレングス圧縮とは、文字列を「文字と、それがいくつ続くか」の組に変換するものである
ちなみに可逆変換

計算量は$$Ο(\vert S \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/runlength%20encode.cpp)

```cpp
std::vector<std::pair<char,int>> runlength_encode(std::string S){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<std::pair<char,int>> R;
    for(int i=0;i<(int)S.size();i++){
        if(i==0 || S[i]!=S[i-1]){
            R.push_back({S[i],1});
        }else{
            R.back().second++;
        }
    }
    return R;
}
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<std::pair<char,int>> runlength_encode(std::string S){/*省略*/}

int main(void){
    
    std::string S = "abbcccddeeeacddd";
    std::vector<std::pair<char,int>> R = runlength_encode(S);
    for(int i=0;i<(int)R.size();i++){
        std::cout << R[i].first << " " << R[i].second << std::endl;
    }
    
    return 0;
}
```

### 出力
```
a 1
b 2
c 3
d 2
e 3
a 1
c 1
d 3
```

## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2022/07/10 | ランレングス圧縮を追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [ABC259-C](https://atcoder.jp/contests/abc259/tasks/abc259_c) | [提出](https://atcoder.jp/contests/abc259/submissions/33129519) |

<div style="page-break-after: always;"></div>

# 🔴 偏角ソート 🔴

数列$$A$$を与えると、以下の並べ方で$$A$$をソートして返す
基準を第二変数$$d$$(デフォルトでは$$(1,0)$$)で定めることもできる

- 偏角(のうち、$$[\arg(d),\arg(d)+2\pi)$$であるもの)が小さい順に並べる
- それが同じ場合、絶対値が小さい順に並べる
- $$(0,0)$$が含まれる場合assertして停止する


計算量は$$Ο(\vert A \vert log \vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/arg%20sort.cpp)

```cpp
std::vector<std::pair<long long,long long>> arg_sort(std::vector<std::pair<long long,long long>> A,std::pair<long long,long long> d = {1,0}){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long N = A.size();
    assert(d.first != 0 || d.second != 0);
    long long g = std::gcd(d.first,d.second);
    d.first/=g;d.second/=g;
    A.push_back(d);
    std::sort(A.begin(),A.end(),[&](std::pair<long long,long long> x, std::pair<long long,long long> y){
        assert(x.first != 0 || x.second != 0);
        assert(y.first != 0 || y.second != 0);
        
        long long a,b;
        if(x.first>0 && x.second==0){
            a=0;
        }else if(x.first>0 && x.second>0){
            a=1;
        }else if(x.first==0 && x.second>0){
            a=2;
        }else if(x.first<0 && x.second>0){
            a=3;
        }else if(x.first<0 && x.second==0){
            a=4;
        }else if(x.first<0 && x.second<0){
            a=5;
        }else if(x.first==0 && x.second<0){
            a=6;
        }else{
            a=7;
        }
        
        if(y.first>0 && y.second==0){
            b=0;
        }else if(y.first>0 && y.second>0){
            b=1;
        }else if(y.first==0 && y.second>0){
            b=2;
        }else if(y.first<0 && y.second>0){
            b=3;
        }else if(y.first<0 && y.second==0){
            b=4;
        }else if(y.first<0 && y.second<0){
            b=5;
        }else if(y.first==0 && y.second<0){
            b=6;
        }else{
            b=7;
        }
        
        if(a!=b){
            return (a<b);
        }
        
        if(a%2==0){
            return (std::abs(x.first+x.second) < std::abs(y.first+y.second));
        }
        
        if(y.first*x.second != x.first*y.second){
           return (y.first*x.second < x.first*y.second);
        }
        
        return abs(x.first) < abs(y.first);
    });
    
    std::vector<std::pair<long long,long long>> B(N);
    for(int i=0;i<N+1;i++){
        if(A[i]==d){
            for(int j=i+1;j<N+1;j++){
                B[j-i-1]=A[j];
            }
            for(int j=0;j<i;j++){
                B[N-i+j]=A[j];
            }
            break;
        }
    }
    
    return B;
}
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>


std::vector<std::pair<long long,long long>> arg_sort(std::vector<std::pair<long long,long long>> A,std::pair<long long,long long> d = {1,0}){/*省略*/}


int main(void){
    
    long long N = 12;
    
    std::vector<std::pair<long long,long long>> A={
        {-3,0},
        {-1,-2},
        {1,2},
        {0,-3},
        {3,0},
        {-2,-1},
        {-2,1},
        {1,-2},
        {2,1},
        {2,-1},
        {0,3},
        {-1,2}
    };
    
    //Aを(1,0)を基準にソート
    A = arg_sort(A);
    for(int i=0;i<N;i++){
        std::cout << "(" << A[i].first << "," << A[i].second << ")" << " "; 
    }
    std::cout << std::endl;
    
    //Aを(-1,1)を基準にソート
    A = arg_sort(A,{-1,1});
    for(int i=0;i<N;i++){
        std::cout << "(" << A[i].first << "," << A[i].second << ")" << " "; 
    }
    std::cout << std::endl;
    
    return 0;
}

```

### 出力
```
(3,0) (2,1) (1,2) (0,3) (-1,2) (-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) 
(-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) (3,0) (2,1) (1,2) (0,3) (-1,2) 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/11/01 | バグを修正 |
| 2021/10/31 | 偏角ソートを追加 |

<div style="page-break-after: always;"></div>

# 🔴 反復写像 🔴

init
- 数列$$F$$を与えると、すべての整数 $$x (0 \leq x < \vert F \vert)$$ について $$f(x) = F[x]$$ となるように関数 $$f$$ を設定する 
- 計算量は$$N=\vert F \vert$$とし、$$Ο(N)$$

iterated_function
- コンストラクタ。initを呼ぶ

solve
- 整数 $$x$$ であって$$0 \leq x < N$$ を満たすようなものと非負整数 $$ k $$ を与えると、$$\overbrace{f(f(\cdots f}^{k}(x)))$$ を求め、返す
- もし$$k = 0$$なら$$x$$そのものを返す
- 範囲外なら$$-1$$を返す
- 計算量は$$Ο(N \log k)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/iterated%20function.cpp)

```cpp
class iterated_function{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> T[64];
    int N;
    
    public:
    void init(std::vector<int> F){
        N = F.size();
        T[0] = F;
        for(int j=1;j<64;j++){
            T[j].resize(N);
            for(int i=0;i<N;i++){
                T[j][i] = T[j-1][T[j-1][i]];
            }
        }
        
    }

    iterated_function(std::vector<int> F){
        init(F);
    }

    int solve(int x,long long k){
        if(!(0<=x && x<N) || k<0){
            return -1;
        }

        int y = x;
        for(int i=0;(k>>i)>0;i++){
            if((k>>i)%2==1){
                y = T[i][y];
            }
        }

        return y;
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class iterated_function{/*省略*/};

int main() {
    
    std::vector<int> F = {1,2,3,4,5,2};
    iterated_function func(F);

    std::cout << "0からk回辿ったときの頂点" << std::endl;
    for(int k=0;k<=15;k++){
        std::cout << func.solve(0,k) << " ";
    }
    std::cout << std::endl << std::endl;

    std::cout << "各頂点から3回辿ったときの頂点" << std::endl;
    for(int i=0;i<6;i++){
        std::cout << func.solve(i,3) << " ";
    }
    std::cout << std::endl;
    
}
```

### 出力
```
0からk回辿ったときの頂点
0 1 2 3 4 5 2 3 4 5 2 3 4 5 2 3 

各頂点から3回辿ったときの頂点
3 4 5 2 3 4 
```

## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2022/07/03 | 反復写像を追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d) | [提出](https://atcoder.jp/contests/abc167/submissions/32945330) |

<div style="page-break-after: always;"></div>

# 🔴 スライド最小値 🔴

数列$$A$$と整数$$K$$を与えると、以下の数式を満たす要素数が$$\vert A \vert -K+1$$の数列$$R$$を構成し、返す

$$R_i = min(A_i , A_{i+1} , ... , A_{i+K-1})$$


計算量は$$O(\vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/slide%20minimum.cpp)

```cpp
std::vector<long long> slide_minimum(std::vector<long long> A,int K){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    int N = A.size();
    std::deque<int> D;
    for(int i=0;i<N;i++){
        while(!D.empty() && A[D.back()]>=A[i]){D.pop_back();}
        D.push_back(i);
        if(i-K+1>=0){
            R.push_back(A[D.front()]);
            if(D.front()==i-K+1){
                D.pop_front();
            }
        }
    }
    return R;
}
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<long long> slide_minimum(std::vector<long long> A,int K){/*省略*/}

int main(void){
    
    std::vector<long long> A = {3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3},B;
    long long K = 3;
    
    B = slide_minimum(A,K);
    for(int i=0;i<B.size();i++){
        std::cout << B[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
1 1 1 1 2 2 2 3 3 3 5 7 7 3 2 2 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例を追加 |
| 2020/04/23 | スライド最小値を追加 |


<div style="page-break-after: always;"></div>

# 🔴 座標圧縮 🔴

init
- 数列$$A$$を与えると、クラスを$$A$$で初期化する
- このとき、$$A$$の全ての$$2$$つの要素について大小関係が維持され、かつindexの最大値が最小になるように$$A$$の各要素にindexという非負整数が割り振られる
- 計算量は$$N=\vert A \vert$$とし、$$Ο(NlogN)$$

compress
- コンストラクタ。initを呼ぶ

size
- initで与えられた数列の中に含まれる値の種類数を返す
- 計算量は$$Ο(1)$$

index
- 値を与えると、その値に対応するindexを返す
- もし数列に存在しない値が与えられたら、数列に存在する値の中で、与えられた値より小さい最大の値についてのindexを返す(つまり、小さい値に寄せる)
- もし列のいかなる値よりも小さければ$$-1$$を返す
- 計算量はinitの$$N$$を用いて、$$Ο(logN)$$

value
- indexを与えると値を返す
- 範囲外なら$$0$$を返す
- 計算量は$$Ο(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/coordinate%20compression.cpp)

```cpp
class compress{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> E;
    
    public:
    void init(std::vector<long long> A){
        E.clear();
        sort(A.begin(),A.end());
        for(int i=0;i<A.size();i++){
            if(i==0 || A[i]!=A[i-1]){
                E.push_back(A[i]);
            }
        }
    }
    
    compress(std::vector<long long> A){
        init(A);
    }
    
    int size(){
        return (int)E.size();
    }
    
    int value(int x){
        if(0<=x && x<(int)E.size()){
            return E[x];
        }else{
            return 0;
        }
    }
    
    int index(int X){
        return (upper_bound(E.begin(),E.end(),X))-E.begin()-1;
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class compress{/*省略*/};

int main(void){
    
    std::vector<long long> A={1,2,4,8,16,32,64,128};
    compress zaatsu(A);
    
    std::cout << "uniqueな要素の個数" << std::endl;
    std::cout << zaatsu.size() << std::endl;
    std::cout << std::endl;
    
    std::cout << "Aの各要素に対応する数" << std::endl;
    for(int i=0;i<A.size();i++){
        std::cout << zaatsu.index(A[i]) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "0~7に対応する要素" << std::endl;
    for(int i=0;i<zaatsu.size();i++){
        std::cout << zaatsu.value(i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
uniqueな要素の個数
8

Aの各要素に対応する数
0 1 2 3 4 5 6 7 

0~7に対応する要素
1 2 4 8 16 32 64 128 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例、コンストラクタを追加 |
| 2020/05/20 | mapで処理しvectorで返す形式から、class化し二分探索を行う形式に変更 |
| 2020/04/05 | 座標圧縮を追加 |

<div style="page-break-after: always;"></div>

# 🔴 最長増加部分列 🔴

数列$$A$$を与えると、$$A$$の最長増加部分列の長さを求め、long longで返す


計算量は$$Ο(\vert A \vert log \vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/longest%20increasing%20subsequence.cpp)

```cpp
long long LIS(std::vector<long long> A){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int N=A.size();
    std::vector<long long> D;
    for(int i=0;i<N;i++){
        int pos=distance(D.begin(),lower_bound(D.begin(), D.end(),A[i]));
        if(pos==D.size()){
            D.push_back(A[i]);
        }else{
            D[pos]=A[i];
        }
    }
    return D.size();
}
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

long long LIS(std::vector<long long> A){/*省略*/}

int main(void){
    
    std::vector<long long> A={1,4,2,5,3},B={5,3,1,4,2};
    std::cout << LIS(A) << std::endl;
    std::cout << LIS(B) << std::endl;
    
    return 0;
}
```

### 出力
```
3
2
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例を追加 |
| 2020/04/05 | 最長増加部分列を追加 |

<div style="page-break-after: always;"></div>

# 🔴 Moのアルゴリズム 🔴

すもももももももものうち

いくつかの半開区間 $$[l_i,r_i)$$ についての答えを高速に求める
$$[l,r)$$ での答えがわかっているとき、隣接する区間 $$[l-1,r),[l+1,r),[l,r-1),[l,r+1)$$ についての答えが高速にわかる場合に有効

第一引数に区間全体の長さ $$N$$ 、第二引数にクエリの数 $$Q$$ 、第三引数にクエリのリスト、そして第四～第七引数にはそれぞれ
- $$[l,r)$$ の答えから $$[l-1,r)$$ の答えを求める関数
- $$[l,r)$$ の答えから $$[l+1,r)$$ の答えを求める関数
- $$[l,r)$$ の答えから $$[l,r-1)$$ の答えを求める関数
- $$[l,r)$$ の答えから $$[l,r+1)$$ の答えを求める関数

を与えると、各クエリに対しての答えをvectorで返す

計算量は第四～第七引数で与えた関数の計算量を $$f$$ とすると $$Ο(Q \log Q + N \sqrt{Q} f)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/mos-algorithm.cpp)

```cpp
std::vector<long long> Mo(int N,int Q,std::vector<std::pair<int,int>> X, 
std::function<void(int,long long&)> lm, std::function<void(int,long long&)> lp, 
std::function<void(int,long long&)> rm, std::function<void(int,long long&)> rp){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int rQ;
    std::map<std::pair<int,int>,std::vector<int>> index;
    std::vector<int> block(N,0);
    std::vector<long long> Ans(Q);

    std::function<bool(std::pair<int,int>, std::pair<int,int>)> comp = [&](std::pair<int,int> A,std::pair<int,int> B){
        if(block[A.first]!=block[B.first]){
            return (block[A.first]<block[B.first]);
        }
        if(A.second != B.second){
            return (A.second < B.second);
        }
        return (A.first < B.first);
    };

    for(int i=0;i<Q;i++){
        index[X[i]].push_back(i+1);
    }
    int q = index.size();

    rQ = 1;
    while((rQ+1)*(rQ+1)<=q)rQ++;

    int now = 0;
    for(int i=0;i<rQ-1;i++){
        now += ((N+rQ-1-i)/rQ);
        block[now]++;
    }
    for(int i=0;i<N-1;i++){
        block[i+1] += block[i];
    }

    std::vector<std::pair<int,int>> Y(q);
    now = 0;
    for(auto e:index){
        Y[now] = e.first;
        now++;
    }

    std::sort(Y.begin(),Y.end(),[&](auto a, auto b){return comp(a, b);});

    int L = 0,R = 0;
    long long Result = 0;

    for(int i=0;i<q;i++){
        
        while(Y[i].first < L){
            lm(L,Result);
            L--;
        }
        while(R < Y[i].second){
            rp(R,Result);
            R++;
        }
        while(L < Y[i].first){
            lp(L,Result);
            L++;
        }
        while(Y[i].second < R){
            rm(R,Result);
            R--;
        }

        for(int k:index[Y[i]]){
            Ans[k-1] = Result;
        }

    }

    return Ans;

    //lm(i): [i,r)を[i-1,r)にする
    //lp(i): [i,r)を[i+1,r)にする
    //rm(i): [i,r)を[i,r-1)にする
    //rp(i): [i,r)を[i,r+1)にする

}
```


## 使用例
***

<br>
$$A = (1,2,3,4,5)$$ の $$[l,r)$$ の和を求める

これは $$[l,r)$$ の和がわかっていれば $$[l-1,r),[l+1,r),[l,r-1),[l,r+1)$$ の和が $$O(1)$$ でわかる\\
例えば $$[1,3)$$ の和が $$A_1 + A_2 = 2 + 3 = 5$$ であることがわかっていれば $$[1,4)$$ の和は $$5 + A_3 = 5 + 4 = 9$$ であることがわかる


### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<long long> Mo(int N,int Q,std::vector<std::pair<int,int>> X, 
std::function<void(int,long long&)> lm, std::function<void(int,long long&)> lp, 
std::function<void(int,long long&)> rm, std::function<void(int,long long&)> rp){/*省略*/}

int main(void){
    
    int N = 5, Q = 15;
    std::vector<long long> A = {1,2,3,4,5};
    std::vector<std::pair<int,int>> LR = {
        {0,1},
        {0,2},
        {0,3},
        {0,4},
        {0,5},
        {1,2},
        {1,3},
        {1,4},
        {1,5},
        {2,3},
        {2,4},
        {2,5},
        {3,4},
        {3,5},
        {4,5},
    };
    
    std::function<void(int,long long&)> lm = [&](int i,long long& res){
        res += A[i-1];
    };

    std::function<void(int,long long&)> lp = [&](int i,long long& res){
        res -= A[i];
    };

    std::function<void(int,long long&)> rm = [&](int i,long long& res){
        res -= A[i-1];
    };

    std::function<void(int,long long&)> rp = [&](int i,long long& res){
        res += A[i];
    };


    std::vector<long long> Ans = Mo(N,Q,LR,lm,lp,rm,rp);

    for(int i=0;i<(int)Ans.size();i++){
        std::cout << "[" << LR[i].first << "," << LR[i].second << ")  " << Ans[i] << std::endl;
    }

    return 0;
}
```

### 出力
```
[0,1)  1
[0,2)  3
[0,3)  6
[0,4)  10
[0,5)  15
[1,2)  2
[1,3)  5
[1,4)  9
[1,5)  14
[2,3)  3
[2,4)  7
[2,5)  12
[3,4)  4
[3,5)  9
[4,5)  5

```

## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2023/03/13 | Moのアルゴリズムを追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [ABC293-G](https://atcoder.jp/contests/abc293/tasks/abc293_g) | [提出](https://atcoder.jp/contests/abc293/submissions/39690323) |

<div style="page-break-after: always;"></div>

# 🔴 ローリングハッシュ 🔴

MOD $$2^{61}-1$$と$$2$$基底を採用しています　[例の記事](https://trap.jp/post/900/)はいったい･･･<br>
基底はコード中のBaseを直にいじれば変更できます ここサポートした方がいいのかな？


init
- ~~文字列~~ long longのvector $$S$$ を与えると、前計算として$$S$$をハッシュする他、getの計算で使用する数値を計算する
- 計算量は基底の数を$$b$$として、$$Ο(b\vert S \vert)$$

rollinghash
- コンストラクタ。initを呼ぶ

get
- 半開区間$$[l,r)$$を与えると、$$S$$の$$[l,r)$$文字目のハッシュ値を返す
- 計算量は基底の数を$$b$$として、$$Ο(b)$$

instant
- ~~文字列~~ long longのvector $$P$$を与えると、initに与えた$$S$$とは関係なく$$P$$のハッシュ値を計算し返す
- ただ返すだけで、initで揃えた情報を変更することはない
- 計算量は基底の数を$$b$$として、$$Ο(b\vert P \vert)$$

connect
- ~~文字列~~ long longのvector $$P,Q$$ のハッシュ結果と列の長さを与えると、initに与えた$$S$$とは関係なく$$P,Q$$の結合vector$$P+Q$$のハッシュ値を計算し返す
- ただ返すだけで、initで揃えた情報を変更することはない
- 計算量は基底の数を$$b$$、$$P$$の長さを$$p$$として、$$Ο(b \log{p})$$


[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/rollinghash.cpp)

```cpp
class rollinghash{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    static constexpr long long mod = (1LL << 61)-1;
    std::vector<long long> Base = {12345,10000000};
    std::vector<long long> BaseInv;
    std::vector<std::vector<long long>> BaseInvExp;
    static constexpr long long h = 100;
    
    long long product(long long a,long long b){
        static constexpr long long m = 1LL << 31;
        long long a1 = a/m,a2 = a%m;
        long long b1 = b/m,b2 = b%m;
        
        long long r = 0 , s;
        r = (r + 2*a1*b1) % mod;
        s = (a1*b2 + b1*a2) % mod;
        long long s1 = s/m,s2 = s%m;
        s = (2*s1+m*s2) % mod;
        r = (r + s) % mod;
        r = (r + a2*b2) % mod;
        
        return r;
    }
    
    long long power(long long b,long long e){
        long long r=1;
        while(e){
            if(e&1){
                r=product(r,b)%mod;
            }
                b=product(b,b)%mod;
                e >>=1;
        }
        return r;
    }
    
    public:
    std::vector<long long> S;
    std::vector<std::vector<long long>> H,Hsum;
    
    void init(std::vector<long long> cs){
        S=cs;
        int n=S.size();
        
        BaseInv.resize(Base.size());
        BaseInvExp.resize(Base.size());
        H.resize(Base.size());
        Hsum.resize(Base.size());
        for(int i=0;i<(int)Base.size();i++){
            BaseInvExp[i].assign(n+1,1);
            H[i].assign(n+1,0);
            Hsum[i].assign(n+1,0);
        }
        
        //逆元
        for(int i=0;i<(int)Base.size();i++){
            BaseInv[i]=power(Base[i],mod-2);
        }
        for(int i=0;i<(int)Base.size();i++){
            for(int j=0;j<n;j++){
                BaseInvExp[i][j+1] = product(BaseInvExp[i][j],BaseInv[i]);
            }
        }
        
        //本体
        for(int i=0;i<(int)Base.size();i++){
            long long b=1;
            for(int j=0;j<n;j++){
                H[i][j]=product(b,S[j]+h);
                b=product(b,Base[i]);
            }
        }
        
        //累積和
        for(int i=0;i<(int)Base.size();i++){
            for(int j=0;j<n;j++){
                Hsum[i][j+1]=(Hsum[i][j]+H[i][j])%mod;
            }
        }
    }
    
    rollinghash(std::vector<long long> C){
        init(C);
    }
    
    std::vector<long long> get(int l,int r){
        std::vector<long long> R(Base.size());
        for(int i=0;i<(int)Base.size();i++){
            long long g = (Hsum[i][r]-Hsum[i][l]+mod)%mod;
            g=product(g,BaseInvExp[i][l]);
            R[i] = g;
        }
        return R;
    }
    
    std::vector<long long> instant(std::vector<long long> P){
        std::vector<long long> R;
        for(int i=0;i<(int)Base.size();i++){
            long long r = 0, b = 1;
            for(int j=0;j<(int)P.size();j++){
                r = (r+product(b,P[j]+h))%mod;
                b = product(b,Base[i]);
            }
            R.push_back(r);
        }
        return R;
    }
    
    std::vector<long long> connect(std::vector<long long> P,long long ps,std::vector<long long> Q,long long qs){
        std::vector<long long> R;
        for(int i=0;i<(int)Base.size();i++){
            long long r = (product(Q[i],power(Base[i],ps))+P[i])%mod;
            R.push_back(r);
        }
        return R;
        assert(qs==qs);
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class rollinghash{/*省略*/};

int main() {
    
    rollinghash rolihash({'a','b','c','a','b'});
    
    std::cout << "\"abcab\"の[0,2)文字目、つまり\"ab\"のハッシュ値" << std::endl;
    std::vector<long long> a = rolihash.get(0,2);
    for(int i=0;i<a.size();i++){
        std::cout << a[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"abcab\"の[1,4)文字目、つまり\"bca\"のハッシュ値" << std::endl;
    std::vector<long long> b = rolihash.get(1,4);
    for(int i=0;i<b.size();i++){
        std::cout << b[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"abcab\"の[3,5)文字目、つまり\"ab\"のハッシュ値" << std::endl;
    std::vector<long long> c = rolihash.get(3,5);
    for(int i=0;i<c.size();i++){
        std::cout << c[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"bc\"のハッシュ値" << std::endl;
    std::vector<long long> d = rolihash.instant({'b','c'});
    for(int i=0;i<d.size();i++){
        std::cout << d[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"a\"のハッシュ値" << std::endl;
    std::vector<long long> e = rolihash.instant({'a'});
    for(int i=0;i<e.size();i++){
        std::cout << e[i] << " ";
    }
    std::cout << std::endl << std::endl;

    std::cout << "\"bc\"と\"a\"の結合、つまり\"bca\"のハッシュ値" << std::endl;
    std::vector<long long> f = rolihash.connect(d,2,e,1);
    for(int i=0;i<f.size();i++){
        std::cout << f[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    return 0;
}
```

### 出力
```
"abcab"の[0,2)文字目、つまり"ab"のハッシュ値
2444507 1980000197 

"abcab"の[1,4)文字目、つまり"bca"のハッシュ値
30025064778 19700001990000198 

"abcab"の[3,5)文字目、つまり"ab"のハッシュ値
2444507 1980000197 

"bc"のハッシュ値
2456853 1990000198 

"a"のハッシュ値
197 197 

"bc"と"a"の結合、つまり"bca"のハッシュ値
30025064778 19700001990000198 
```

## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2023/03/25 | connectを追加 |
| 2023/03/25 | ハッシュ対象をstringからvector<long long>に変更 |
| 2022/06/26 | constexprによる最適化を実行 |
| 2021/08/31 | instantを追加 |
| 2021/04/01 | ローリングハッシュを追加 |

## 確認した問題

| 問題 | 提出 |
| :---: | :--- |
| [ABC141-E](https://atcoder.jp/contests/abc141/tasks/abc141_e) | [提出](https://atcoder.jp/contests/abc141/submissions/39997036) |

<div style="page-break-after: always;"></div>

# 🔴 ダイクストラ法 🔴

init
- 無向グラフを、頂点数$$N$$と、辺の始点と終点とコストを表現したpair<pair<int,int>,long long>のvectorとして与える。
- すると、グラフをsolve()が扱えるようになる
- 多始点などで何回も回す場合、initの実行は$$1$$回でよい
- 計算量は$$Ο(\vert E \vert)$$

Dijkstra
- コンストラクタ。initを呼ぶ

solve
- initでできたグラフに対し、与えられた$$s$$を始点としてダイクストラ法を実行する
- 得られた最小コストを要素数が$$V$$のvectorとして返す
- 計算量は$$Ο((E+V)logV)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/Dijkstra.cpp)

```cpp
class Dijkstra{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    typedef std::pair<long long,int> P;
    std::vector<std::vector<P>> G;
    int V;
    long long INF = (1LL<<61);
    std::priority_queue<P,std::vector<P>,std::greater<P>> que;
    
    public:
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        //頂点数を決定する
        V=N;
        
        //辺集合を扱いやすい形式に変換する
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({cost,to});
        }
    }
    
    Dijkstra(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }

    std::vector<long long> solve(int s){
        std::vector<long long> d;
        //INFで初期化する
        for(int i=0;i<V;i++){
            d.push_back(INF);
        }
        d[s]=0;
        que.push({0,s});
        //queは{cost,to}をコストが小さい順に出す
        while(!que.empty()){
            P p = que.top();
            que.pop();
            int v=p.second;
            if(d[v]<p.first)continue;
            for(int i=0;i<G[v].size();i++){
                P e = G[v][i];
                if(d[e.second]>d[v]+e.first){
                    d[e.second] = d[v]+e.first;
                    que.push({d[e.second],e.second});
                }
            }
        }
        return d;
    }
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class Dijkstra{/*省略*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Dijkstra dijkstra(N,E);
    std::vector<long long> D = dijkstra.solve(0);
    
    for(int i=0;i<N;i++){
        std::cout << D[i] << " ";
    }
    std::cout << std::endl;
    
    std::vector<long long> F = dijkstra.solve(1);
    
    for(int i=0;i<N;i++){
        std::cout << F[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
0 1 3 7 11 
2305843009213693952 0 2 6 10 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例、コンストラクタを追加/コメントを削除 |
| 2021/02/12 | バグを修正/いくつかの表記変更 |
| 2020/04/04 | ダイクストラ法を追加 |

<div style="page-break-after: always;"></div>

# 🔴 ベルマンフォード法 🔴

init
- 無向グラフを、辺の始点と終点とコストを表現したpair<pair<int,int>,long long>のvectorとして与える。
- すると、グラフをsolve()が扱えるようになる
- 多始点などで何回も回す場合、initの実行は$$1$$回でよい
- 計算量は$$Ο(max(E,V))$$

BellmanFord
- コンストラクタ。initを呼ぶ

solve
- initでできたグラフに対し、与えられた$$s$$を始点としてベルマンフォード法を実行する
- 得られた最小コストを要素数が$$V$$のvectorとして返す
- vectorの要素はpair<long long,bool>である　firstは最小コストを表しており、secondがtrueの場合最小コストが存在せずfirstの値は適当
- 計算量は$$Ο(VE)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/BellmanFord.cpp)

```cpp
class BellmanFord{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    typedef std::pair<std::pair<int,int>,long long> P;
    int V,E;
    long long INF = (1LL<<61);
    std::vector<std::pair<std::pair<int,int>,long long>> es;
    
    public:
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        //辺数をもとめる　
        E=edge.size();
        //頂点数を決定する
        V=N;
        es=edge;
    }
    
    BellmanFord(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }

    std::vector<std::pair<long long,bool>> solve(int s){
        std::vector<std::pair<long long,bool>> d;
        //INFで初期化する
        for(int i=0;i<V;i++){
            d.push_back({INF,false});
        }
        d[s].first=0;
        for(int j=0;j<2*V;j++){
             bool update=false;
            for(int i=0;i<E;i++){
                P k=es[i];
                if(d[k.first.first].first!=INF && d[k.first.second].first>d[k.first.first].first+k.second){
                    d[k.first.second].first=d[k.first.first].first+k.second;
                    if(j>=V){
                        d[k.first.second].second=true;
                    }
                    update=true;
                }
            }
            if(!update)break;
        }
        return d;
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class BellmanFord{/*省略*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    BellmanFord bellmanford(N,E);
    std::vector<std::pair<long long,bool>> B = bellmanford.solve(0);
    
    for(int i=0;i<N;i++){
        if(B[i].second==true){
            std::cout << "-INF" << " ";
        }else{
            std::cout << B[i].first << " ";
        }
    }
    std::cout << std::endl;
    
    std::vector<std::pair<long long,bool>> C = bellmanford.solve(1);
    
    for(int i=0;i<N;i++){
        if(C[i].second==true){
            std::cout << "-INF" << " ";
        }else{
            std::cout << C[i].first << " ";
        }
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
0 1 3 7 11 
2305843009213693952 0 2 6 10 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例、コンストラクタを追加 |
| 2021/03/25 | バグを修正/コメントを削除 |
| 2020/04/04 | ベルマンフォード法を追加 |

<div style="page-break-after: always;"></div>

# 🔴 クラスカル法 🔴

無向グラフを、辺の始点と終点とコストを表現したpair<pair<int,int>,long long>のvectorとして与える。

すると、コストの和が最小になるような全域木を一つ構成し、その木を構成する辺をvectorとして返す

辺がつなぐ$$2$$頂点が連結かどうかを[UnionFind](./unionfind)を用いて判定している

計算量は$$Ο(ElogE)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/Kruskal.cpp)

```cpp
class Kruskal{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int V=0,E=0;
    typedef std::pair<std::pair<int,int>,long long> P;
    std::vector<int> UF,rank;
    std::vector<std::pair<std::pair<int,int>,long long>> es;
    
    bool comp(P F,P G){
        return F.second<G.second;
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]<rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
    }
    
    public:
    
    std::vector<P> solve(std::vector<P> edge){
        //頂点数を決定する
        V=0;
        for(int i=0;i<edge.size();i++){
            V=std::max(V,edge[i].first.first+1);
            V=std::max(V,edge[i].first.second+1);
        }
        //辺数をもとめる　
        E=edge.size();
        //unionfindを初期化する
        UF.clear();
        rank.clear();
        for(int i=0;i<V;i++){
            UF.push_back(i);
            rank.push_back(0);
        }
        //辺をソートして代入しておく
        std::sort(edge.begin(),edge.end(),[&](P x, P y){return comp(x, y);});
        es=edge;
        
        std::vector<P> R;
        for(int i=0;i<E;i++){
            if(!same(es[i].first.first,es[i].first.second)){
                unite(es[i].first.first,es[i].first.second);
                R.push_back(es[i]);
            }
        }
        return R;
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class Kruskal{/*省略*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Kruskal kruskal;
    std::vector<std::pair<std::pair<int,int>,long long>> K = kruskal.solve(E);
    
    for(int i=0;i<K.size();i++){
        std::cout << K[i].first.first << " " << K[i].first.second;
        std::cout << "  " << K[i].second << std::endl;
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
0 1  1
1 2  2
2 3  4
2 4  8
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/25 | 使用例を追加 |
| 2021/03/25 | コメントを削除 |
| 2020/04/05 | クラスカル法を追加 |

<div style="page-break-after: always;"></div>

# 🔴 二部グラフ判定 🔴

無向グラフを、辺の始点と終点を表現したpair<int,int>のvectorとして与える。<br>
すると、sizeが$$max(点の番号)+1$$のvectorが返ってくる。すべての要素は$$0$$または$$1$$である。<br>
これは、与えられたグラフを二部グラフとして表現するとき$$i$$番目の要素は$$0$$と$$1$$どちらに属するかを表している。<br>
また二部グラフでないとき全ての要素は$$0$$である。<br>
計算量は$$Ο(V+E)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/bipartite%20graph.cpp)

```cpp
std::vector<int> bipartite(std::vector<std::pair<int,int>> edge){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int E = edge.size();
    if(E==0)return {};
    int V = 0;
    for(int i=0;i<E;i++){
        V=std::max(V,edge[i].first+1);
        V=std::max(V,edge[i].second+1);
    }
    std::vector<int> R(V,-1);
    std::vector<int> S(V,0);
    std::vector<std::vector<int>> es(V,std::vector<int>(0));
    for(int i=0;i<E;i++){
        es[edge[i].first].push_back(edge[i].second);
        es[edge[i].second].push_back(edge[i].first);
    }
    std::queue<int> Q;
    std::vector<bool> visited(V,false);
    for(int j=0;j<V;j++){
        if(visited[j])continue;
        Q.push(j);
        R[j]=0;
        visited[j]=true;
        while(!Q.empty()){
            int q=Q.front();
            Q.pop();
            visited[q]=true;
            for(int i=0;i<es[q].size();i++){
                if(R[es[q][i]]==R[q]){
                    return S;
                }
                if(visited[es[q][i]])continue;
                Q.push(es[q][i]);
                R[es[q][i]]=1-R[q];
            }
        }
    }
    return R;
}
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

std::vector<int> bipartite(std::vector<std::pair<int,int>> edge){/*省略*/}

int main(void){
    
    std::vector<std::pair<int,int>> E,F;
    
    E.push_back({0,1});
    E.push_back({1,2});
    E.push_back({2,3});
    E.push_back({3,0});
    E.push_back({0,4});
    
    F.push_back({0,1});
    F.push_back({1,2});
    F.push_back({2,3});
    F.push_back({2,4});
    F.push_back({3,4});
    
    std::vector<int> Es = bipartite(E), Fs = bipartite(F);
    
    for(int i=0;i<Es.size();i++){
        std::cout << Es[i] << " ";
    }
    std::cout << std::endl;
    
    for(int i=0;i<Fs.size();i++){
        std::cout << Fs[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
0 1 0 1 1 
0 0 0 0 0 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例を追加 |
| 2021/03/26 | バグを修正/計算量表記を修正 |
| 2020/04/02 | 二部グラフ判定を追加 |

<div style="page-break-after: always;"></div>

# 🔴 木の直径 🔴

木ではない一般的なグラフでも近似解が出るらしいけどチェックしてません(え？)

init
- 整数$$N$$と頂点数$$N$$の重み付き木を0-indexedのvector<pair<pair<int,int>,long long>>で与えると前計算をし、木の直径が計算できるようになる
- 計算量は$$Ο(N)$$

double_sweep
- コンストラクタ。initを呼ぶ

vertex
- 最も距離が大きくなるような頂点対$$(u,v)$$を一つ返す
- 計算量は$$Ο(1)$$

pass
- $$u$$と$$v$$の間のパスを返す
- このときvectorの先頭が$$u$$、最後尾が$$v$$になる
- 計算量はパスの長さを$$P$$として、$$Ο(P)$$

diameter
- $$u$$と$$v$$の間のパスの重さを出力する
- 計算量はパスの長さを$$P$$として、$$Ο(P)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/double%20sweep.cpp)

```cpp
class double_sweep{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const long long INF = (1LL<<61);
    int V,V1,V2;
    std::vector<std::vector<std::pair<int,long long>>> G;
    std::vector<int> parent;
    std::vector<long long> parent_cost;
    long long diam;
    long long temp;
    
    void dfs(int phase,int v,int p,long long d){
        if(phase==1){
            if(d>temp){
                V1 = v;
                temp = d;
            }
        }
        if(phase==2){
            parent[v] = p;
            if(d>temp){
                V2 = v;
                temp = d;
            }
        }
        for(std::pair<int,long long> E:G[v]){
            int e = E.first;
            long long f = E.second;
            if(e!=p){
                dfs(phase,e,v,d+f);
                if(phase==2){
                    parent_cost[e] = f;
                }
            }
        }
    }
    
    public:
    
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        V = N;
        V1 = 0,V2 = 0;
        
        G.clear();
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({to,cost});
            G[to].push_back({from,cost});
        }
        
        parent.resize(V);
        for(int i=0;i<V;i++){
            parent[i] = -1;
        }
        parent_cost.resize(V);
        for(int i=0;i<V;i++){
            parent_cost[i] = -1;
        }
        
        temp = -INF;
        dfs(1,0,-1,0);
        temp = -INF;
        dfs(2,V1,-1,0);
        diam = -1;
    }
    
    double_sweep(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }
    
    std::pair<int,int> vertex(void){
        return std::make_pair(V2,V1);
    }
    
    std::vector<int> pass(void){
        std::vector<int> R;
        diam = 0;
        int r = V2;
        while(r!=V1){
            R.push_back(r);
            diam += parent_cost[r];
            r = parent[r];
        }
        R.push_back(r);
        return R;
    }
    
    long long diameter(void){
        if(diam==-1){
            pass();
        }
        return diam;
    }
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class double_sweep{/*省略*/};

int main(void){
    
    int N = 8;
    std::vector<std::pair<std::pair<int,int>,long long>> edge;
    
    edge.push_back({ {0,1},1});
    edge.push_back({ {0,2},2});
    edge.push_back({ {0,3},4});
    edge.push_back({ {1,4},8});
    edge.push_back({ {1,5},16});
    edge.push_back({ {5,6},32});
    edge.push_back({ {5,7},64});
    
    double_sweep DS(N,edge);
    
    
    //直径の端の頂点は6と7
    std::pair<int,int> V = DS.vertex();
    std::cout << V.first << " " << V.second << std::endl;
    
    //そのパスは6-5-7
    std::vector<int> P = DS.pass();
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl;
    
    //重さの和は96
    long long D = DS.diameter();
    std::cout << D << std::endl;
    
    
    return 0;
}
```

### 出力
```
6 7
6 5 7 
96
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2020/10/15 | 木の直径を追加 |

<div style="page-break-after: always;"></div>

# 🔴 最小共通祖先 🔴

init
- 整数$$r$$と頂点数$$N$$の木を0-indexedのvector<pair<int,int>>で与えると前計算をし、$$r$$を根とする木のLCAが計算できるようになる
- 計算量は$$Ο(N \log N)$$

lowest_common_ancestor
- コンストラクタ。initを呼ぶ

climb
- $$u$$と$$k$$を与えると、頂点$$u$$から$$k$$個遡った頂点の番号を返す
- もし根を超えてしまった場合は$$-1$$を返す
- 計算量は$$Ο(\log k)$$

lca
- $$u$$と$$v$$を与えると頂点$$u$$と$$v$$のLCA(最小共通祖先)を返す
- 計算量は木の頂点数$$N$$を用いて、$$Ο(\log N)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/lowest%20common%20ancestor.cpp)

```cpp
class lowest_common_ancestor{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int V,LOG;
    std::vector<std::vector<long long>> G,table;
    std::vector<long long> depth;
    
    void dfs(long long v,long long p,long long d){
        depth[v] = d;
        table[v][0] = p;
        for(long long e:G[v]){
            if(e!=p){
                dfs(e,v,d+1);
            }
        }
    }
    
    public:
    void init(long long root,std::vector<std::pair<long long,long long>> edge){
        V = 1+edge.size();
        LOG = 1;
        while((1<<LOG)<V)LOG++;

        G.clear();
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            G[edge[i].first].push_back(edge[i].second);
            G[edge[i].second].push_back(edge[i].first);
        }
        
        table.resize(V);
        for(int i=0;i<V;i++){
            table[i].resize(LOG);
        }
        depth.resize(V);
        dfs(root,-1,0);
        
        for(int j=0;j<LOG-1;j++){
            for(int i=0;i<V;i++){
                if(table[i][j]==-1){
                    table[i][j+1] = -1;
                }else{
                    table[i][j+1] = table[table[i][j]][j];
                }
                
            }
        }
        
    }
    
    lowest_common_ancestor(long long root,std::vector<std::pair<long long,long long>> edge){
        init(root,edge);
    }
    
    
    long long climb(long long u,long long k = 1){
        for(int i=0;k>0;k>>=1,i++){
            if(u==-1)return -1;
            if(k&1)u = table[u][i];
        }
        return u;
    }
    
    long long lca(long long u,long long v){
        if(depth[u]>depth[v])std::swap(u,v);
        v = climb(v,depth[v]-depth[u]);
        if(u==v)return u;
        
        for(int i=LOG-1;i>=0;i--){
            if(table[u][i]!=table[v][i]){
                u = table[u][i];
                v = table[v][i];
            }
        }
        return table[u][0];
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class lowest_common_ancestor{/*省略*/};

int main(void){
    
    int N = 8;
    
    std::vector<std::pair<long long,long long>> edge;
    
    edge.push_back({0,1});
    edge.push_back({0,2});
    edge.push_back({0,3});
    edge.push_back({1,4});
    edge.push_back({1,5});
    edge.push_back({5,6});
    edge.push_back({5,7});
    
    //0を根として前計算する
    lowest_common_ancestor LCA(0,edge);
    
    //頂点6から一つずつ遡ったら6→5→1→0になり、それを超えると-1
    for(int i=0;i<5;i++){
        std::cout << LCA.climb(6,i) << " ";
    }
    std::cout << std::endl;
    
    //頂点6と頂点7のLCAは5
    std::cout << LCA.lca(6,7) << std::endl;
    
    //頂点6と頂点1のLCAは1
    std::cout << LCA.lca(6,1) << std::endl;
    
    //頂点6と頂点3のLCAは0
    std::cout << LCA.lca(6,3) << std::endl;
    
    return 0;
}
```

### 出力
```
6 5 1 0 -1 
5
1
0
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2020/10/10 | 最小共通祖先を追加 |

<div style="page-break-after: always;"></div>

# 🔴 ディニッツ法 🔴

Dinicの読み方これでいいのかな

init
- 整数$$N$$を与えると、頂点を$$N$$個生成しフローの計算に必要なメモリを確保する
- 計算量は$$Ο(N)$$

Dinic
- コンストラクタ。initを呼ぶ

add
- 頂点$$from$$から$$end$$にかけて容量$$cap$$の有向辺を張る
- 計算量は$$O(1)$$

solve
- 頂点$$s$$を始点、頂点$$t$$を終点としてフローの最大値を求める
- 計算量はinitで与えた頂点の数を$$V$$、addで与えた辺の数を$$E$$として$$Ο(E V^2)$$
- 実際はこれよりも高速に動作する

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/dinic.cpp)

```cpp
class Dinic{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    struct edge{
        int end;
        long long cap,rev;
        
    };
    
    const long long INF = (1LL<<61);
    int V;
    std::vector<std::vector<edge>> G;
    std::vector<long long> level;
    std::vector<int> iter;
    
    void Dinic_bfs(int s){
        for(int i=0;i<V;i++){
            level[i]=-1;
        }
        std::queue<int> que;
        level[s]=0;
        que.push(s);
        while(!que.empty()){
            int v=que.front();
            que.pop();
            for(unsigned int i=0;i<G[v].size();i++){
                edge &e = G[v][i];
                if(e.cap>0 && level[e.end]<0){
                    level[e.end]=level[v]+1;
                    que.push(e.end);
                }
            }
        }
    }
    
    long long Dinic_dfs(int v,int t,long long f){
        if(v==t)return f;
        for(int &i=iter[v];i<G[v].size();i++){
            edge &e = G[v][i];
            if(e.cap>0 && level[v]<level[e.end]){
                long long d = Dinic_dfs(e.end,t,std::min(f,e.cap));
                if(d>0){
                    e.cap -= d;
                    G[e.end][e.rev].cap+=d;
                    return d;
                }
            }
        }
        return 0;
    }
    
    public:
    
    void init(int N){
        V = N;
        G.clear();
        G.resize(V);
        level.resize(V);
        iter.resize(V);
    }
    
    Dinic(int N){
        init(N);
    }
    
    void add(int from,int end,long long cap){
        G[from].push_back((edge){end,cap,(long long)G[end].size()});
        G[end].push_back((edge){from,0,(long long)G[from].size()-1});
    }
    
    long long solve(int s,int t){
        long long flow=0;
        while(1){
            Dinic_bfs(s);
            if(level[t]<0){return flow;}
            for(int i=0;i<V;i++){
                iter[i]=0;
            }
            long long f;
            while((f=Dinic_dfs(s,t,INF))>0){
                flow+=f;
            }
        }
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class Dinic{/*省略*/};


int main(void){
    
    Dinic dinitz(5);
    dinitz.add(0,1,4);
    dinitz.add(0,2,2);
    dinitz.add(1,2,1);
    dinitz.add(1,3,2);
    dinitz.add(2,3,4);
    dinitz.add(2,4,2);
    dinitz.add(3,4,4);
    
    //このグラフでは頂点0から頂点4へは最大で5つ流れる
    //例えば0->2->4に2つ、0->1->2->3->4に1つ、0->1->3->4に2つなどが考えられる
    long long R = dinitz.solve(0,4);
    std::cout << R << std::endl;
    
    return 0;
}

```

### 出力
```
5
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/11/01 | githubリンクを追加 |
| 2021/11/01 | ディニッツ法を追加 |

<div style="page-break-after: always;"></div>

# 🔴 セグメント木 🔴

単にセグ木と言えばこれを指す、最も単純なセグ木

init
- 第一引数で整数$$N$$を与えると、要素が$$N$$個入る最小サイズの完全二分木を構成し、すべての要素を単位元で初期化する
- また第二･第三引数でセグ木に乗せる演算とその単位元を与えるとその演算を乗せる
- 演算がモノイドでない場合の動作は保証しない
- 計算量は$$Ο(N)$$

segmenttree
- コンストラクタ。initを呼ぶ

update
- $$k$$番目(0-indexed)の要素を$$a$$で更新し、それが影響するノードを全て更新する
- 計算量はinitの$$N$$を用いて、$$Ο(logN)$$

query
- $$[a,b)$$の範囲内にある要素をcalcで計算した結果をlong longで返す
- 計算量は$$Ο(log(b-a))$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp)

```cpp
template<typename T>
class segmenttree{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int n;
    
    std::vector<T> dat;
    std::function<T(T,T)> calc;
    T identity;
    public:
    
    void init(int N,std::function<T(T,T)> func,T Identity){
        n=1;
        while(n<N)n*=2;
        dat.resize(2*n-1);
        for(int i=0;i<2*n-1;++i){
            dat[i]=Identity;
        }
        calc = func;
        identity = Identity;
    }
    
    segmenttree(int N,std::function<T(T,T)> func,T Identity){
        init(N,func,Identity);
    }
    
    void update(int k,T a){
        k+=n-1;
        dat[k]=a;
        while(k>0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    T query(int a,int b){
        a+=n-1;
        b+=n-1;
        T L= identity,R = identity;
        while(a < b){
            if(a % 2 == 0){
                L = calc(L,dat[a]);
                a++;
            }
            a = (a-1)/2;
            if(b % 2 == 0){
                R = calc(dat[b-1],R);
                b--;
            }
            b = (b-1)/2;
        }
        R = calc(L,R);
        return R;
    }
    
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

template<typename T>
class segmenttree{/*省略*/};

int main(void){
    
    long long N = 6;
    std::vector<long long> A = {100000,20000,3000,400,50,6};
    std::function<long long(long long,long long)> func = [](long long a,long long b){
        return a+b;
    };
    
    segmenttree<long long> segtree(N,func,0);
    for(int i=0;i<N;i++){
        segtree.update(i,A[i]);
    }
    
    std::cout << segtree.query(0,3) << std::endl;
    std::cout << segtree.query(0,6) << std::endl;
    std::cout << segtree.query(2,6) << std::endl;
    std::cout << segtree.query(3,5) << std::endl;
    std::cout << segtree.query(5,6) << std::endl;
    
    return 0;
}
```

### 出力
```
123000
123456
3456
450
6
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2022/01/30 | バグを修正 |
| 2022/01/30 | 任意の型に対応 |
| 2021/10/10 | バグを修正 |
| 2021/03/26 | 使用例、コンストラクタを追加 |
| 2020/04/06 | セグメント木を追加 |

<div style="page-break-after: always;"></div>

# 🔴 フェニック木 🔴

BIT(Binary Indexed Tree)とも

init
- 整数$$N$$を与えると、要素が$$N$$個のフェニック木を構成し、すべての要素を$$0$$で初期化する
- 計算量は$$Ο(N)$$

Fenwick_tree
- コンストラクタ。initを呼ぶ

add
- $$a$$番目(0-indexed)の要素に$$w$$を加算する
- 計算量はinitの$$N$$を用いて、$$Ο(log(N))$$


sum
- $$[0,a)$$の範囲内にある要素の和をlong longで返す
- 計算量は$$Ο(log(a))$$

inversion
- 数列$$V$$を与えると$$V$$の転倒数を計算し、long longで返す
- この際、initし直すため今までの内容をすべて削除する
- 計算量は$$Ο(\vert V \vert log \vert V \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/Fenwick%20tree.cpp)

```cpp
class Fenwick_tree{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<long long> BIT;
    
    public:
    
    void add(int a,long long w){
        for(int x=a;x<BIT.size();x|=(x+1)){
            BIT[x]+=w;
        }
    }
    
    void init(int n){
        BIT.clear();
        for(int i=0;i<n;i++){
            BIT.push_back(0);
        }
    }
    
    Fenwick_tree(int n){
        init(n);
    }
    
    long long sum(int a){
        long long r=0;
        for(int x=a-1;x>=0;x=(x&(x+1))-1){
            r+=BIT[x];
        }
        return r;
    }
    
    long long inversion(std::vector<long long> V){
        long long r=0;
        init(V.size());
        for(int i=0;i<V.size();i++){
            add(V[i],1);
            r+=i-sum(V[i]);
        }
        return r;
    }
};
```

## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class Fenwick_tree{/*省略*/};

int main(void){
    
    long long N = 6;
    std::vector<long long> A = {100000,20000,3000,400,50,6};
    
    Fenwick_tree BIT(N);
    for(int i=0;i<N;i++){
        BIT.add(i,A[i]);
    }
    
    for(int i=0;i<=N;i++){
        std::cout << BIT.sum(i) << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<long long> B = {3,1,4,2};
    std::cout << BIT.inversion(B) << std::endl;
    
    return 0;
}
```

### 出力
```
0
100000
120000
123000
123400
123450
123456

3
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例、コンストラクタを追加 |
| 2020/04/06 | フェニック木を追加 |

<div style="page-break-after: always;"></div>

# 🔴 UnionFind 🔴

DSU(disjoint set union)とも

init
- 整数$$N$$を与えると、頂点を$$N$$個生成し全てを独立にした上で全てのランクを$$0$$にする
- 計算量は$$Ο(N)$$

unionfind
- コンストラクタ。initを呼ぶ

root
- 頂点$$k$$のその時点での根を求める
- と同時に経路圧縮する
- 計算量は$$Ο(\alpha (N))$$

$$α(x)$$はアッカーマン関数$$Ack(x,x)$$の逆関数

$$Ack(4,4)=2^{2^{2^{65536}}}-3$$から伺えるように、$$\alpha (x)$$は実用上定数($$4$$)倍と見なせるほどに収束が遅い

same
- 頂点$$p$$と頂点$$q$$がその時点で同じ集合に属しているか(=根が同一か)を調べ、同じならtrue、違うならfalseを返す
- 計算量は$$Ο(\alpha (N))$$

unite
- 頂点$$p$$と頂点$$q$$が属してる集合を合併する
- すでに同じ集合に属している場合は無視する
- $$p$$の属する集合のランクが$$q$$のものと同じか大きいとき$$p$$側が根に、そうでないとき$$q$$側が根になる
- 計算量は$$Ο(\alpha (N))$$

size
- 頂点$$k$$とその時点で同じ集合に属している頂点の数を返す
- 計算量は$$Ο(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/union%20find.cpp)

```cpp
class unionfind{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> UF,rank,size_;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        size_.clear();
        for(int i=0;i<N;i++){
            UF.push_back(i);
            rank.push_back(0);
            size_.push_back(1);
        }
    }
    
    unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]<rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        size_[p] += size_[q];
        size_[q] = 0;
    }
    
    int size(int k){
        return size_[root(k)];
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class unionfind{/*省略*/};

int main(void){
    
    unionfind UF(13);
    UF.unite(1,3);
    UF.unite(1,5);
    UF.unite(1,7);
    UF.unite(1,8);
    UF.unite(1,10);
    UF.unite(1,12);
    UF.unite(4,6);
    UF.unite(4,9);
    UF.unite(4,11);
    
    for(int i=1;i<=12;i++){
        std::cout << UF.root(i) << " ";
    }
    std::cout << std::endl;
    
    //1と同じ集合に属しているなら1(true)、そうでないなら0(false)
    for(int i=1;i<=12;i++){
        std::cout << UF.same(1,i) << " ";
    }
    std::cout << std::endl;
    
    //同じ集合に入っている頂点がいくつあるか
    for(int i=1;i<=12;i++){
        std::cout << UF.size(i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
1 2 1 4 1 4 1 1 4 1 4 1 
1 0 1 0 1 0 1 1 0 1 0 1 
7 1 7 4 7 4 7 7 4 7 4 7 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/08/31 | sizeを追加 |
| 2021/03/26 | 使用例、コンストラクタを追加 |
| 2020/04/06 | UnionFindを追加 |

<div style="page-break-after: always;"></div>

# 🔴 ポテンシャル付きUnionFind 🔴

重み付きUnionFindって言ったほうがいいのかな？正直わからない

大体の機能は[UnionFind](./unionfind)と同じで違う点は

potential
- 頂点$$k$$のその時点でのポテンシャルを求める
- 計算量は$$Ο(\alpha (N))$$

unite
- 集合を合併する際に、$$(Qのポテンシャル)-(Pのポテンシャル)=d$$になるように指定する
- P,Qが同じ集合にある場合にfalseを返す

diff
- $$(Qのポテンシャル)-(Pのポテンシャル)$$を返す
- 計算量は$$Ο(\alpha (N))$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/potentialized%20unionfind.cpp)

```cpp
class potentialized_unionfind{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> UF,rank,pot;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i<N;i++){
            UF.push_back(i);
            rank.push_back(0);
            pot.push_back(0);
        }
    }

    potentialized_unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            int r = root(UF[k]);
            pot[k] += pot[UF[k]];
            UF[k] = r;
            return UF[k];
        }
    }
    
    int potential(int k){
        root(k);
        return pot[k];
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    bool unite(int P,int Q,int d){
        //pot(Q)-pot(P)=dを満たす
        d+=potential(P);
        d-=potential(Q);
        int p=root(P), q=root(Q);
        if(p==q)return false;
        if(rank[p]<rank[q]){
            std::swap(p,q);
            d = -d;
        }
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        pot[q]=d;
        
        return true;
    }
    
    int diff(int P,int Q){
        return potential(Q)-potential(P);
    }
    
};
```


## 使用例
***

### 実行コード
```cpp
#include <bits/stdc++.h>

class potentialized_unionfind{/*省略*/};

int main(void){
    
    potentialized_unionfind potUF(5);
    
    potUF.unite(0,1,1);
    potUF.unite(1,2,2);
    potUF.unite(2,3,4);
    potUF.unite(2,4,8);
    
    std::cout << "頂点3と頂点4の結合はできているか" << std::endl;
    bool c = potUF.unite(3,4,4);
    if(c==true){
        std::cout << "true" << std::endl;
    }else{
        std::cout << "false" << std::endl;
    }
    std::cout << std::endl;
    
    std::cout << "頂点0とのポテンシャルの差は何か" << std::endl;
    for(int i=0;i<5;i++){
        std::cout << potUF.diff(0,i) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "頂点2とのポテンシャルの差は何か" << std::endl;
    for(int i=0;i<5;i++){
        std::cout << potUF.diff(2,i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 出力
```
頂点3と頂点4の結合はできているか
false

頂点0とのポテンシャルの差は何か
0 1 3 7 11 

頂点2とのポテンシャルの差は何か
-3 -2 0 4 8 
```


## 更新履歴
***

| 日時 | 内容 |
| :---: | :--- |
| 2023/06/29 | ライセンスのコメントアウトを変更 |
| 2021/03/26 | 使用例、コンストラクタを追加 |
| 2020/04/06 | ポテンシャル付きUnionFindを追加 |

<div style="page-break-after: always;"></div>

