---
title: "ã™ããƒ©ã‚¤ãƒ–ãƒ©ãƒª"
permalink: /posts/wild
writer: 0214sh7
layout: library
---

<style>
    pre, code {
        white-space: pre-wrap;
    }
</style>

<h2>æ•°å­¦</h2>
- [æ•°å­¦è©°ã‚åˆã‚ã›ãƒ‘ãƒƒã‚¯](./posts/basic-math)
- [ç´ æ•°modäºŒé …ä¿‚æ•°](./posts/binomial-coefficient)
- [ç´ å› æ•°åˆ†è§£(ç·šå½¢ç¯©)](./posts/sieve)
- [æ‹¡å¼µãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•](./posts/bezout-coef)
- [å‡¸åŒ…](./posts/convexhull)
- [ã‚ªã‚¤ãƒ©ãƒ¼ã®Ï†é–¢æ•°](./posts/totient)
- [é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›(FFT)](./posts/fft)
- [æ•°è«–å¤‰æ›(NTT)](./posts/ntt)
- [ä»»æ„modäºŒé …ä¿‚æ•°](./posts/composite-binomial-coefficient)

<h2>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h2>
- [äºŒæ¬¡å…ƒé…åˆ—ã®å›è»¢](./posts/vector2d-rotate)
- [ãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸®](./posts/run-length-encode)
- [åè§’ã‚½ãƒ¼ãƒˆ](./posts/arg-sort)
- [åå¾©å†™åƒ](./posts/iterated-function)
- [ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤](./posts/slideminimum)
- [åº§æ¨™åœ§ç¸®](./posts/compress)
- [æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—](./posts/lis)
- [Moã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ](./posts/mos-algorithm)
- [ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒãƒƒã‚·ãƒ¥](./posts/rollinghash)

<h2>ã‚°ãƒ©ãƒ•</h2>
- [ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•](./posts/dijkstra)
- [ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³•](./posts/bellmanford)
- [ã‚¯ãƒ©ã‚¹ã‚«ãƒ«æ³•](./posts/kruskal)
- [äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®š](./posts/bipartite)
- [æœ¨ã®ç›´å¾„](./posts/double-sweep)
- [æœ€å°å…±é€šç¥–å…ˆ](./posts/lowest-common-ancestor)
- [ãƒ‡ã‚£ãƒ‹ãƒƒãƒ„æ³•](./posts/dinic)

<h2>ãƒ‡ãƒ¼ã‚¿æ§‹é€ </h2>
- [ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨](./posts/segmenttree)
- [ãƒ•ã‚§ãƒ‹ãƒƒã‚¯æœ¨](./posts/fenwicktree)
- [UnionFind](./posts/unionfind)
- [ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ä»˜ãUnionFind](./posts/pot-unionfind)


---
<div style="page-break-after: always;"></div>

# ğŸ”´ æ•°å­¦è©°ã‚åˆã‚ã›ãƒ‘ãƒƒã‚¯ ğŸ”´

å„ªæŸ”ä¸æ–­ãªã‚ãªãŸã«

ã¨ã„ã†ã®ã¯å»ºå‰ã§ã€ãã‚Œãã‚Œç‹¬ç«‹ã—ã¦æ‰±ã†ã»ã©ã§ã¯ãªã„ãŒé‡è¦ãªã‚‚ã®ã‚’ä¸€ç®‡æ‰€ã«é›†ã‚ãŸ

[github](https://github.com/0214sh7/procon-library/blob/master/math/basic%20math%20assortment.cpp)



# ã‚‚ãã˜
- [å°æ•°ç‚¹ä»¥ä¸‹åˆ‡ã‚Šä¸Šã’(å¤©äº•é–¢æ•°)]( #å°æ•°ç‚¹ä»¥ä¸‹åˆ‡ã‚Šä¸Šã’å¤©äº•é–¢æ•° )
- [éšä¹—]( #éšä¹— )
- [æœ€å¤§å…¬ç´„æ•°]( #æœ€å¤§å…¬ç´„æ•° )
- [æœ€å°å…¬å€æ•°]( #æœ€å°å…¬å€æ•° )
- [ç´„æ•°åˆ—æŒ™]( #ç´„æ•°åˆ—æŒ™ )
- [ç´ æ•°åˆ¤å®š]( #ç´ æ•°åˆ¤å®š )
- [ç´ æ•°åˆ—æŒ™]( #ç´ æ•°åˆ—æŒ™ )
- [ç´ å› æ•°åˆ†è§£]( #ç´ å› æ•°åˆ†è§£ )
- [ç´¯ä¹—(ç¹°ã‚Šè¿”ã—äºŒä¹—æ³•)]( #ç´¯ä¹—ç¹°ã‚Šè¿”ã—äºŒä¹—æ³• )
- [é€†å…ƒ(ç´ æ•°MOD)]( #é€†å…ƒç´ æ•°mod )


---

## å°æ•°ç‚¹ä»¥ä¸‹åˆ‡ã‚Šä¸Šã’(å¤©äº•é–¢æ•°)

- ã‚ˆãã‚ã‚‹å¤©äº•é–¢æ•°
- è¨ˆç®—é‡ã¯$$ÎŸ(1)$$

```cpp
long long roundup(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    return (a+b-1)/b;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long roundup(long long a,long long b){/*çœç•¥*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << i << " ";
    }
    std::cout << std::endl;
    for(int i=0;i<=10;i++){
        std::cout << roundup(i,4) << " ";
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
0 1 2 3 4 5 6 7 8 9 10 
0 1 1 1 1 2 2 2 2 3 3 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## éšä¹—

- ä¸ãˆã‚‰ã‚ŒãŸ$$x$$ã«å¯¾ã—$$x!$$ã‚’è¨ˆç®—ã™ã‚‹
- $$MOD$$ã‚‚ä¸ãˆã‚‹ã¨ãã‚Œã§å‰²ã£ãŸä½™ã‚Šã‚’ã¨ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(x)$$

```cpp
long long fact(long long x,long long MOD=LLONG_MAX){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long k=1;
    for(int i=1;i<=x;i++){
        k=(k*i)%MOD;
    }
    return k;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long fact(long long x,long long MOD=LLONG_MAX){/*çœç•¥*/}

int main(void){
    
    for(int i=0;i<=6;i++){
        std::cout << fact(i) << " ";
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
1 1 2 6 24 120 720 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## æœ€å¤§å…¬ç´„æ•°

- ï¼’ã¤ã®å¼•æ•°ã®GCDã‚’æ±‚ã‚ã‚‹
- è¨ˆç®—é‡ã¯$$O(log(max(a,b)))$$

```cpp
long long gcd(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    a=std::abs(a);
    b=std::abs(b);
    if(a>b)std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long gcd(long long a,long long b){/*çœç•¥*/}

int main(void){
    
    std::cout << gcd(4,6) << std::endl;
    std::cout << gcd(3,5) << std::endl;
    std::cout << gcd(12,18) << std::endl;
    std::cout << gcd(8,13) << std::endl;
    
    return 0;
}
```

#### å‡ºåŠ›
```
2
1
6
1
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## æœ€å°å…¬å€æ•°

- ï¼’ã¤ã®å¼•æ•°ã®LCMã‚’æ±‚ã‚ã‚‹
- è¨ˆç®—é‡ã¯$$O(log(max(a,b)))$$

```cpp
long long lcm(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(std::abs(a)>std::abs(b))std::swap(a,b);
    if(a==0){
        return b;
    }
    
    long long s=a,t=b;
    a=std::abs(a);
    b=std::abs(b);
    if(a>b)std::swap(a,b);
    
    long long r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    
    return s / b * t;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long lcm(long long a,long long b){/*çœç•¥*/}

int main(void){
    
    std::cout << lcm(4,6) << std::endl;
    std::cout << lcm(3,5) << std::endl;
    std::cout << lcm(12,18) << std::endl;
    std::cout << lcm(8,13) << std::endl;
    
    return 0;
}
```

#### å‡ºåŠ›
```
12
15
36
104
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## ç´„æ•°åˆ—æŒ™

- è‡ªç„¶æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€$$N$$ã®æ­£ã®ç´„æ•°ã‚’å°ã•ã„é †ã«ä¸¦ã¹ãŸvectorã‚’è¿”ã™
- æ­£ã§ãªã„æ•°ã‚’ä¸ãˆã‚‹ã¨ç©ºã®vectorã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$O(\sqrt{N})$$

```cpp
std::vector<long long> divisor_enum(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    if(N<=0)return R;
    long long s=0;
    for(long long i=1;i*i<=N;i++){
        if(N%i==0){
            R.push_back(i);
            if(i*i!=N)s++;
        }
    }
    for(long long i = s-1;i>=0;i--){
        R.push_back(N/R[i]);
    }
    return R;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<long long> divisor_enum(long long N){/*çœç•¥*/}

signed main() {
    
    for(long long i=1;i<=10;i++){
        std::cout << i << "  ";
        std::vector<long long> K = divisor_enum(i);
        for(long long j=0;j<K.size();j++){
            std::cout << K[j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
1  1 
2  1 2 
3  1 3 
4  1 2 4 
5  1 5 
6  1 2 3 6 
7  1 7 
8  1 2 4 8 
9  1 3 9 
10  1 2 5 10 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## ç´ æ•°åˆ¤å®š

- ä¸ãˆã‚‰ã‚ŒãŸ$$x$$ã«å¯¾ã—ã€$$x$$ãŒç´ æ•°ãªã‚‰trueã‚’ã€ãã†ã§ãªã„ãªã‚‰falseã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$O(\sqrt{x})$$

```cpp
bool prime(long long X){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(X<2)return false;
    for(long long i=2;i*i<=X;i++){
        if(X%i==0){
            return false;
        }
    }
    return true;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

bool prime(long long X){/*çœç•¥*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << i << " ";
    }
    std::cout << std::endl;
    
    for(int i=0;i<=10;i++){
        std::cout << prime(i) << " ";
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
0 1 2 3 4 5 6 7 8 9 10 
0 0 1 1 0 1 0 1 0 0 0 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## ç´ æ•°åˆ—æŒ™

- ä¸ãˆã‚‰ã‚ŒãŸ$$N$$ã«å¯¾ã—ã€$$N$$ä»¥ä¸‹ã®ç´ æ•°ã‚’åˆ—æŒ™ã—ã€å°ã•ã„é †ã«vectorã¨ã—ã¦è¿”ã™
- è¨ˆç®—é‡ã¯$$O(NloglogN)$$

```cpp
std::vector<long long> primearray(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    std::vector<bool> prime;
    for(int i=0;i<=N;i++){
        prime.push_back(true);
    }
    if(N<2){
        return R;
    }
    prime[0]=false;
    prime[1]=false;
    for(long long i=2;i*i<=N;i++){
        if(!prime[i])continue;
        for(int j=2*i;j<=N;j+=i){
            prime[j]=false;
        }
    }
    for(long long i=0;i<prime.size();i++){
        if(prime[i]){
            R.push_back(i);
        }
    }
    return R;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<long long> primearray(long long N){/*çœç•¥*/}

int main(void){
    
    std::vector<long long> P = primearray(100);
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### å‡ºåŠ›
```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## ç´ å› æ•°åˆ†è§£

- ä¸ãˆã‚‰ã‚ŒãŸ$$N$$ã«å¯¾ã—ã€$$N$$ã‚’ç´ å› æ•°åˆ†è§£ã—ã€å°ã•ã„é †ã«vectorã¨ã—ã¦è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(\sqrt{N})$$

```cpp
std::vector<long long> prime_factorization(long long N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    if(N<2)return R;
    for(long long i=2;i*i<=N;i++){
        while(N%i==0){
            R.push_back(i);
            N/=i;
        }
    }
    if(N!=1){
          R.push_back(N);
    }
    return R;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<long long> prime_factorization(long long N){/*çœç•¥*/}

int main(void){
    
    std::vector<long long> number={4,12,57,97,210};
    for(int j=0;j<5;j++){
        std::cout << number[j] << "  ";
        std::vector<long long> F = prime_factorization(number[j]);
        for(int i=0;i<F.size();i++){
            std::cout << F[i] << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### å‡ºåŠ›
```
4  2 2 
12  2 2 3 
57  3 19 
97  97 
210  2 3 5 7 
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## ç´¯ä¹—(ç¹°ã‚Šè¿”ã—äºŒä¹—æ³•)

- ä¸ãˆã‚‰ã‚ŒãŸ$$b,e$$ã«å¯¾ã—ã€$$b^e$$ã‚’è¿”ã™
- $$MOD$$ã‚‚ä¸ãˆã‚‹ã¨ãã‚Œã§å‰²ã£ãŸä½™ã‚Šã‚’ã¨ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(log(e))$$

```cpp
long long power(long long b,long long e,long long MOD=LLONG_MAX){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long r=1;
    while(e){
        if(e&1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e >>=1;
    }
    return r;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long power(long long b,long long e,long long MOD=LLONG_MAX){/*çœç•¥*/}

int main(void){
    
    std::cout << "2ã®iä¹—"<< std::endl;
    for(int i=0;i<=10;i++){
        std::cout << power(2,i) << " ";
    }
    std::cout << std::endl;
    
    std::cout << "2ã®iä¹—ã‚’100ã§å‰²ã£ãŸã‚ã¾ã‚Š"<< std::endl;
    for(int i=0;i<=10;i++){
        std::cout << power(2,i,100) << " ";
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
2ã®iä¹—
1 2 4 8 16 32 64 128 256 512 1024 
2ã®iä¹—ã‚’100ã§å‰²ã£ãŸã‚ã¾ã‚Š
1 2 4 8 16 32 64 28 56 12 24
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## é€†å…ƒ(ç´ æ•°MOD)

- ä¸ãˆã‚‰ã‚ŒãŸ$$b,MOD$$ã«å¯¾ã—ã€$$MOD$$ã‚’æ³•ã¨ã—ãŸæ•´æ•°ç’°ä¸Šã§ã®é€†å…ƒ($$bx=1$$ã‚’æº€ãŸã™$$x$$)ã‚’è¿”ã™
- MODãŒç´ æ•°ã§ãªã„å ´åˆã®å‹•ä½œã¯æœªç¢ºèª
- è¨ˆç®—é‡ã¯$$ÎŸ(log(MOD))$$

```cpp
long long inverse(long long b,long long MOD){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long r=1,e=MOD-2;
    while(e){
        if(e&1){
            r=(r*b)%MOD;
        }
        b=(b*b)%MOD;
        e >>=1;
    }
    return r;
}
```

### ä½¿ç”¨ä¾‹

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long inverse(long long b,long long MOD){/*çœç•¥*/}

int main(void){
    
    std::cout << "mod 7ã§ã®iã®é€†å…ƒ"<< std::endl;
    for(int i=1;i<7;i++){
        std::cout << i << " " << inverse(i,7) << " " << (i*inverse(i,7))%7 << std::endl;
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
mod 7ã§ã®iã®é€†å…ƒ
1 1 1
2 4 1
3 5 1
4 2 1
5 3 1
6 6 1
```

[ã‚‚ãã˜ã«æˆ»ã‚‹](#ã‚‚ãã˜)

---

## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/04/05 | ç´„æ•°åˆ—æŒ™ã‚’è¿½åŠ  |
| 2021/03/27 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2021/03/26 | è»½å¾®ãªãƒã‚°ã‚’ä¿®æ­£ |
| 2021/03/26 | ã‚¢ãƒ³ã‚«ãƒ¼ãƒªãƒ³ã‚¯ã‚’è¿½åŠ  |
| 2021/06/01 | ç´ å› æ•°åˆ†è§£ã®ãƒã‚°ã‚’ä¿®æ­£ |
| 2020/04/03 | æ•°å­¦è©°ã‚åˆã‚ã›ãƒ‘ãƒƒã‚¯ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ç´ æ•°modäºŒé …ä¿‚æ•° ğŸ”´


init
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€combã‚’å®Ÿè¡Œã™ã‚‹ã®ã«å¿…è¦ãªæ•°å€¤(éšä¹—ã¨ãã®é€†å…ƒ)ã‚’å‰è¨ˆç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

binomial_coefficient
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

extension
- initã§ç”¨æ„ã—ãŸç¯„å›²ã§è¶³ã‚Šãªã„å ´åˆã€æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ä¸è¶³åˆ†ã‚’è¿½åŠ ã§å‰è¨ˆç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯å®Ÿè¡Œå‰ã®ã‚µã‚¤ã‚ºã‚’$$s$$ã¨ã—ã¦ã€$$ÎŸ(N-s+log(MOD))$$

comb
- æ•´æ•°$$n,r$$ã‚’ä¸ãˆã‚‹ã¨ã€$$\frac{n!}{r!(n-r)!}$$ã‚’$$MOD$$ã§å‰²ã£ãŸä½™ã‚Šã‚’è¿”ã™
- ã‚‚ã—ã“ã‚Œã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®å‰è¨ˆç®—ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã€ã¡ã‚‡ã†ã©è£œå®Œã™ã‚‹ã‚ˆã†ã«extensionãŒå®Ÿè¡Œã•ã‚Œã‚‹
- ã“ã®ãŸã‚ã€è¨ˆç®—é‡ã‚’æ°—ã«ã—ãªã‘ã‚Œã°initã¯å‘¼ã°ãªãã¦ã‚‚è‰¯ã„
- ã¾ãŸæœ€åˆã«initã«ååˆ†ãªå€¤ã‚’ä¸ãˆã¦ã„ã‚Œã°extensionã¯å‘¼ã°ã‚Œãªã„
- è¨ˆç®—é‡ã¯extensionã®ã‚‚ã®+$$ÎŸ(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/binomial%20coefficient.cpp)

```cpp
class binomial_coefficient{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const long long MOD = 998244353;
    int sze = 0;
    std::vector<long long> fact;
    std::vector<long long> factinv;
    
    long long Gfinv(long long b){
        long long r=1;
        long long e=MOD-2;
        while(e){
            if(e&1){
                r=(r*b)%MOD;
            }
                b=(b*b)%MOD;
                e >>=1;
        }
        return r;
    }
    
    public:
    
    void init(int N){
        if(N<0){
            return ;
        }
        sze = N+1;
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[0]=1;
        for(long long i=1;i<=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i>=0;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
    }
    
    binomial_coefficient(int N){
        init(N);
    }
    
    void extension(int N){
        if(sze>N && sze!=0){
            return ;
        }
        
        fact.resize(N+1);
        factinv.resize(N+1);
        
        fact[sze]=(sze==0)?1:(fact[sze-1]*sze)%MOD;
        
        for(long long i=sze+1;i<=N;i++){
            fact[i]=(fact[i-1]*i)%MOD;
        }
        factinv[N] = Gfinv(fact[N]);
        for(long long i=N-1;i>=sze;i--){
            factinv[i]=(factinv[i+1]*(i+1))%MOD;
        }
        sze = N+1;
    }
    
    long long comb(long long n,long long r){
        if(n<0 || r<0 || n<r){
            return 0;
        }
        
        if(n>=sze){
            extension(n);
        }
        
        long long R = fact[n];
        R = (R*factinv[r])%MOD;
        R = (R*factinv[n-r])%MOD;
        return R;
    }
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class binomial_coefficient{/*çœç•¥*/};

int main(void){
    
    binomial_coefficient BC(10);
    for(int i=0;i<=5;i++){
        for(int j=0;j<=5;j++){
            std::cout << BC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

### å‡ºåŠ›
```
1 0 0 0 0 0 
1 1 0 0 0 0 
1 2 1 0 0 0 
1 3 3 1 0 0 
1 4 6 4 1 0 
1 5 10 10 5 1 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2023/03/18 | åç§°ã‚’äºŒé …ä¿‚æ•°ã‹ã‚‰ç´ æ•°modäºŒé …ä¿‚æ•°ã«å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2021/02/18 | nã‚’æŒ‡å®šã—ã¦vectorã‚’è¿”ã™å½¢å¼ã‹ã‚‰classåŒ–ã—n,rã‹ã‚‰nCrã‚’è¿”ã™å½¢å¼ã«å¤‰æ›´ |
| 2020/04/04 | äºŒé …ä¿‚æ•°ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ç´ å› æ•°åˆ†è§£(ç·šå½¢ç¯©) ğŸ”´


init
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€å‰è¨ˆç®—ã¨ã—ã¦$$N$$ä»¥ä¸‹ã®åˆæˆæ•°$$i$$ã«ã¤ã„ã¦$$i$$ã®è‡ªæ˜ã§ãªã„($$1$$ã§ã‚‚$$i$$ã§ã‚‚ãªã„)ç´„æ•°ã®1ã¤ã‚’æ±‚ã‚ã‚‹
- ãã‚Œã¨åŒæ™‚ã«ã€$$N$$ä»¥ä¸‹ã®ç´ æ•°ã®ãƒªã‚¹ãƒˆã‚‚æ±‚ã‚ã‚‹
- ä»¥é™ã®é–¢æ•°ã«$$N$$ã‚ˆã‚Šå¤§ãã„å€¤ã‚’ä¸ãˆã‚‹ã¨è£œå®Œã®ãŸã‚ã«initãŒå‘¼ã°ã‚Œã‚‹ã€‚ã“ã‚Œã¯æœ€åˆã«initã«ååˆ†å¤§ãã„å€¤ã‚’ä¸ãˆã‚‹ã“ã¨ã§å›é¿ã§ãã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

linear_sieve
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

primearray
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€$$N$$ä»¥ä¸‹ã®ç´ æ•°ã‚’æ˜‡é †ã«ä¸¦ã¹ãŸvectorã‚’è¿”ã™
- ã‚‚ã—å‰è¨ˆç®—ãŒè¶³ã‚Šãªã„å ´åˆã€ã¡ã‚‡ã†ã©è£œå®Œã™ã‚‹ã‚ˆã†ã«initãŒå®Ÿè¡Œã•ã‚Œã‚‹
- è¨ˆç®—é‡ã¯initã®ã‚‚ã®+$$ÎŸ(N/log(N))$$

divisor
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€å‰è¨ˆç®—ã—ãŸ$$N$$ã®è‡ªæ˜ã§ãªã„ç´„æ•°ã®1ã¤ã‚’è¿”ã™
- ã‚‚ã—$$N$$ãŒç´ æ•°ãªã‚‰$$N$$ã‚’ã€$$1$$ãªã‚‰$$1$$ã‚’ã€æ­£ã§ãªã„ãªã‚‰$$-1$$ã‚’è¿”ã™
- ã‚‚ã—å‰è¨ˆç®—ãŒè¶³ã‚Šãªã„å ´åˆã€ã¡ã‚‡ã†ã©è£œå®Œã™ã‚‹ã‚ˆã†ã«initãŒå®Ÿè¡Œã•ã‚Œã‚‹
- è¨ˆç®—é‡ã¯initã®ã‚‚ã®+$$ÎŸ(1)$$

factorization
- æ•´æ•°$$X$$ã‚’ä¸ãˆã‚‹ã¨ã€$$X$$ã‚’ç´ å› æ•°åˆ†è§£ã—ã€çµæœã‚’**å¤§ãã„é †ã«**ä¸¦ã¹ã€vectorã¨ã—ã¦è¿”ã™
- ã‚‚ã—å‰è¨ˆç®—ãŒè¶³ã‚Šãªã„å ´åˆã€ã¡ã‚‡ã†ã©è£œå®Œã™ã‚‹ã‚ˆã†ã«initãŒå®Ÿè¡Œã•ã‚Œã‚‹
- è¨ˆç®—é‡ã¯initã®ã‚‚ã®+$$ÎŸ(log(N))$$

exp_enum
- æ•´æ•°$$N,M,mod$$ã‚’ä¸ãˆã‚‹ã¨ã€$$0^M,1^M,...,N^M$$ã‚’ãã‚Œãã‚Œ$$mod$$ã§å‰²ã£ãŸã‚ã¾ã‚Šã‚’è¨ˆç®—ã—ã€vectorã¨ã—ã¦è¿”ã™
- $$N,M$$ãŒè² ã§ã‚ã‚‹å ´åˆã€ç©ºã®vectorã‚’è¿”ã™
- ã‚‚ã—å‰è¨ˆç®—ãŒè¶³ã‚Šãªã„å ´åˆã€ã¡ã‚‡ã†ã©è£œå®Œã™ã‚‹ã‚ˆã†ã«initãŒå®Ÿè¡Œã•ã‚Œã‚‹
- è¨ˆç®—é‡ã¯initã®ã‚‚ã®+$$ÎŸ(N + N \frac{log(M)}{log(N)})$$


[github](https://github.com/0214sh7/procon-library/blob/master/math/linear%20sieve.cpp)

```cpp
class linear_sieve{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    long long S=0;
    std::vector<long long> divisor_,prime;
    
    public:
    void init(long long N){
        S=N;
        prime.clear();
        divisor_.resize(N+1);
        for(long long i=0;i<N+1;i++){
            divisor_[i]=0;
        }
        
        if(N>=1){
            divisor_[1]=1;
        }
        
        
        for(long long i=2;i<=N;i++){
            if(divisor_[i]==0){
                divisor_[i]=i;
                prime.push_back(i);
            }
            for(long long j=0;j<=prime.size() && prime[j]<=divisor_[i] && i*prime[j]<=N ;j++){
                divisor_[prime[j]*i]=prime[j];
            }
        }
    }
    
    linear_sieve(long long N){
        init(N);
    }
    
    std::vector<long long> primearray(long long X){
        std::vector<long long> R;
        if(X<=1)return R;
        if(S<X)init(X);
        for(long long i=0;i<prime.size();i++){
            if(prime[i]<=X){
                R.push_back(prime[i]);
            }
        }
        return R;
    }
    
    long long divisor(long long X){
        if(X<=0)return -1;
        if(S<X)init(X);
        return divisor_[X];
    }
    
    std::vector<long long> factorization(long long X){
        std::vector<long long> R;
        if(X<=1)return R;
        if(S<X)init(X);
        R = factorization(X/divisor_[X]);
        R.push_back(divisor_[X]);
        return R;
    }
    
    std::vector<long long> exp_enum(long long N,long long M,long long mod=LLONG_MAX){
        std::vector<long long> R;
        if(N<0 || M<0)return R;
        if(S<N)init(N);
        
        for(long long i=0;i<=N;i++){
            R.push_back(-1);
        }
        R[0]=0;
        if(N>=1)R[1]=1;
        
        for(long long i=0;i<prime.size();i++){
            if(prime[i]>N)continue;
            long long r=1,b=prime[i],e=M;
            while(e){
                if(e&1){
                    r=(r*b)%mod;
                }
                b=(b*b)%mod;
                e >>=1;
            }
            R[prime[i]]=r;
        }
        
        for(long long i=0;i<=N;i++){
            if(R[i]!=-1)continue;
            R[i] = (R[i/divisor_[i]]*R[divisor_[i]])%mod;
        }
        return R;
    }
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class linear_sieve{/*çœç•¥*/};

int main(void){
    
    linear_sieve sieve(1000);
    
    std::cout << "100ä»¥ä¸‹ã®ç´ æ•°ã®ãƒªã‚¹ãƒˆ" << std::endl;
    std::vector<long long> P = sieve.primearray(100);
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "1~10ã®ç´„æ•°ã®ä¸€ã¤" << std::endl;
    for(int i=1;i<=10;i++){
        std::cout << sieve.divisor(i) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "4,12,57,97,210ã®ç´ å› æ•°åˆ†è§£" << std::endl;
    std::vector<long long> number={4,12,57,97,210};
    for(int j=0;j<5;j++){
        std::vector<long long> F = sieve.factorization(number[j]);
        for(int i=0;i<F.size();i++){
            std::cout << F[i] << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::cout << "0~10ã«ã¤ã„ã¦ã€i^3" << std::endl;
    std::vector<long long> E = sieve.exp_enum(10,3);
    for(int i=0;i<E.size();i++){
        std::cout << E[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
100ä»¥ä¸‹ã®ç´ æ•°ã®ãƒªã‚¹ãƒˆ
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 

1~10ã®ç´„æ•°ã®ä¸€ã¤
1 2 3 2 5 2 7 2 3 2 

4,12,57,97,210ã®ç´ å› æ•°åˆ†è§£
2 2 
3 2 2 
19 3 
97 
7 5 3 2 

0~10ã«ã¤ã„ã¦ã€i^3
0 1 8 27 64 125 216 343 512 729 1000 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/24 | ç´ å› æ•°åˆ†è§£(ç·šå½¢ç¯©)ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ æ‹¡å¼µãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³• ğŸ”´

æ‹¡å¼µãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•ã€extended Euclidean algorithmã®å¯¾è¨³æ„ŸãŒãã‚“ãªã«ãªã„ã­ã€€ã©ã†ã§ã‚‚ã„ã„ã­

æ•´æ•°$$a,b$$ã‚’ä¸ãˆã‚‹ã¨ã€$$g=gcd(a,b)$$ã¨ãã‚Œã‚’ç”¨ã„ã¦è¡¨ã•ã‚Œã‚‹ç­‰å¼

$$ax+by=g$$

ã‚’æº€ãŸã™$$(x,y)$$(ãƒ™ã‚ºãƒ¼ä¿‚æ•°)ã‚’ä¸€ã¤æ±‚ã‚ã€$$g$$ã¨ã¨ã‚‚ã«è¿”ã™

è¨ˆç®—é‡ã¯$$O(log(max(a,b)))$$

ã“ã“ã§è¿”ã‚Šå€¤ã¯pair<ll,pair<ll,ll>>ã¨ãªã£ã¦ã„ã‚‹ãŒã€ãã‚Œãã‚Œ$$ \{g,\{x,y\}\} $$ã‚’è¡¨ã—ã¦ã„ã‚‹

[github](https://github.com/0214sh7/procon-library/blob/master/math/extended%20Euclidean%20algorithm.cpp)

```cpp
std::pair<long long,std::pair<long long,long long>> extgcd(long long a,long long b){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> q;
    while(b!=0){
        long long r = a%b;
        r+=b;
        r%=b;
        long long q_ = (a-r)/b;
        q.push_back(q_);
        a = b;
        b = r;
    }
    
    long long g=a,x=1,y=0;
    if(g<0){
        g*=-1;
        x*=-1;
    }
    for(int i=-1+(int)q.size();i>=0;i--){
        long long tmp = y;
        y = x-q[i]*y;
        x = tmp;
    }
    
    return {g,{x,y}};
}
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::pair<long long,std::pair<long long,long long>> extgcd(long long a,long long b){/*çœç•¥*/}

signed main() {
    
    std::pair<long long,std::pair<long long,long long>> R;
    R = extgcd(111,30);
    long long g = R.first, x = R.second.first, y = R.second.second;
    
    std::cout << "111ã¨30ã®æœ€å¤§å…¬ç´„æ•°" << std::endl;
    std::cout << g << std::endl;
    std::cout << std::endl;
    
    
    std::cout << "111x+30y=3ã‚’æº€ãŸã™ã‚ˆã†ãª(x,y)ã®ä¸€ä¾‹" << std::endl;
    std::cout << "(" << x << "," << y << ")" << std::endl;
    std::cout << std::endl;
    
    
    std::cout << "111x+30y" << std::endl;
    std::cout << 111*x+30*y << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
111ã¨30ã®æœ€å¤§å…¬ç´„æ•°
3

111x+30y=3ã‚’æº€ãŸã™ã‚ˆã†ãª(x,y)ã®ä¸€ä¾‹
(3,-11)

111x+30y
3
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/04/08 | æ¬ è½ã—ã¦ã„ãŸè¨ˆç®—é‡ã‚’è¿½åŠ  |
| 2021/04/08 | æ‹¡å¼µãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ å‡¸åŒ… ğŸ”´

ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯Andrewã®monotone chainã¨ã„ã†åå‰ã‚‰ã—ã„

äºŒæ¬¡å…ƒä¸Šã®ç‚¹é›†åˆã‚’vector<pair<long long,long long>>ã§ä¸ãˆã‚‹

ã™ã‚‹ã¨ãã®ç‚¹é›†åˆã®å‡¸åŒ…ã‚’æ±‚ã‚ã€xåº§æ¨™ãŒæœ€ã‚‚å°ã•ã„ç‚¹ã®ã†ã¡yåº§æ¨™ãŒæœ€ã‚‚å°ã•ã„ç‚¹ã‹ã‚‰å§‹ã‚ã¦åæ™‚è¨ˆå›ã‚Šã«ä¸¦ã¹ã¦vector<pair<long long,long long>>ã§è¿”ã™

è¨ˆç®—é‡ã¯$$O(\vert P \vert log \vert P \vert)$$(ã‚½ãƒ¼ãƒˆãŒãƒãƒƒã‚¯ã«ãªã£ã¦ãŠã‚Šã€ã‚½ãƒ¼ãƒˆãŒãªã‘ã‚Œã°$$O(\vert P \vert)$$)

[github](https://github.com/0214sh7/procon-library/blob/master/math/convex%20hull.cpp)

```cpp
std::vector<std::pair<long long,long long>> convex_hull(std::vector<std::pair<long long,long long>> P){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(P.size()<=2){
        return P;
    }
    std::vector<std::pair<long long,long long>> H,L,R;
    sort(P.begin(),P.end());
    
    //ä¸‹åŠåˆ†
    for(int i=0;i<P.size();i++){
        int j=L.size();
        while(j>=2 && (L[j-1].first-L[j-2].first)*(P[i].second-L[j-2].second)<=(L[j-1].second-L[j-2].second)*(P[i].first-L[j-2].first)){
            L.pop_back();
            j--;
        }
        L.push_back(P[i]);
    }
    
    //ä¸ŠåŠåˆ†
    for(int i=P.size()-1;i>=0;i--){
        int j=H.size();
        while(j>=2 && (H[j-1].first-H[j-2].first)*(P[i].second-H[j-2].second)<=(H[j-1].second-H[j-2].second)*(P[i].first-H[j-2].first)){
            H.pop_back();
            j--;
        }
        H.push_back(P[i]);
    }
    
    
    R=L;
    for(int i=1;i<H.size()-1;i++){
        R.push_back(H[i]);
    }
    
    return R;
}
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<std::pair<long long,long long>> convex_hull(std::vector<std::pair<long long,long long>> P){/*çœç•¥*/}

int main(void){
    
    std::vector<std::pair<long long,long long>> P,Q;
    P.push_back({0,0});
    P.push_back({2,0});
    P.push_back({1,1});
    P.push_back({0,2});
    P.push_back({2,2});
    
    Q = convex_hull(P);
    for(int i=0;i<Q.size();i++){
        std::cout << Q[i].first << " " << Q[i].second << std::endl;
    }
    return 0;
}
```

### å‡ºåŠ›
```
0 0
2 0
2 2
0 2
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2020/04/22 | å‡¸åŒ…ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ã‚ªã‚¤ãƒ©ãƒ¼ã®Ï†é–¢æ•° ğŸ”´

$$\varphi$$ã¯ãƒˆãƒ¼ã‚·ã‚§ãƒ³ãƒˆã¨èª­ã‚€ã‚‰ã—ã„

$$\varphi(n)$$ã¨ã¯ã€$$1$$ã‹ã‚‰$$n$$ã¾ã§ã®æ•´æ•°ã§ã€$$n$$ã¨äº’ã„ã«ç´ ã§ã‚ã‚‹ã‚‚ã®ã®å€‹æ•°

ã“ã‚Œã¯ã€$$n$$ãŒç›¸é•ãªç´ å› æ•°$$p_1,p_2,...,p_d$$ã‚’å«ã‚€ã¨ã—ã¦

$$\varphi(n) = n\prod_{k=1}^d (1-\frac{1}{p_k})$$

ã¨è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹

[github](https://github.com/0214sh7/procon-library/blob/master/math/Euler's%20totient%20function.cpp)


å˜ä½“
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€$$\varphi(N)$$ã‚’è¨ˆç®—ã—æ•´æ•°ã§è¿”ã™
- è¨ˆç®—é‡ã¯$$O(\sqrt{N})$$

```cpp
int totient(int N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    if(N<0){
        return 0;
    }
    int R = N;
    for(int i=2;i*i<=N;i++){
        if(N%i==0){
            R -= R/i;
            while(N%i==0){
                N/=i;
            }
        }
    }
    if(N>1){
        R -= R/N;
    }
    return R;
}
```


åˆ—æŒ™
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€$$0$$ã‹ã‚‰$$N$$ã¾ã§ã®$$\varphi(i)$$ã‚’è¨ˆç®—ã—,è¦ç´ æ•°ãŒ$$N+1$$ã®vectorã§è¿”ã™
- ã“ã“ã§ã€$$\varphi(0)=0$$ã¨ã—ã¦ã„ã‚‹
- è¨ˆç®—é‡ã¯$$O(NloglogN)$$

```cpp
std::vector<int> totient_array(int N){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<int> R(N+1);
    for(int i=0;i<=N;i++){
        R[i]=i;
    }
    for(int i=2;i<=N;i++){
        if(R[i]!=i)continue;
        for(int j=i;j<=N;j+=i){
            R[j]-=(R[j]/i);
        }
    }
    return R;
}
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

int totient(int N){/*çœç•¥*/}
std::vector<int> totient_array(int N){/*çœç•¥*/}

int main(void){
    
    for(int i=0;i<=10;i++){
        std::cout << totient(i) << " ";
    }
    std::cout << std::endl;
    
    std::vector<int> T = totient_array(10);
    for(int i=0;i<=10;i++){
        std::cout << T[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0 1 1 2 2 4 2 6 4 6 4 
0 1 1 2 2 4 2 6 4 6 4 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2020/04/16 | ã‚ªã‚¤ãƒ©ãƒ¼ã®Ï†é–¢æ•°ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ› ğŸ”´

ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŒã€å®Ÿè¡Œã™ã‚‹ã¨ãã¯convolutionã‚’å‘¼ã³å‡ºã›ã°ã„ã„

å¤šé …å¼ã«è¦‹ç«‹ã¦ãŸvectorã‚’$$2$$ã¤ä¸ãˆã‚‹ã¨ã€ãã‚Œã‚‰ã«å¯¾ã—é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’ç”¨ã„ãŸç•³ã¿è¾¼ã¿æ¼”ç®—ã‚’è¡Œã„ä¸€ã¤ã®å¤šé …å¼ã«ã—ã€vectorã¨ã—ã¦è¿”ã™

$$\{1,2,3\}*\{1,3,5\}=\{1,5,14,19,15\}$$ã¨ã„ã£ãŸèª¿å­

å®Ÿè£…ä¸Šdoubleã‚’çµŒç”±ã—ã¦ã„ã‚‹ã®ã§èª¤å·®æ­»ãŒæ€–ã„

è¨ˆç®—é‡ã¯$$N=max(\vert A \vert,\vert B\vert)$$ã¨ã—ã¦ã€$$ÎŸ(NlogN)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/fast%20Fourier%20transform.cpp)

```cpp
class fast_Fourier_transform{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const double PI=3.14159265358979; 
    
    std::vector<std::complex<double>> DFT(std::vector<std::complex<double>> A){
        int N=A.size();
        if(N==1)return A;
        std::vector<std::complex<double>> A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i<N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        for(int i=0;i<N;i++){
            std::complex<double> ith_zeta = std::complex<double>(cos(2*PI*i/N),sin(2*PI*i/N));
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)]);
        }
        return iA;
    }
    
    std::vector<std::complex<double>> iDFT(std::vector<std::complex<double>> iA){
        int N=iA.size();
        std::vector<std::complex<double>> A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i<N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back(rA[i]/std::complex<double>(N,0));
        }
        return A;
    }
    
    public:
    std::vector<long long> convolution(std::vector<long long> A,std::vector<long long> B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N<deg){N<<=1;}
        A.resize(N);B.resize(N);
        std::vector<std::complex<double>> dC(N),iC(N),dA,iA,dB,iB;
        std::vector<long long> C(N);
        for(int i=0;i<A.size();i++){
            dA.push_back(A[i]);
        }
        for(int i=0;i<B.size();i++){
            dB.push_back(B[i]);
        }
        iA=DFT(dA);iB=DFT(dB);
        for(int i=0;i<N;i++){
            iC[i]=iA[i]*iB[i];
        }
        dC=iDFT(iC);
        for(int i=0;i<dC.size();i++){
            C[i]=(0.1+dC[i].real());
        }
        C.resize(deg);
        return C;
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class fast_Fourier_transform{/*çœç•¥*/};

int main(void){
    
    fast_Fourier_transform FFT;
    std::vector<long long> A={1,2,3},B={1,3,5},C;
    
    C = FFT.convolution(A,B);
    for(int i=0;i<C.size();i++){
        std::cout << C[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
1 5 14 19 15 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ãƒã‚°ã‚’ä¿®æ­£ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2020/04/04 | é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ æ•°è«–å¤‰æ› ğŸ”´

æ•´æ•°ç’°FFTã¨ã‚‚

åŸºæœ¬çš„ã«ã¯[FFT](./fft)ã¨åŒã˜ã ãŒã€ã‚ã¡ã‚‰ãŒå®Ÿæ•°ã‚’ä½¿ã£ã¦è¨ˆç®—ã™ã‚‹ã®ã«å¯¾ã—ã“ã¡ã‚‰ã¯æœ‰ç†æ•°ã‚’ç´ æ•°ã§å‰²ã£ãŸä½™ã‚Šã‚’ä½¿ã£ã¦è¨ˆç®—ã™ã‚‹

èª¤å·®ãŒãªã„ã¨ã„ã†ãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚‹ãŒã€$$MOD$$ç´ æ•°ã‚ˆã‚Šå¤§ãã„æ•´æ•°ã‚’æ‰±ãˆãªã„ã¨ã„ã†ãƒ‡ãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚‹

ã“ã“ã§ç”¨ã„ã‚‹ç´ æ•°ã¯ã€$$P-1$$ãŒç´ å› æ•°ã«$$2$$ã‚’å¤šãå«ã‚€ã‚ˆã†ãª$$P$$ã§ã‚ã‚‹ã“ã¨ãŒæœ›ã¾ã—ã„(ä¾‹ãˆã°NTTã§ã‚ˆãä½¿ã‚ã‚Œã‚‹$$998244353$$ã¯$$119 \cdot 2^{23}+1$$ã§ã‚ã‚‹)


è¨ˆç®—é‡ã¯$$N=max(\vert A \vert,\vert B \vert)$$ã¨ã—ã¦ã€$$ÎŸ(NlogNlogMOD)$$

[github](https://github.com/0214sh7/procon-library/blob/master/math/number%20theoretic%20transform.cpp)

```cpp
class number_theoretic_transform{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    
    const long long MOD = 998244353;
    const long long k = 119;
    const long long n = 23;
    const long long pri_root = 3;
    //MOD=k*2^n+1
    
    long long BE(long long b,long long e){
        long long r=1;
        while(e){
            if(e&1){
                r=(r*b)%MOD;
            }
            b=(b*b)%MOD;
            e >>=1;
        }
        return r;
    }
    
    std::vector<long long> DFT(std::vector<long long> A){
        int N=A.size();
        if(N==1)return A;
        std::vector<long long> A0(N/2),A1(N/2),iA0,iA1,iA(N);
        for(int i=0;i<N;i++){
            if(i%2==0){
                A0[i/2]=A[i];
            }else{
                A1[i/2]=A[i];
            }
        }
        iA0=DFT(A0);
        iA1=DFT(A1);
        
        long long omega=BE(pri_root,k*(1<<n)/N);
        long long ith_zeta = 1;
        for(int i=0;i<N;i++){
            iA[i]=(iA0[i%(N/2)]+ ith_zeta*iA1[i%(N/2)])%MOD;
            ith_zeta = (ith_zeta*omega)%MOD;
        }
        return iA;
    }
     
    std::vector<long long> iDFT(std::vector<long long> iA){
        int N=iA.size();
        long long N_inverse = BE(N,MOD-2);
        std::vector<long long> A,dA,rA;
        dA=DFT(iA);
        for(int i=0;i<N;i++){
            rA.push_back(dA[(N-i)%N]);
            A.push_back((rA[i]*N_inverse)%MOD);
        }
        return A;
    }
    
    
    public:
    
    std::vector<long long> convolution(std::vector<long long> A,std::vector<long long> B){
        int deg = A.size() + B.size() -1;
        long long N=1;
        while(N<deg){N<<=1;}
        A.resize(N);B.resize(N);
        for(int i=0;i<A.size();i++){
            A[i]%=MOD;
        }
        for(int i=0;i<B.size();i++){
            B[i]%=MOD;
        }
        std::vector<long long> C(N),iC(N),iA,iB;
        iA=DFT(A);iB=DFT(B);
        for(int i=0;i<N;i++){
            iC[i]=(iA[i]*iB[i])%MOD;
        }
        C=iDFT(iC);
        C.resize(deg);
        return C;
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class number_theoretic_transform{/*çœç•¥*/};

int main(void){
    
    number_theoretic_transform NTT;
    std::vector<long long> A={1,2,3},B={1,3,5},C;
    
    C = NTT.convolution(A,B);
    for(int i=0;i<C.size();i++){
        std::cout << C[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
1 5 14 19 15 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ /vectorã‚’std::vectorã«å¤‰æ›´ |
| 2020/04/04 | æ•°è«–å¤‰æ›ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ä»»æ„modäºŒé …ä¿‚æ•° ğŸ”´

è¨ˆç®—é‡ã®ç•°ãªã‚‹ $$2$$ ã¤ã®ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹

[github](https://github.com/0214sh7/procon-library/blob/master/math/composite%20binomial%20coefficient.cpp)


- [ãã®ï¼‘]( #ãã®ï¼‘ )
  - $$n,r \leq 10^{18}, mod \leq 10^6$$ ç¨‹åº¦ã®å ´åˆã«è¨ˆç®—ã§ãã‚‹
- [ãã®ï¼’]( #ãã®ï¼’ )
  - $$n,r \leq 10^6, mod \leq 10^9$$ ç¨‹åº¦ã®å ´åˆã«è¨ˆç®—ã§ãã‚‹ 

***

## ãã®ï¼‘

init
- mod $$M$$ã‚’ä¸ãˆã‚‹ã¨ã€combã‚’å®Ÿè¡Œã™ã‚‹ã®ã«å¿…è¦ãªæ•°å€¤ã‚’å‰è¨ˆç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯ $$M$$ ã®ç´ å› æ•°åˆ†è§£ã‚’ $$ \prod_{i=1}^{\omega(M)}{ {p_i}^{e_i}} $$ ã¨ã™ã‚‹ã¨ $$ÎŸ( \sum_{i=1}^{\omega(M)}{ {p_i}^{e_i}} + \sqrt{M})$$
  - $$\omega(m)$$ ã¯ $$m$$ ã®ç´ å› æ•°ã®å€‹æ•°ã€$$m \leq 10^9$$ ã®ã¨ã $$\omega(m) \leq 10$$

composite_binomial_coefficient_1
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

comb
- æ•´æ•°$$n,r$$ã‚’ä¸ãˆã‚‹ã¨ã€$$\frac{n!}{r!(n-r)!}$$ã‚’$$M$$ã§å‰²ã£ãŸä½™ã‚Šã‚’è¿”ã™
- extensionã¯ãªã„ãŸã‚ã€$$n$$ ã«initã§ä¸ãˆãŸ $$N$$ ã‚ˆã‚Šå¤§ãã„å€¤ã‚’ä¸ãˆãŸå ´åˆã®æŒ™å‹•ã¯ä¿è¨¼ã—ãªã„
- è¨ˆç®—é‡ã¯$$ÎŸ( (\log n + \log M) \omega(M) )$$


```cpp
class composite_binomial_coefficient_1{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    long long Mod;    
    std::vector<std::array<long long,3>> P;
    std::vector<std::vector<long long>> fact,factinv;

    std::pair<long long,long long> bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair<long long,long long> D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(long long M){

        if(M<1){
            return;
        }

        Mod = M;

        //Mã‚’ç´ å› æ•°åˆ†è§£ã™ã‚‹
        //Pã¯{ç´ æ•°,å€‹æ•°,ç´ æ•°^å€‹æ•°}
        P.clear();
        long long m = M;
        for(int i=2;i*i<=m;i++){
            int v = 1;
            int e = 0;
            while(m%i==0){
                e++;
                m /= i;
                v *= i;
            }
            if(e>0){
                P.push_back({i,e,v});
            }
        }
        if(m!=1){
            P.push_back({m,1,m});
        }

        //ç”¨ã„ã‚‹ç´ æ•°pã«ã¤ã„ã¦ã€(x!)_p := (1~xã§pã¨äº’ã„ã«ç´ ãªã‚‚ã®ã®ç©)ã‚’æ±‚ã‚ã‚‹
        fact.clear();
        fact.resize(P.size());
        factinv.clear();
        factinv.resize(P.size());

        for(int i=0;i<(int)P.size();i++){
            fact[i].resize(P[i][2]);
            fact[i][0] = 1;
            for(int j=1;j<P[i][2];j++){
                if(j%P[i][0]==0){
                    fact[i][j] = fact[i][j-1];
                }else{
                    fact[i][j] = (fact[i][j-1]*j)%P[i][2];
                }
            }

            factinv[i].resize(P[i][2]);
            factinv[i][P[i][2]-1] = bezout(fact[i][P[i][2]-1],P[i][2]).first;
            if(factinv[i][P[i][2]-1]<0)factinv[i][P[i][2]-1] += P[i][2];
            
            for(int j=P[i][2]-2;j>=0;j--){
                if((j+1)%P[i][0]==0){
                    factinv[i][j] = factinv[i][j+1];
                }else{
                    factinv[i][j] = (factinv[i][j+1]*(j+1))%P[i][2];
                }
            }
        }
    }

    composite_binomial_coefficient_1(long long mod){
        init(mod);
    }

    long long comb(long long n,long long r){
        
        if(n<0 || r<0 || n<r || Mod==1){
            return 0;
        }
        long long k = n-r;

        //å„p^qã«ã¤ã„ã¦nCr mod p^qã‚’æ±‚ã‚ã¦Lã«ã¾ã¨ã‚ã‚‹
        std::vector<std::pair<long long,long long>> L(P.size());

        for(int i=0;i<(int)P.size();i++){
            long long p = P[i][0], q = P[i][1], pq = P[i][2];

            std::vector<long long> N,K,R;
            long long nown = n, nowk = k, nowr = r;
            while(nown>0){
                N.push_back(nown%pq);
                K.push_back(nowk%pq);
                R.push_back(nowr%pq);
                nown /= p;
                nowk /= p;
                nowr /= p;
            }

            long long e0 = 0, e1 = 0;
            nown = n/p, nowk = k/p, nowr = r/p;
            while(nown > 0){
                e0 += nown;
                e0 -= nowk;
                e0 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            nown = n/pq, nowk = k/pq, nowr = r/pq;
            while(nown > 0){
                e1 += nown;
                e1 -= nowk;
                e1 -= nowr;
                nown /= p;
                nowk /= p;
                nowr /= p;
            }
            
            long long T = 1;
            if((p!=2 || q<3) && e1%2 == 1){
                T = pq-1;
            }

            for(int j=0;j<(int)N.size();j++){
                T = (T*fact[i][N[j]])%pq;
                T = (T*factinv[i][K[j]])%pq;
                T = (T*factinv[i][R[j]])%pq;
            }

            for(int j=0;j<std::min(q,e0);j++){
                T = (T*p)%pq;
            }

            L[i] = {T,pq};
        }

        //ä¸­å›½å‰°ä½™å®šç†ã‚’ç”¨ã„ã¦å¾©å…ƒã™ã‚‹
        std::pair<long long,long long> C = L[0];
        for(int i=1;i<(int)P.size();i++){
            long long q = C.second*L[i].second;
            std::pair<long long,long long> u = bezout(C.second,L[i].second);
            long long c = (((C.first*L[i].second)%q)*u.second)%q;
            long long d = (((L[i].first*C.second)%q)*u.first)%q;
            C.first = (c+d+q)%q;
            C.second = q;
        }

        return C.first;
    }
};
```


### ä½¿ç”¨ä¾‹
***

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class composite_binomial_coefficient_1{/*çœç•¥*/};

int main(void){
    
    std::cout << "10ã§å‰²ã£ãŸã‚ã¾ã‚Š" << std::endl; 
    composite_binomial_coefficient_1 CBC(10);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;

    std::cout << "ã‚‚ã¨ã®å€¤" << std::endl;
    composite_binomial_coefficient_1 CBC_origin(1000);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC_origin.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
10ã§å‰²ã£ãŸã‚ã¾ã‚Š
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

ã‚‚ã¨ã®å€¤
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

```

### æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2023/03/18 | ä»»æ„modäºŒé …ä¿‚æ•°ã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [Library Checker](https://judge.yosupo.jp/problem/binomial_coefficient) | [æå‡º](https://judge.yosupo.jp/submission/130133) |

***


## ãã®ï¼’

init
- æ•´æ•°$$N$$ã¨mod $$M$$ã‚’ä¸ãˆã‚‹ã¨ã€combã‚’å®Ÿè¡Œã™ã‚‹ã®ã«å¿…è¦ãªæ•°å€¤ã‚’å‰è¨ˆç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯ $$ÎŸ(N \log N + N \omega(M) + \sqrt{M})$$
  - $$\omega(m)$$ ã¯ $$m$$ ã®ç´ å› æ•°ã®å€‹æ•°ã€$$m \leq 10^9$$ ã®ã¨ã $$\omega(m) \leq 10$$
<!-- âˆšM + NÏ‰(M) + Î©(N!) , ã‚‚ã£ã¨ã‚¿ã‚¤ãƒˆãªè©•ä¾¡ãŒã§ããã† -->

composite_binomial_coefficient_2
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

comb
- æ•´æ•°$$n,r$$ã‚’ä¸ãˆã‚‹ã¨ã€$$\frac{n!}{r!(n-r)!}$$ã‚’$$M$$ã§å‰²ã£ãŸä½™ã‚Šã‚’è¿”ã™
- extensionã¯ãªã„ãŸã‚ã€$$n$$ ã«initã§ä¸ãˆãŸ $$N$$ ã‚ˆã‚Šå¤§ãã„å€¤ã‚’ä¸ãˆãŸå ´åˆã®æŒ™å‹•ã¯ä¿è¨¼ã—ãªã„
- è¨ˆç®—é‡ã¯$$ÎŸ(\log M + \omega(M) )$$
  - ç‰¹ã«ã€ $$n,r$$ ã«ä¾å­˜ã—ãªã„


```cpp
class composite_binomial_coefficient_2{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int sze = 0;
    long long Mod;
    std::vector<long long> P;
    std::vector<long long> d,prime;
    std::vector<int> index;
    std::vector<long long> factPri;
    std::vector<std::vector<long long>> factRel;
    std::vector<std::vector<long long>> power;

    std::pair<long long,long long> bezout(long long a,long long b){
        if(b==0){
            return {1,0};
        }
        long long r = a%b, q = (a-r)/b;
        std::pair<long long,long long> D = bezout(b,r);
        return {D.second,D.first-q*D.second};
    }

    public:

    void init(int N,long long M){

        if(N<0 || M<1){
            return;
        }

        if(M==1){
            Mod = M;
            return;
        }

        sze = N+1;
        Mod = M;
        
        //1~Nã®éè‡ªæ˜ãªç´„æ•°ã‚’æ±‚ã‚ã‚‹
        d.resize(N+1);
        std::fill(d.begin(),d.end(),0);
        prime.clear();
        index.resize(N+1);
        std::fill(index.begin(),index.end(),-1);

        if(N>0){
            d[1] = 1;
        }
        for(long long i=2;i<=N;i++){
            if(d[i]==0){
                d[i]=i;
                prime.push_back(i);
            }
            for(int j=0;j<(int)prime.size() && prime[j]<=d[i] && i*prime[j]<=N ;j++){
                d[prime[j]*i]=prime[j];
            }
        }
        
        //æ³•ãŒå«ã‚€ç´ æ•°ã®ãƒªã‚¹ãƒˆã‚’æ±‚ã‚ã‚‹
        P.clear();
        for(int i=2;i*i<=M;i++){
            int e = 0;
            while(M%i==0){
                e++;
                M /= i;
            }
            if(e>0){
                if(i<=N)index[i] = P.size();
                P.push_back(i);
            }
        }
        if(M!=1){
            if(M<=N)index[M] = P.size();
            P.push_back(M);
        }

        //k!ã«ã¤ã„ã¦ã€Mã¨äº’ã„ã«ç´ ã§ã‚ã‚‹éƒ¨åˆ†ã¨ãã†ã§ãªã„éƒ¨åˆ†ã«åˆ†ã‘ã¦ãã‚Œãã‚Œæ±‚ã‚ã‚‹
        factPri.resize(N+1);
        std::fill(factPri.begin(),factPri.end(),1);
        factRel.resize(N+1);
        for(int i=0;i<=N;i++){
            factRel[i].resize(P.size());
            std::fill(factRel[i].begin(),factRel[i].end(),0);
        }

        for(int i=2;i<=N;i++){

            factPri[i] = factPri[i-1];
            factRel[i] = factRel[i-1];

            long long now = i;
            while(now>1){
                long long p = d[now];
                if(index[p]==-1){
                    factPri[i] = (factPri[i]*p)%Mod;
                }else{
                    factRel[i][index[p]]++;
                }
                now /= p;
            }
        }

        //p^0,p^1,...,p^(N/p)ã‚’å‰è¨ˆç®—ã™ã‚‹
        power.resize(P.size());
        for(int i=0;i<(int)P.size();i++){
            power[i].resize(1+N/P[i]);
            power[i][0] = 1;
            for(int j=1;j<1+N/P[i];j++){
                power[i][j] = (power[i][j-1]*P[i])%Mod;
            }
        }

    }

    composite_binomial_coefficient_2(int N,long long M){
        init(N,M);
    }

    long long comb(long long n,long long r){
        if(Mod==1){
            return 0;
        }
        if(n<0 || r<0 || n<r){
            return 0;
        }

        long long R = factPri[n];
        long long m = bezout(factPri[r],Mod).first;
        if(m<0)m+=Mod;
        R = (R*m)%Mod;
        m = bezout(factPri[n-r],Mod).first;
        if(m<0)m+=Mod;
        R = (R*m)%Mod;

        for(int i=0;i<(int)P.size();i++){
            int e = factRel[n][i] - factRel[r][i] - factRel[n-r][i];
            assert(e>=0);
            R = (R*power[i][e])%Mod;
        }

        return R;
    }

};
```


### ä½¿ç”¨ä¾‹
***

#### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class composite_binomial_coefficient_2{/*çœç•¥*/};

int main(void){
    
    std::cout << "10ã§å‰²ã£ãŸã‚ã¾ã‚Š" << std::endl; 
    composite_binomial_coefficient_2 CBC(8,10);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    std::cout << std::endl;

    std::cout << "ã‚‚ã¨ã®å€¤" << std::endl;
    composite_binomial_coefficient_2 CBC_origin(8,1000);
    for(int i=0;i<=8;i++){
        for(int j=0;j<=i;j++){
            std::cout << CBC_origin.comb(i,j) << " ";
        }std::cout << std::endl;
    }
    
    return 0;
}
```

#### å‡ºåŠ›
```
10ã§å‰²ã£ãŸã‚ã¾ã‚Š
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 0 0 5 1 
1 6 5 0 5 6 1 
1 7 1 5 5 1 7 1 
1 8 8 6 0 6 8 8 1 

ã‚‚ã¨ã®å€¤
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 

```

### æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2023/03/18 | ä»»æ„modäºŒé …ä¿‚æ•°ã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [ARC012-D](https://atcoder.jp/contests/arc012/tasks/arc012_4) | [æå‡º](https://atcoder.jp/contests/arc012/submissions/39798965) |

<div style="page-break-after: always;"></div>

# ğŸ”´ äºŒæ¬¡å…ƒé…åˆ—ã®å›è»¢ ğŸ”´

äºŒæ¬¡å…ƒé…åˆ—$$A$$ã‚’ä¸ãˆã‚‹ã¨ã€$$A$$ã‚’åæ™‚è¨ˆå›ã‚Šã«å›è»¢ã•ã›è¿”ã™

ç¬¬äºŒå¤‰æ•°ã‚’$$true$$ã«ã™ã‚‹ã¨æ™‚è¨ˆå›ã‚Šã«å›è»¢ã•ã›ã‚‹

ã‚‚ã—$$A[i]$$ã®é•·ã•ãŒæƒã£ã¦ã„ãªã„å ´åˆã¯æœ€ã‚‚é•·ã„ã‚‚ã®ã«åˆã‚ã›ã€è¶³ã‚Šãªã„éƒ¨åˆ†ã¯ç¬¬ä¸‰å¤‰æ•°ã®å€¤(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯$$0$$)ã§åŸ‹ã‚ã‚‹

è¨ˆç®—é‡ã¯é…åˆ—ã‚’$$N$$è¡Œ$$M$$åˆ—ã¨ã—ã¦$$ÎŸ(NM)$$

[github]()

```cpp
std::vector<std::vector<char>> vector2D_rotate(std::vector<std::vector<char>> A,bool clockwise=false,char leading = 0){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int N = A.size();
    if(N==0)return A;
    
    int M = 0;
    for(int i=0;i<N;i++){
        M = std::max(M,(int)A[i].size());
    }
    
    std::vector<std::vector<char>> B(M,std::vector<char>(N,leading));
    
    for(int i=0;i<N;i++){
        for(int j=0;j<A[i].size();j++){
            if(clockwise){
                B[j][N-1-i]=A[i][j];
            }else{
                B[M-1-j][i]=A[i][j];
            }
        }
    }
    
    return B;
}
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<std::vector<char>> vector2D_rotate(std::vector<std::vector<char>> A,bool clockwise=false,char leading = 0){/*çœç•¥*/}

int main(){
    
    std::vector<std::vector<char>> A ={
        {'a','b','c'},
        {'d','e','f'},
        {'g','h','i'}
    };
    
    std::cout << "å›è»¢ãªã—" << std::endl;
    for(int i=0;i<A.size();i++){
        for(int j=0;j<A[i].size();j++){
            std::cout << A[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<std::vector<char>> counter = vector2D_rotate(A);
    
    std::cout << "åæ™‚è¨ˆå›ã‚Š" << std::endl;
    for(int i=0;i<counter.size();i++){
        for(int j=0;j<counter[i].size();j++){
            std::cout << counter[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<std::vector<char>> clockwise = vector2D_rotate(A,true);
    
    std::cout << "æ™‚è¨ˆå›ã‚Š" << std::endl;
    for(int i=0;i<clockwise.size();i++){
        for(int j=0;j<clockwise[i].size();j++){
            std::cout << clockwise[i][j] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### å‡ºåŠ›
```
å›è»¢ãªã—
a b c 
d e f 
g h i 

åæ™‚è¨ˆå›ã‚Š
c f i 
b e h 
a d g 

æ™‚è¨ˆå›ã‚Š
g d a 
h e b 
i f c
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/09/12 | äºŒæ¬¡å…ƒé…åˆ—ã®å›è»¢ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸® ğŸ”´

æ–‡å­—åˆ—$$S$$ã‚’ä¸ãˆã‚‹ã¨ã€$$S$$ã‚’ãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸®(é€£é•·åœ§ç¸®)ã—ã¦è¿”ã™

ãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸®ã¨ã¯ã€æ–‡å­—åˆ—ã‚’ã€Œæ–‡å­—ã¨ã€ãã‚ŒãŒã„ãã¤ç¶šãã‹ã€ã®çµ„ã«å¤‰æ›ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹
ã¡ãªã¿ã«å¯é€†å¤‰æ›

è¨ˆç®—é‡ã¯$$ÎŸ(\vert S \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/runlength%20encode.cpp)

```cpp
std::vector<std::pair<char,int>> runlength_encode(std::string S){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<std::pair<char,int>> R;
    for(int i=0;i<(int)S.size();i++){
        if(i==0 || S[i]!=S[i-1]){
            R.push_back({S[i],1});
        }else{
            R.back().second++;
        }
    }
    return R;
}
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<std::pair<char,int>> runlength_encode(std::string S){/*çœç•¥*/}

int main(void){
    
    std::string S = "abbcccddeeeacddd";
    std::vector<std::pair<char,int>> R = runlength_encode(S);
    for(int i=0;i<(int)R.size();i++){
        std::cout << R[i].first << " " << R[i].second << std::endl;
    }
    
    return 0;
}
```

### å‡ºåŠ›
```
a 1
b 2
c 3
d 2
e 3
a 1
c 1
d 3
```

## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2022/07/10 | ãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸®ã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [ABC259-C](https://atcoder.jp/contests/abc259/tasks/abc259_c) | [æå‡º](https://atcoder.jp/contests/abc259/submissions/33129519) |

<div style="page-break-after: always;"></div>

# ğŸ”´ åè§’ã‚½ãƒ¼ãƒˆ ğŸ”´

æ•°åˆ—$$A$$ã‚’ä¸ãˆã‚‹ã¨ã€ä»¥ä¸‹ã®ä¸¦ã¹æ–¹ã§$$A$$ã‚’ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã™
åŸºæº–ã‚’ç¬¬äºŒå¤‰æ•°$$d$$(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯$$(1,0)$$)ã§å®šã‚ã‚‹ã“ã¨ã‚‚ã§ãã‚‹

- åè§’(ã®ã†ã¡ã€$$[\arg(d),\arg(d)+2\pi)$$ã§ã‚ã‚‹ã‚‚ã®)ãŒå°ã•ã„é †ã«ä¸¦ã¹ã‚‹
- ãã‚ŒãŒåŒã˜å ´åˆã€çµ¶å¯¾å€¤ãŒå°ã•ã„é †ã«ä¸¦ã¹ã‚‹
- $$(0,0)$$ãŒå«ã¾ã‚Œã‚‹å ´åˆassertã—ã¦åœæ­¢ã™ã‚‹


è¨ˆç®—é‡ã¯$$ÎŸ(\vert A \vert log \vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/arg%20sort.cpp)

```cpp
std::vector<std::pair<long long,long long>> arg_sort(std::vector<std::pair<long long,long long>> A,std::pair<long long,long long> d = {1,0}){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    long long N = A.size();
    assert(d.first != 0 || d.second != 0);
    long long g = std::gcd(d.first,d.second);
    d.first/=g;d.second/=g;
    A.push_back(d);
    std::sort(A.begin(),A.end(),[&](std::pair<long long,long long> x, std::pair<long long,long long> y){
        assert(x.first != 0 || x.second != 0);
        assert(y.first != 0 || y.second != 0);
        
        long long a,b;
        if(x.first>0 && x.second==0){
            a=0;
        }else if(x.first>0 && x.second>0){
            a=1;
        }else if(x.first==0 && x.second>0){
            a=2;
        }else if(x.first<0 && x.second>0){
            a=3;
        }else if(x.first<0 && x.second==0){
            a=4;
        }else if(x.first<0 && x.second<0){
            a=5;
        }else if(x.first==0 && x.second<0){
            a=6;
        }else{
            a=7;
        }
        
        if(y.first>0 && y.second==0){
            b=0;
        }else if(y.first>0 && y.second>0){
            b=1;
        }else if(y.first==0 && y.second>0){
            b=2;
        }else if(y.first<0 && y.second>0){
            b=3;
        }else if(y.first<0 && y.second==0){
            b=4;
        }else if(y.first<0 && y.second<0){
            b=5;
        }else if(y.first==0 && y.second<0){
            b=6;
        }else{
            b=7;
        }
        
        if(a!=b){
            return (a<b);
        }
        
        if(a%2==0){
            return (std::abs(x.first+x.second) < std::abs(y.first+y.second));
        }
        
        if(y.first*x.second != x.first*y.second){
           return (y.first*x.second < x.first*y.second);
        }
        
        return abs(x.first) < abs(y.first);
    });
    
    std::vector<std::pair<long long,long long>> B(N);
    for(int i=0;i<N+1;i++){
        if(A[i]==d){
            for(int j=i+1;j<N+1;j++){
                B[j-i-1]=A[j];
            }
            for(int j=0;j<i;j++){
                B[N-i+j]=A[j];
            }
            break;
        }
    }
    
    return B;
}
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>


std::vector<std::pair<long long,long long>> arg_sort(std::vector<std::pair<long long,long long>> A,std::pair<long long,long long> d = {1,0}){/*çœç•¥*/}


int main(void){
    
    long long N = 12;
    
    std::vector<std::pair<long long,long long>> A={
        {-3,0},
        {-1,-2},
        {1,2},
        {0,-3},
        {3,0},
        {-2,-1},
        {-2,1},
        {1,-2},
        {2,1},
        {2,-1},
        {0,3},
        {-1,2}
    };
    
    //Aã‚’(1,0)ã‚’åŸºæº–ã«ã‚½ãƒ¼ãƒˆ
    A = arg_sort(A);
    for(int i=0;i<N;i++){
        std::cout << "(" << A[i].first << "," << A[i].second << ")" << " "; 
    }
    std::cout << std::endl;
    
    //Aã‚’(-1,1)ã‚’åŸºæº–ã«ã‚½ãƒ¼ãƒˆ
    A = arg_sort(A,{-1,1});
    for(int i=0;i<N;i++){
        std::cout << "(" << A[i].first << "," << A[i].second << ")" << " "; 
    }
    std::cout << std::endl;
    
    return 0;
}

```

### å‡ºåŠ›
```
(3,0) (2,1) (1,2) (0,3) (-1,2) (-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) 
(-2,1) (-3,0) (-2,-1) (-1,-2) (0,-3) (1,-2) (2,-1) (3,0) (2,1) (1,2) (0,3) (-1,2) 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/11/01 | ãƒã‚°ã‚’ä¿®æ­£ |
| 2021/10/31 | åè§’ã‚½ãƒ¼ãƒˆã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ åå¾©å†™åƒ ğŸ”´

init
- æ•°åˆ—$$F$$ã‚’ä¸ãˆã‚‹ã¨ã€ã™ã¹ã¦ã®æ•´æ•° $$x (0 \leq x < \vert F \vert)$$ ã«ã¤ã„ã¦ $$f(x) = F[x]$$ ã¨ãªã‚‹ã‚ˆã†ã«é–¢æ•° $$f$$ ã‚’è¨­å®šã™ã‚‹ 
- è¨ˆç®—é‡ã¯$$N=\vert F \vert$$ã¨ã—ã€$$ÎŸ(N)$$

iterated_function
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

solve
- æ•´æ•° $$x$$ ã§ã‚ã£ã¦$$0 \leq x < N$$ ã‚’æº€ãŸã™ã‚ˆã†ãªã‚‚ã®ã¨éè² æ•´æ•° $$ k $$ ã‚’ä¸ãˆã‚‹ã¨ã€$$\overbrace{f(f(\cdots f}^{k}(x)))$$ ã‚’æ±‚ã‚ã€è¿”ã™
- ã‚‚ã—$$k = 0$$ãªã‚‰$$x$$ãã®ã‚‚ã®ã‚’è¿”ã™
- ç¯„å›²å¤–ãªã‚‰$$-1$$ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(N \log k)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/iterated%20function.cpp)

```cpp
class iterated_function{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> T[64];
    int N;
    
    public:
    void init(std::vector<int> F){
        N = F.size();
        T[0] = F;
        for(int j=1;j<64;j++){
            T[j].resize(N);
            for(int i=0;i<N;i++){
                T[j][i] = T[j-1][T[j-1][i]];
            }
        }
        
    }

    iterated_function(std::vector<int> F){
        init(F);
    }

    int solve(int x,long long k){
        if(!(0<=x && x<N) || k<0){
            return -1;
        }

        int y = x;
        for(int i=0;(k>>i)>0;i++){
            if((k>>i)%2==1){
                y = T[i][y];
            }
        }

        return y;
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class iterated_function{/*çœç•¥*/};

int main() {
    
    std::vector<int> F = {1,2,3,4,5,2};
    iterated_function func(F);

    std::cout << "0ã‹ã‚‰kå›è¾¿ã£ãŸã¨ãã®é ‚ç‚¹" << std::endl;
    for(int k=0;k<=15;k++){
        std::cout << func.solve(0,k) << " ";
    }
    std::cout << std::endl << std::endl;

    std::cout << "å„é ‚ç‚¹ã‹ã‚‰3å›è¾¿ã£ãŸã¨ãã®é ‚ç‚¹" << std::endl;
    for(int i=0;i<6;i++){
        std::cout << func.solve(i,3) << " ";
    }
    std::cout << std::endl;
    
}
```

### å‡ºåŠ›
```
0ã‹ã‚‰kå›è¾¿ã£ãŸã¨ãã®é ‚ç‚¹
0 1 2 3 4 5 2 3 4 5 2 3 4 5 2 3 

å„é ‚ç‚¹ã‹ã‚‰3å›è¾¿ã£ãŸã¨ãã®é ‚ç‚¹
3 4 5 2 3 4 
```

## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2022/07/03 | åå¾©å†™åƒã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d) | [æå‡º](https://atcoder.jp/contests/abc167/submissions/32945330) |

<div style="page-break-after: always;"></div>

# ğŸ”´ ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤ ğŸ”´

æ•°åˆ—$$A$$ã¨æ•´æ•°$$K$$ã‚’ä¸ãˆã‚‹ã¨ã€ä»¥ä¸‹ã®æ•°å¼ã‚’æº€ãŸã™è¦ç´ æ•°ãŒ$$\vert A \vert -K+1$$ã®æ•°åˆ—$$R$$ã‚’æ§‹æˆã—ã€è¿”ã™

$$R_i = min(A_i , A_{i+1} , ... , A_{i+K-1})$$


è¨ˆç®—é‡ã¯$$O(\vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/slide%20minimum.cpp)

```cpp
std::vector<long long> slide_minimum(std::vector<long long> A,int K){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    std::vector<long long> R;
    int N = A.size();
    std::deque<int> D;
    for(int i=0;i<N;i++){
        while(!D.empty() && A[D.back()]>=A[i]){D.pop_back();}
        D.push_back(i);
        if(i-K+1>=0){
            R.push_back(A[D.front()]);
            if(D.front()==i-K+1){
                D.pop_front();
            }
        }
    }
    return R;
}
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<long long> slide_minimum(std::vector<long long> A,int K){/*çœç•¥*/}

int main(void){
    
    std::vector<long long> A = {3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3},B;
    long long K = 3;
    
    B = slide_minimum(A,K);
    for(int i=0;i<B.size();i++){
        std::cout << B[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
1 1 1 1 2 2 2 3 3 3 5 7 7 3 2 2 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2020/04/23 | ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤ã‚’è¿½åŠ  |


<div style="page-break-after: always;"></div>

# ğŸ”´ åº§æ¨™åœ§ç¸® ğŸ”´

init
- æ•°åˆ—$$A$$ã‚’ä¸ãˆã‚‹ã¨ã€ã‚¯ãƒ©ã‚¹ã‚’$$A$$ã§åˆæœŸåŒ–ã™ã‚‹
- ã“ã®ã¨ãã€$$A$$ã®å…¨ã¦ã®$$2$$ã¤ã®è¦ç´ ã«ã¤ã„ã¦å¤§å°é–¢ä¿‚ãŒç¶­æŒã•ã‚Œã€ã‹ã¤indexã®æœ€å¤§å€¤ãŒæœ€å°ã«ãªã‚‹ã‚ˆã†ã«$$A$$ã®å„è¦ç´ ã«indexã¨ã„ã†éè² æ•´æ•°ãŒå‰²ã‚ŠæŒ¯ã‚‰ã‚Œã‚‹
- è¨ˆç®—é‡ã¯$$N=\vert A \vert$$ã¨ã—ã€$$ÎŸ(NlogN)$$

compress
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

size
- initã§ä¸ãˆã‚‰ã‚ŒãŸæ•°åˆ—ã®ä¸­ã«å«ã¾ã‚Œã‚‹å€¤ã®ç¨®é¡æ•°ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(1)$$

index
- å€¤ã‚’ä¸ãˆã‚‹ã¨ã€ãã®å€¤ã«å¯¾å¿œã™ã‚‹indexã‚’è¿”ã™
- ã‚‚ã—æ•°åˆ—ã«å­˜åœ¨ã—ãªã„å€¤ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€æ•°åˆ—ã«å­˜åœ¨ã™ã‚‹å€¤ã®ä¸­ã§ã€ä¸ãˆã‚‰ã‚ŒãŸå€¤ã‚ˆã‚Šå°ã•ã„æœ€å¤§ã®å€¤ã«ã¤ã„ã¦ã®indexã‚’è¿”ã™(ã¤ã¾ã‚Šã€å°ã•ã„å€¤ã«å¯„ã›ã‚‹)
- ã‚‚ã—åˆ—ã®ã„ã‹ãªã‚‹å€¤ã‚ˆã‚Šã‚‚å°ã•ã‘ã‚Œã°$$-1$$ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯initã®$$N$$ã‚’ç”¨ã„ã¦ã€$$ÎŸ(logN)$$

value
- indexã‚’ä¸ãˆã‚‹ã¨å€¤ã‚’è¿”ã™
- ç¯„å›²å¤–ãªã‚‰$$0$$ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/coordinate%20compression.cpp)

```cpp
class compress{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> E;
    
    public:
    void init(std::vector<long long> A){
        E.clear();
        sort(A.begin(),A.end());
        for(int i=0;i<A.size();i++){
            if(i==0 || A[i]!=A[i-1]){
                E.push_back(A[i]);
            }
        }
    }
    
    compress(std::vector<long long> A){
        init(A);
    }
    
    int size(){
        return (int)E.size();
    }
    
    int value(int x){
        if(0<=x && x<(int)E.size()){
            return E[x];
        }else{
            return 0;
        }
    }
    
    int index(int X){
        return (upper_bound(E.begin(),E.end(),X))-E.begin()-1;
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class compress{/*çœç•¥*/};

int main(void){
    
    std::vector<long long> A={1,2,4,8,16,32,64,128};
    compress zaatsu(A);
    
    std::cout << "uniqueãªè¦ç´ ã®å€‹æ•°" << std::endl;
    std::cout << zaatsu.size() << std::endl;
    std::cout << std::endl;
    
    std::cout << "Aã®å„è¦ç´ ã«å¯¾å¿œã™ã‚‹æ•°" << std::endl;
    for(int i=0;i<A.size();i++){
        std::cout << zaatsu.index(A[i]) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "0~7ã«å¯¾å¿œã™ã‚‹è¦ç´ " << std::endl;
    for(int i=0;i<zaatsu.size();i++){
        std::cout << zaatsu.value(i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
uniqueãªè¦ç´ ã®å€‹æ•°
8

Aã®å„è¦ç´ ã«å¯¾å¿œã™ã‚‹æ•°
0 1 2 3 4 5 6 7 

0~7ã«å¯¾å¿œã™ã‚‹è¦ç´ 
1 2 4 8 16 32 64 128 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2020/05/20 | mapã§å‡¦ç†ã—vectorã§è¿”ã™å½¢å¼ã‹ã‚‰ã€classåŒ–ã—äºŒåˆ†æ¢ç´¢ã‚’è¡Œã†å½¢å¼ã«å¤‰æ›´ |
| 2020/04/05 | åº§æ¨™åœ§ç¸®ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ— ğŸ”´

æ•°åˆ—$$A$$ã‚’ä¸ãˆã‚‹ã¨ã€$$A$$ã®æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—ã®é•·ã•ã‚’æ±‚ã‚ã€long longã§è¿”ã™


è¨ˆç®—é‡ã¯$$ÎŸ(\vert A \vert log \vert A \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/longest%20increasing%20subsequence.cpp)

```cpp
long long LIS(std::vector<long long> A){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int N=A.size();
    std::vector<long long> D;
    for(int i=0;i<N;i++){
        int pos=distance(D.begin(),lower_bound(D.begin(), D.end(),A[i]));
        if(pos==D.size()){
            D.push_back(A[i]);
        }else{
            D[pos]=A[i];
        }
    }
    return D.size();
}
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

long long LIS(std::vector<long long> A){/*çœç•¥*/}

int main(void){
    
    std::vector<long long> A={1,4,2,5,3},B={5,3,1,4,2};
    std::cout << LIS(A) << std::endl;
    std::cout << LIS(B) << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
3
2
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2020/04/05 | æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ Moã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  ğŸ”´

ã™ã‚‚ã‚‚ã‚‚ã‚‚ã‚‚ã‚‚ã‚‚ã‚‚ã®ã†ã¡

ã„ãã¤ã‹ã®åŠé–‹åŒºé–“ $$[l_i,r_i)$$ ã«ã¤ã„ã¦ã®ç­”ãˆã‚’é«˜é€Ÿã«æ±‚ã‚ã‚‹
$$[l,r)$$ ã§ã®ç­”ãˆãŒã‚ã‹ã£ã¦ã„ã‚‹ã¨ãã€éš£æ¥ã™ã‚‹åŒºé–“ $$[l-1,r),[l+1,r),[l,r-1),[l,r+1)$$ ã«ã¤ã„ã¦ã®ç­”ãˆãŒé«˜é€Ÿã«ã‚ã‹ã‚‹å ´åˆã«æœ‰åŠ¹

ç¬¬ä¸€å¼•æ•°ã«åŒºé–“å…¨ä½“ã®é•·ã• $$N$$ ã€ç¬¬äºŒå¼•æ•°ã«ã‚¯ã‚¨ãƒªã®æ•° $$Q$$ ã€ç¬¬ä¸‰å¼•æ•°ã«ã‚¯ã‚¨ãƒªã®ãƒªã‚¹ãƒˆã€ãã—ã¦ç¬¬å››ï½ç¬¬ä¸ƒå¼•æ•°ã«ã¯ãã‚Œãã‚Œ
- $$[l,r)$$ ã®ç­”ãˆã‹ã‚‰ $$[l-1,r)$$ ã®ç­”ãˆã‚’æ±‚ã‚ã‚‹é–¢æ•°
- $$[l,r)$$ ã®ç­”ãˆã‹ã‚‰ $$[l+1,r)$$ ã®ç­”ãˆã‚’æ±‚ã‚ã‚‹é–¢æ•°
- $$[l,r)$$ ã®ç­”ãˆã‹ã‚‰ $$[l,r-1)$$ ã®ç­”ãˆã‚’æ±‚ã‚ã‚‹é–¢æ•°
- $$[l,r)$$ ã®ç­”ãˆã‹ã‚‰ $$[l,r+1)$$ ã®ç­”ãˆã‚’æ±‚ã‚ã‚‹é–¢æ•°

ã‚’ä¸ãˆã‚‹ã¨ã€å„ã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã®ç­”ãˆã‚’vectorã§è¿”ã™

è¨ˆç®—é‡ã¯ç¬¬å››ï½ç¬¬ä¸ƒå¼•æ•°ã§ä¸ãˆãŸé–¢æ•°ã®è¨ˆç®—é‡ã‚’ $$f$$ ã¨ã™ã‚‹ã¨ $$ÎŸ(Q \log Q + N \sqrt{Q} f)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/mos-algorithm.cpp)

```cpp
std::vector<long long> Mo(int N,int Q,std::vector<std::pair<int,int>> X, 
std::function<void(int,long long&)> lm, std::function<void(int,long long&)> lp, 
std::function<void(int,long long&)> rm, std::function<void(int,long long&)> rp){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int rQ;
    std::map<std::pair<int,int>,std::vector<int>> index;
    std::vector<int> block(N,0);
    std::vector<long long> Ans(Q);

    std::function<bool(std::pair<int,int>, std::pair<int,int>)> comp = [&](std::pair<int,int> A,std::pair<int,int> B){
        if(block[A.first]!=block[B.first]){
            return (block[A.first]<block[B.first]);
        }
        if(A.second != B.second){
            return (A.second < B.second);
        }
        return (A.first < B.first);
    };

    for(int i=0;i<Q;i++){
        index[X[i]].push_back(i+1);
    }
    int q = index.size();

    rQ = 1;
    while((rQ+1)*(rQ+1)<=q)rQ++;

    int now = 0;
    for(int i=0;i<rQ-1;i++){
        now += ((N+rQ-1-i)/rQ);
        block[now]++;
    }
    for(int i=0;i<N-1;i++){
        block[i+1] += block[i];
    }

    std::vector<std::pair<int,int>> Y(q);
    now = 0;
    for(auto e:index){
        Y[now] = e.first;
        now++;
    }

    std::sort(Y.begin(),Y.end(),[&](auto a, auto b){return comp(a, b);});

    int L = 0,R = 0;
    long long Result = 0;

    for(int i=0;i<q;i++){
        
        while(Y[i].first < L){
            lm(L,Result);
            L--;
        }
        while(R < Y[i].second){
            rp(R,Result);
            R++;
        }
        while(L < Y[i].first){
            lp(L,Result);
            L++;
        }
        while(Y[i].second < R){
            rm(R,Result);
            R--;
        }

        for(int k:index[Y[i]]){
            Ans[k-1] = Result;
        }

    }

    return Ans;

    //lm(i): [i,r)ã‚’[i-1,r)ã«ã™ã‚‹
    //lp(i): [i,r)ã‚’[i+1,r)ã«ã™ã‚‹
    //rm(i): [i,r)ã‚’[i,r-1)ã«ã™ã‚‹
    //rp(i): [i,r)ã‚’[i,r+1)ã«ã™ã‚‹

}
```


## ä½¿ç”¨ä¾‹
***

<br>
$$A = (1,2,3,4,5)$$ ã® $$[l,r)$$ ã®å’Œã‚’æ±‚ã‚ã‚‹

ã“ã‚Œã¯ $$[l,r)$$ ã®å’ŒãŒã‚ã‹ã£ã¦ã„ã‚Œã° $$[l-1,r),[l+1,r),[l,r-1),[l,r+1)$$ ã®å’ŒãŒ $$O(1)$$ ã§ã‚ã‹ã‚‹\\
ä¾‹ãˆã° $$[1,3)$$ ã®å’ŒãŒ $$A_1 + A_2 = 2 + 3 = 5$$ ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã£ã¦ã„ã‚Œã° $$[1,4)$$ ã®å’Œã¯ $$5 + A_3 = 5 + 4 = 9$$ ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹


### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<long long> Mo(int N,int Q,std::vector<std::pair<int,int>> X, 
std::function<void(int,long long&)> lm, std::function<void(int,long long&)> lp, 
std::function<void(int,long long&)> rm, std::function<void(int,long long&)> rp){/*çœç•¥*/}

int main(void){
    
    int N = 5, Q = 15;
    std::vector<long long> A = {1,2,3,4,5};
    std::vector<std::pair<int,int>> LR = {
        {0,1},
        {0,2},
        {0,3},
        {0,4},
        {0,5},
        {1,2},
        {1,3},
        {1,4},
        {1,5},
        {2,3},
        {2,4},
        {2,5},
        {3,4},
        {3,5},
        {4,5},
    };
    
    std::function<void(int,long long&)> lm = [&](int i,long long& res){
        res += A[i-1];
    };

    std::function<void(int,long long&)> lp = [&](int i,long long& res){
        res -= A[i];
    };

    std::function<void(int,long long&)> rm = [&](int i,long long& res){
        res -= A[i-1];
    };

    std::function<void(int,long long&)> rp = [&](int i,long long& res){
        res += A[i];
    };


    std::vector<long long> Ans = Mo(N,Q,LR,lm,lp,rm,rp);

    for(int i=0;i<(int)Ans.size();i++){
        std::cout << "[" << LR[i].first << "," << LR[i].second << ")  " << Ans[i] << std::endl;
    }

    return 0;
}
```

### å‡ºåŠ›
```
[0,1)  1
[0,2)  3
[0,3)  6
[0,4)  10
[0,5)  15
[1,2)  2
[1,3)  5
[1,4)  9
[1,5)  14
[2,3)  3
[2,4)  7
[2,5)  12
[3,4)  4
[3,5)  9
[4,5)  5

```

## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2023/03/13 | Moã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [ABC293-G](https://atcoder.jp/contests/abc293/tasks/abc293_g) | [æå‡º](https://atcoder.jp/contests/abc293/submissions/39690323) |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒãƒƒã‚·ãƒ¥ ğŸ”´

MOD $$2^{61}-1$$ã¨$$2$$åŸºåº•ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€€[ä¾‹ã®è¨˜äº‹](https://trap.jp/post/900/)ã¯ã„ã£ãŸã„ï½¥ï½¥ï½¥<br>
åŸºåº•ã¯ã‚³ãƒ¼ãƒ‰ä¸­ã®Baseã‚’ç›´ã«ã„ã˜ã‚Œã°å¤‰æ›´ã§ãã¾ã™ ã“ã“ã‚µãƒãƒ¼ãƒˆã—ãŸæ–¹ãŒã„ã„ã®ã‹ãªï¼Ÿ


init
- ~~æ–‡å­—åˆ—~~ long longã®vector $$S$$ ã‚’ä¸ãˆã‚‹ã¨ã€å‰è¨ˆç®—ã¨ã—ã¦$$S$$ã‚’ãƒãƒƒã‚·ãƒ¥ã™ã‚‹ä»–ã€getã®è¨ˆç®—ã§ä½¿ç”¨ã™ã‚‹æ•°å€¤ã‚’è¨ˆç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯åŸºåº•ã®æ•°ã‚’$$b$$ã¨ã—ã¦ã€$$ÎŸ(b\vert S \vert)$$

rollinghash
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

get
- åŠé–‹åŒºé–“$$[l,r)$$ã‚’ä¸ãˆã‚‹ã¨ã€$$S$$ã®$$[l,r)$$æ–‡å­—ç›®ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯åŸºåº•ã®æ•°ã‚’$$b$$ã¨ã—ã¦ã€$$ÎŸ(b)$$

instant
- ~~æ–‡å­—åˆ—~~ long longã®vector $$P$$ã‚’ä¸ãˆã‚‹ã¨ã€initã«ä¸ãˆãŸ$$S$$ã¨ã¯é–¢ä¿‚ãªã$$P$$ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã—è¿”ã™
- ãŸã è¿”ã™ã ã‘ã§ã€initã§æƒãˆãŸæƒ…å ±ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ãªã„
- è¨ˆç®—é‡ã¯åŸºåº•ã®æ•°ã‚’$$b$$ã¨ã—ã¦ã€$$ÎŸ(b\vert P \vert)$$

connect
- ~~æ–‡å­—åˆ—~~ long longã®vector $$P,Q$$ ã®ãƒãƒƒã‚·ãƒ¥çµæœã¨åˆ—ã®é•·ã•ã‚’ä¸ãˆã‚‹ã¨ã€initã«ä¸ãˆãŸ$$S$$ã¨ã¯é–¢ä¿‚ãªã$$P,Q$$ã®çµåˆvector$$P+Q$$ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã—è¿”ã™
- ãŸã è¿”ã™ã ã‘ã§ã€initã§æƒãˆãŸæƒ…å ±ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ãªã„
- è¨ˆç®—é‡ã¯åŸºåº•ã®æ•°ã‚’$$b$$ã€$$P$$ã®é•·ã•ã‚’$$p$$ã¨ã—ã¦ã€$$ÎŸ(b \log{p})$$


[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/rollinghash.cpp)

```cpp
class rollinghash{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    static constexpr long long mod = (1LL << 61)-1;
    std::vector<long long> Base = {12345,10000000};
    std::vector<long long> BaseInv;
    std::vector<std::vector<long long>> BaseInvExp;
    static constexpr long long h = 100;
    
    long long product(long long a,long long b){
        static constexpr long long m = 1LL << 31;
        long long a1 = a/m,a2 = a%m;
        long long b1 = b/m,b2 = b%m;
        
        long long r = 0 , s;
        r = (r + 2*a1*b1) % mod;
        s = (a1*b2 + b1*a2) % mod;
        long long s1 = s/m,s2 = s%m;
        s = (2*s1+m*s2) % mod;
        r = (r + s) % mod;
        r = (r + a2*b2) % mod;
        
        return r;
    }
    
    long long power(long long b,long long e){
        long long r=1;
        while(e){
            if(e&1){
                r=product(r,b)%mod;
            }
                b=product(b,b)%mod;
                e >>=1;
        }
        return r;
    }
    
    public:
    std::vector<long long> S;
    std::vector<std::vector<long long>> H,Hsum;
    
    void init(std::vector<long long> cs){
        S=cs;
        int n=S.size();
        
        BaseInv.resize(Base.size());
        BaseInvExp.resize(Base.size());
        H.resize(Base.size());
        Hsum.resize(Base.size());
        for(int i=0;i<(int)Base.size();i++){
            BaseInvExp[i].assign(n+1,1);
            H[i].assign(n+1,0);
            Hsum[i].assign(n+1,0);
        }
        
        //é€†å…ƒ
        for(int i=0;i<(int)Base.size();i++){
            BaseInv[i]=power(Base[i],mod-2);
        }
        for(int i=0;i<(int)Base.size();i++){
            for(int j=0;j<n;j++){
                BaseInvExp[i][j+1] = product(BaseInvExp[i][j],BaseInv[i]);
            }
        }
        
        //æœ¬ä½“
        for(int i=0;i<(int)Base.size();i++){
            long long b=1;
            for(int j=0;j<n;j++){
                H[i][j]=product(b,S[j]+h);
                b=product(b,Base[i]);
            }
        }
        
        //ç´¯ç©å’Œ
        for(int i=0;i<(int)Base.size();i++){
            for(int j=0;j<n;j++){
                Hsum[i][j+1]=(Hsum[i][j]+H[i][j])%mod;
            }
        }
    }
    
    rollinghash(std::vector<long long> C){
        init(C);
    }
    
    std::vector<long long> get(int l,int r){
        std::vector<long long> R(Base.size());
        for(int i=0;i<(int)Base.size();i++){
            long long g = (Hsum[i][r]-Hsum[i][l]+mod)%mod;
            g=product(g,BaseInvExp[i][l]);
            R[i] = g;
        }
        return R;
    }
    
    std::vector<long long> instant(std::vector<long long> P){
        std::vector<long long> R;
        for(int i=0;i<(int)Base.size();i++){
            long long r = 0, b = 1;
            for(int j=0;j<(int)P.size();j++){
                r = (r+product(b,P[j]+h))%mod;
                b = product(b,Base[i]);
            }
            R.push_back(r);
        }
        return R;
    }
    
    std::vector<long long> connect(std::vector<long long> P,long long ps,std::vector<long long> Q,long long qs){
        std::vector<long long> R;
        for(int i=0;i<(int)Base.size();i++){
            long long r = (product(Q[i],power(Base[i],ps))+P[i])%mod;
            R.push_back(r);
        }
        return R;
        assert(qs==qs);
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class rollinghash{/*çœç•¥*/};

int main() {
    
    rollinghash rolihash({'a','b','c','a','b'});
    
    std::cout << "\"abcab\"ã®[0,2)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š\"ab\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> a = rolihash.get(0,2);
    for(int i=0;i<a.size();i++){
        std::cout << a[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"abcab\"ã®[1,4)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š\"bca\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> b = rolihash.get(1,4);
    for(int i=0;i<b.size();i++){
        std::cout << b[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"abcab\"ã®[3,5)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š\"ab\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> c = rolihash.get(3,5);
    for(int i=0;i<c.size();i++){
        std::cout << c[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"bc\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> d = rolihash.instant({'b','c'});
    for(int i=0;i<d.size();i++){
        std::cout << d[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "\"a\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> e = rolihash.instant({'a'});
    for(int i=0;i<e.size();i++){
        std::cout << e[i] << " ";
    }
    std::cout << std::endl << std::endl;

    std::cout << "\"bc\"ã¨\"a\"ã®çµåˆã€ã¤ã¾ã‚Š\"bca\"ã®ãƒãƒƒã‚·ãƒ¥å€¤" << std::endl;
    std::vector<long long> f = rolihash.connect(d,2,e,1);
    for(int i=0;i<f.size();i++){
        std::cout << f[i] << " ";
    }
    std::cout << std::endl << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
"abcab"ã®[0,2)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š"ab"ã®ãƒãƒƒã‚·ãƒ¥å€¤
2444507 1980000197 

"abcab"ã®[1,4)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š"bca"ã®ãƒãƒƒã‚·ãƒ¥å€¤
30025064778 19700001990000198 

"abcab"ã®[3,5)æ–‡å­—ç›®ã€ã¤ã¾ã‚Š"ab"ã®ãƒãƒƒã‚·ãƒ¥å€¤
2444507 1980000197 

"bc"ã®ãƒãƒƒã‚·ãƒ¥å€¤
2456853 1990000198 

"a"ã®ãƒãƒƒã‚·ãƒ¥å€¤
197 197 

"bc"ã¨"a"ã®çµåˆã€ã¤ã¾ã‚Š"bca"ã®ãƒãƒƒã‚·ãƒ¥å€¤
30025064778 19700001990000198 
```

## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2023/03/25 | connectã‚’è¿½åŠ  |
| 2023/03/25 | ãƒãƒƒã‚·ãƒ¥å¯¾è±¡ã‚’stringã‹ã‚‰vector<long long>ã«å¤‰æ›´ |
| 2022/06/26 | constexprã«ã‚ˆã‚‹æœ€é©åŒ–ã‚’å®Ÿè¡Œ |
| 2021/08/31 | instantã‚’è¿½åŠ  |
| 2021/04/01 | ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒãƒƒã‚·ãƒ¥ã‚’è¿½åŠ  |

## ç¢ºèªã—ãŸå•é¡Œ

| å•é¡Œ | æå‡º |
| :---: | :--- |
| [ABC141-E](https://atcoder.jp/contests/abc141/tasks/abc141_e) | [æå‡º](https://atcoder.jp/contests/abc141/submissions/39997036) |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³• ğŸ”´

init
- ç„¡å‘ã‚°ãƒ©ãƒ•ã‚’ã€é ‚ç‚¹æ•°$$N$$ã¨ã€è¾ºã®å§‹ç‚¹ã¨çµ‚ç‚¹ã¨ã‚³ã‚¹ãƒˆã‚’è¡¨ç¾ã—ãŸpair<pair<int,int>,long long>ã®vectorã¨ã—ã¦ä¸ãˆã‚‹ã€‚
- ã™ã‚‹ã¨ã€ã‚°ãƒ©ãƒ•ã‚’solve()ãŒæ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹
- å¤šå§‹ç‚¹ãªã©ã§ä½•å›ã‚‚å›ã™å ´åˆã€initã®å®Ÿè¡Œã¯$$1$$å›ã§ã‚ˆã„
- è¨ˆç®—é‡ã¯$$ÎŸ(\vert E \vert)$$

Dijkstra
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

solve
- initã§ã§ããŸã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€ä¸ãˆã‚‰ã‚ŒãŸ$$s$$ã‚’å§‹ç‚¹ã¨ã—ã¦ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’å®Ÿè¡Œã™ã‚‹
- å¾—ã‚‰ã‚ŒãŸæœ€å°ã‚³ã‚¹ãƒˆã‚’è¦ç´ æ•°ãŒ$$V$$ã®vectorã¨ã—ã¦è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ((E+V)logV)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/Dijkstra.cpp)

```cpp
class Dijkstra{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    typedef std::pair<long long,int> P;
    std::vector<std::vector<P>> G;
    int V;
    long long INF = (1LL<<61);
    std::priority_queue<P,std::vector<P>,std::greater<P>> que;
    
    public:
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        //é ‚ç‚¹æ•°ã‚’æ±ºå®šã™ã‚‹
        V=N;
        
        //è¾ºé›†åˆã‚’æ‰±ã„ã‚„ã™ã„å½¢å¼ã«å¤‰æ›ã™ã‚‹
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({cost,to});
        }
    }
    
    Dijkstra(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }

    std::vector<long long> solve(int s){
        std::vector<long long> d;
        //INFã§åˆæœŸåŒ–ã™ã‚‹
        for(int i=0;i<V;i++){
            d.push_back(INF);
        }
        d[s]=0;
        que.push({0,s});
        //queã¯{cost,to}ã‚’ã‚³ã‚¹ãƒˆãŒå°ã•ã„é †ã«å‡ºã™
        while(!que.empty()){
            P p = que.top();
            que.pop();
            int v=p.second;
            if(d[v]<p.first)continue;
            for(int i=0;i<G[v].size();i++){
                P e = G[v][i];
                if(d[e.second]>d[v]+e.first){
                    d[e.second] = d[v]+e.first;
                    que.push({d[e.second],e.second});
                }
            }
        }
        return d;
    }
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class Dijkstra{/*çœç•¥*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Dijkstra dijkstra(N,E);
    std::vector<long long> D = dijkstra.solve(0);
    
    for(int i=0;i<N;i++){
        std::cout << D[i] << " ";
    }
    std::cout << std::endl;
    
    std::vector<long long> F = dijkstra.solve(1);
    
    for(int i=0;i<N;i++){
        std::cout << F[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0 1 3 7 11 
2305843009213693952 0 2 6 10 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ /ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ |
| 2021/02/12 | ãƒã‚°ã‚’ä¿®æ­£/ã„ãã¤ã‹ã®è¡¨è¨˜å¤‰æ›´ |
| 2020/04/04 | ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³• ğŸ”´

init
- ç„¡å‘ã‚°ãƒ©ãƒ•ã‚’ã€è¾ºã®å§‹ç‚¹ã¨çµ‚ç‚¹ã¨ã‚³ã‚¹ãƒˆã‚’è¡¨ç¾ã—ãŸpair<pair<int,int>,long long>ã®vectorã¨ã—ã¦ä¸ãˆã‚‹ã€‚
- ã™ã‚‹ã¨ã€ã‚°ãƒ©ãƒ•ã‚’solve()ãŒæ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹
- å¤šå§‹ç‚¹ãªã©ã§ä½•å›ã‚‚å›ã™å ´åˆã€initã®å®Ÿè¡Œã¯$$1$$å›ã§ã‚ˆã„
- è¨ˆç®—é‡ã¯$$ÎŸ(max(E,V))$$

BellmanFord
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

solve
- initã§ã§ããŸã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€ä¸ãˆã‚‰ã‚ŒãŸ$$s$$ã‚’å§‹ç‚¹ã¨ã—ã¦ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³•ã‚’å®Ÿè¡Œã™ã‚‹
- å¾—ã‚‰ã‚ŒãŸæœ€å°ã‚³ã‚¹ãƒˆã‚’è¦ç´ æ•°ãŒ$$V$$ã®vectorã¨ã—ã¦è¿”ã™
- vectorã®è¦ç´ ã¯pair<long long,bool>ã§ã‚ã‚‹ã€€firstã¯æœ€å°ã‚³ã‚¹ãƒˆã‚’è¡¨ã—ã¦ãŠã‚Šã€secondãŒtrueã®å ´åˆæœ€å°ã‚³ã‚¹ãƒˆãŒå­˜åœ¨ã›ãšfirstã®å€¤ã¯é©å½“
- è¨ˆç®—é‡ã¯$$ÎŸ(VE)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/BellmanFord.cpp)

```cpp
class BellmanFord{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    typedef std::pair<std::pair<int,int>,long long> P;
    int V,E;
    long long INF = (1LL<<61);
    std::vector<std::pair<std::pair<int,int>,long long>> es;
    
    public:
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        //è¾ºæ•°ã‚’ã‚‚ã¨ã‚ã‚‹ã€€
        E=edge.size();
        //é ‚ç‚¹æ•°ã‚’æ±ºå®šã™ã‚‹
        V=N;
        es=edge;
    }
    
    BellmanFord(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }

    std::vector<std::pair<long long,bool>> solve(int s){
        std::vector<std::pair<long long,bool>> d;
        //INFã§åˆæœŸåŒ–ã™ã‚‹
        for(int i=0;i<V;i++){
            d.push_back({INF,false});
        }
        d[s].first=0;
        for(int j=0;j<2*V;j++){
             bool update=false;
            for(int i=0;i<E;i++){
                P k=es[i];
                if(d[k.first.first].first!=INF && d[k.first.second].first>d[k.first.first].first+k.second){
                    d[k.first.second].first=d[k.first.first].first+k.second;
                    if(j>=V){
                        d[k.first.second].second=true;
                    }
                    update=true;
                }
            }
            if(!update)break;
        }
        return d;
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class BellmanFord{/*çœç•¥*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    BellmanFord bellmanford(N,E);
    std::vector<std::pair<long long,bool>> B = bellmanford.solve(0);
    
    for(int i=0;i<N;i++){
        if(B[i].second==true){
            std::cout << "-INF" << " ";
        }else{
            std::cout << B[i].first << " ";
        }
    }
    std::cout << std::endl;
    
    std::vector<std::pair<long long,bool>> C = bellmanford.solve(1);
    
    for(int i=0;i<N;i++){
        if(C[i].second==true){
            std::cout << "-INF" << " ";
        }else{
            std::cout << C[i].first << " ";
        }
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0 1 3 7 11 
2305843009213693952 0 2 6 10 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2021/03/25 | ãƒã‚°ã‚’ä¿®æ­£/ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ |
| 2020/04/04 | ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³•ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ã‚¯ãƒ©ã‚¹ã‚«ãƒ«æ³• ğŸ”´

ç„¡å‘ã‚°ãƒ©ãƒ•ã‚’ã€è¾ºã®å§‹ç‚¹ã¨çµ‚ç‚¹ã¨ã‚³ã‚¹ãƒˆã‚’è¡¨ç¾ã—ãŸpair<pair<int,int>,long long>ã®vectorã¨ã—ã¦ä¸ãˆã‚‹ã€‚

ã™ã‚‹ã¨ã€ã‚³ã‚¹ãƒˆã®å’ŒãŒæœ€å°ã«ãªã‚‹ã‚ˆã†ãªå…¨åŸŸæœ¨ã‚’ä¸€ã¤æ§‹æˆã—ã€ãã®æœ¨ã‚’æ§‹æˆã™ã‚‹è¾ºã‚’vectorã¨ã—ã¦è¿”ã™

è¾ºãŒã¤ãªã$$2$$é ‚ç‚¹ãŒé€£çµã‹ã©ã†ã‹ã‚’[UnionFind](./unionfind)ã‚’ç”¨ã„ã¦åˆ¤å®šã—ã¦ã„ã‚‹

è¨ˆç®—é‡ã¯$$ÎŸ(ElogE)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/Kruskal.cpp)

```cpp
class Kruskal{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int V=0,E=0;
    typedef std::pair<std::pair<int,int>,long long> P;
    std::vector<int> UF,rank;
    std::vector<std::pair<std::pair<int,int>,long long>> es;
    
    bool comp(P F,P G){
        return F.second<G.second;
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]<rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
    }
    
    public:
    
    std::vector<P> solve(std::vector<P> edge){
        //é ‚ç‚¹æ•°ã‚’æ±ºå®šã™ã‚‹
        V=0;
        for(int i=0;i<edge.size();i++){
            V=std::max(V,edge[i].first.first+1);
            V=std::max(V,edge[i].first.second+1);
        }
        //è¾ºæ•°ã‚’ã‚‚ã¨ã‚ã‚‹ã€€
        E=edge.size();
        //unionfindã‚’åˆæœŸåŒ–ã™ã‚‹
        UF.clear();
        rank.clear();
        for(int i=0;i<V;i++){
            UF.push_back(i);
            rank.push_back(0);
        }
        //è¾ºã‚’ã‚½ãƒ¼ãƒˆã—ã¦ä»£å…¥ã—ã¦ãŠã
        std::sort(edge.begin(),edge.end(),[&](P x, P y){return comp(x, y);});
        es=edge;
        
        std::vector<P> R;
        for(int i=0;i<E;i++){
            if(!same(es[i].first.first,es[i].first.second)){
                unite(es[i].first.first,es[i].first.second);
                R.push_back(es[i]);
            }
        }
        return R;
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class Kruskal{/*çœç•¥*/};

int main(void){
    
    std::vector<std::pair<std::pair<int,int>,long long>> E;
    int N = 5;
    E.push_back({ {0,1},1});
    E.push_back({ {1,2},2});
    E.push_back({ {2,3},4});
    E.push_back({ {2,4},8});
    E.push_back({ {3,4},10000});
    
    Kruskal kruskal;
    std::vector<std::pair<std::pair<int,int>,long long>> K = kruskal.solve(E);
    
    for(int i=0;i<K.size();i++){
        std::cout << K[i].first.first << " " << K[i].first.second;
        std::cout << "  " << K[i].second << std::endl;
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0 1  1
1 2  2
2 3  4
2 4  8
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/25 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2021/03/25 | ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ |
| 2020/04/05 | ã‚¯ãƒ©ã‚¹ã‚«ãƒ«æ³•ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®š ğŸ”´

ç„¡å‘ã‚°ãƒ©ãƒ•ã‚’ã€è¾ºã®å§‹ç‚¹ã¨çµ‚ç‚¹ã‚’è¡¨ç¾ã—ãŸpair<int,int>ã®vectorã¨ã—ã¦ä¸ãˆã‚‹ã€‚<br>
ã™ã‚‹ã¨ã€sizeãŒ$$max(ç‚¹ã®ç•ªå·)+1$$ã®vectorãŒè¿”ã£ã¦ãã‚‹ã€‚ã™ã¹ã¦ã®è¦ç´ ã¯$$0$$ã¾ãŸã¯$$1$$ã§ã‚ã‚‹ã€‚<br>
ã“ã‚Œã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ©ãƒ•ã‚’äºŒéƒ¨ã‚°ãƒ©ãƒ•ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã¨ã$$i$$ç•ªç›®ã®è¦ç´ ã¯$$0$$ã¨$$1$$ã©ã¡ã‚‰ã«å±ã™ã‚‹ã‹ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚<br>
ã¾ãŸäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ãªã„ã¨ãå…¨ã¦ã®è¦ç´ ã¯$$0$$ã§ã‚ã‚‹ã€‚<br>
è¨ˆç®—é‡ã¯$$ÎŸ(V+E)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/bipartite%20graph.cpp)

```cpp
std::vector<int> bipartite(std::vector<std::pair<int,int>> edge){
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    int E = edge.size();
    if(E==0)return {};
    int V = 0;
    for(int i=0;i<E;i++){
        V=std::max(V,edge[i].first+1);
        V=std::max(V,edge[i].second+1);
    }
    std::vector<int> R(V,-1);
    std::vector<int> S(V,0);
    std::vector<std::vector<int>> es(V,std::vector<int>(0));
    for(int i=0;i<E;i++){
        es[edge[i].first].push_back(edge[i].second);
        es[edge[i].second].push_back(edge[i].first);
    }
    std::queue<int> Q;
    std::vector<bool> visited(V,false);
    for(int j=0;j<V;j++){
        if(visited[j])continue;
        Q.push(j);
        R[j]=0;
        visited[j]=true;
        while(!Q.empty()){
            int q=Q.front();
            Q.pop();
            visited[q]=true;
            for(int i=0;i<es[q].size();i++){
                if(R[es[q][i]]==R[q]){
                    return S;
                }
                if(visited[es[q][i]])continue;
                Q.push(es[q][i]);
                R[es[q][i]]=1-R[q];
            }
        }
    }
    return R;
}
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

std::vector<int> bipartite(std::vector<std::pair<int,int>> edge){/*çœç•¥*/}

int main(void){
    
    std::vector<std::pair<int,int>> E,F;
    
    E.push_back({0,1});
    E.push_back({1,2});
    E.push_back({2,3});
    E.push_back({3,0});
    E.push_back({0,4});
    
    F.push_back({0,1});
    F.push_back({1,2});
    F.push_back({2,3});
    F.push_back({2,4});
    F.push_back({3,4});
    
    std::vector<int> Es = bipartite(E), Fs = bipartite(F);
    
    for(int i=0;i<Es.size();i++){
        std::cout << Es[i] << " ";
    }
    std::cout << std::endl;
    
    for(int i=0;i<Fs.size();i++){
        std::cout << Fs[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0 1 0 1 1 
0 0 0 0 0 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã‚’è¿½åŠ  |
| 2021/03/26 | ãƒã‚°ã‚’ä¿®æ­£/è¨ˆç®—é‡è¡¨è¨˜ã‚’ä¿®æ­£ |
| 2020/04/02 | äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®šã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ æœ¨ã®ç›´å¾„ ğŸ”´

æœ¨ã§ã¯ãªã„ä¸€èˆ¬çš„ãªã‚°ãƒ©ãƒ•ã§ã‚‚è¿‘ä¼¼è§£ãŒå‡ºã‚‹ã‚‰ã—ã„ã‘ã©ãƒã‚§ãƒƒã‚¯ã—ã¦ã¾ã›ã‚“(ãˆï¼Ÿ)

init
- æ•´æ•°$$N$$ã¨é ‚ç‚¹æ•°$$N$$ã®é‡ã¿ä»˜ãæœ¨ã‚’0-indexedã®vector<pair<pair<int,int>,long long>>ã§ä¸ãˆã‚‹ã¨å‰è¨ˆç®—ã‚’ã—ã€æœ¨ã®ç›´å¾„ãŒè¨ˆç®—ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

double_sweep
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

vertex
- æœ€ã‚‚è·é›¢ãŒå¤§ãããªã‚‹ã‚ˆã†ãªé ‚ç‚¹å¯¾$$(u,v)$$ã‚’ä¸€ã¤è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(1)$$

pass
- $$u$$ã¨$$v$$ã®é–“ã®ãƒ‘ã‚¹ã‚’è¿”ã™
- ã“ã®ã¨ãvectorã®å…ˆé ­ãŒ$$u$$ã€æœ€å¾Œå°¾ãŒ$$v$$ã«ãªã‚‹
- è¨ˆç®—é‡ã¯ãƒ‘ã‚¹ã®é•·ã•ã‚’$$P$$ã¨ã—ã¦ã€$$ÎŸ(P)$$

diameter
- $$u$$ã¨$$v$$ã®é–“ã®ãƒ‘ã‚¹ã®é‡ã•ã‚’å‡ºåŠ›ã™ã‚‹
- è¨ˆç®—é‡ã¯ãƒ‘ã‚¹ã®é•·ã•ã‚’$$P$$ã¨ã—ã¦ã€$$ÎŸ(P)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/double%20sweep.cpp)

```cpp
class double_sweep{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    const long long INF = (1LL<<61);
    int V,V1,V2;
    std::vector<std::vector<std::pair<int,long long>>> G;
    std::vector<int> parent;
    std::vector<long long> parent_cost;
    long long diam;
    long long temp;
    
    void dfs(int phase,int v,int p,long long d){
        if(phase==1){
            if(d>temp){
                V1 = v;
                temp = d;
            }
        }
        if(phase==2){
            parent[v] = p;
            if(d>temp){
                V2 = v;
                temp = d;
            }
        }
        for(std::pair<int,long long> E:G[v]){
            int e = E.first;
            long long f = E.second;
            if(e!=p){
                dfs(phase,e,v,d+f);
                if(phase==2){
                    parent_cost[e] = f;
                }
            }
        }
    }
    
    public:
    
    void init(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        V = N;
        V1 = 0,V2 = 0;
        
        G.clear();
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            int from=edge[i].first.first,to=edge[i].first.second;
            long long cost=edge[i].second;
            G[from].push_back({to,cost});
            G[to].push_back({from,cost});
        }
        
        parent.resize(V);
        for(int i=0;i<V;i++){
            parent[i] = -1;
        }
        parent_cost.resize(V);
        for(int i=0;i<V;i++){
            parent_cost[i] = -1;
        }
        
        temp = -INF;
        dfs(1,0,-1,0);
        temp = -INF;
        dfs(2,V1,-1,0);
        diam = -1;
    }
    
    double_sweep(int N,std::vector<std::pair<std::pair<int,int>,long long>> edge){
        init(N,edge);
    }
    
    std::pair<int,int> vertex(void){
        return std::make_pair(V2,V1);
    }
    
    std::vector<int> pass(void){
        std::vector<int> R;
        diam = 0;
        int r = V2;
        while(r!=V1){
            R.push_back(r);
            diam += parent_cost[r];
            r = parent[r];
        }
        R.push_back(r);
        return R;
    }
    
    long long diameter(void){
        if(diam==-1){
            pass();
        }
        return diam;
    }
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class double_sweep{/*çœç•¥*/};

int main(void){
    
    int N = 8;
    std::vector<std::pair<std::pair<int,int>,long long>> edge;
    
    edge.push_back({ {0,1},1});
    edge.push_back({ {0,2},2});
    edge.push_back({ {0,3},4});
    edge.push_back({ {1,4},8});
    edge.push_back({ {1,5},16});
    edge.push_back({ {5,6},32});
    edge.push_back({ {5,7},64});
    
    double_sweep DS(N,edge);
    
    
    //ç›´å¾„ã®ç«¯ã®é ‚ç‚¹ã¯6ã¨7
    std::pair<int,int> V = DS.vertex();
    std::cout << V.first << " " << V.second << std::endl;
    
    //ãã®ãƒ‘ã‚¹ã¯6-5-7
    std::vector<int> P = DS.pass();
    for(int i=0;i<P.size();i++){
        std::cout << P[i] << " ";
    }
    std::cout << std::endl;
    
    //é‡ã•ã®å’Œã¯96
    long long D = DS.diameter();
    std::cout << D << std::endl;
    
    
    return 0;
}
```

### å‡ºåŠ›
```
6 7
6 5 7 
96
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2020/10/15 | æœ¨ã®ç›´å¾„ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ æœ€å°å…±é€šç¥–å…ˆ ğŸ”´

init
- æ•´æ•°$$r$$ã¨é ‚ç‚¹æ•°$$N$$ã®æœ¨ã‚’0-indexedã®vector<pair<int,int>>ã§ä¸ãˆã‚‹ã¨å‰è¨ˆç®—ã‚’ã—ã€$$r$$ã‚’æ ¹ã¨ã™ã‚‹æœ¨ã®LCAãŒè¨ˆç®—ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N \log N)$$

lowest_common_ancestor
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

climb
- $$u$$ã¨$$k$$ã‚’ä¸ãˆã‚‹ã¨ã€é ‚ç‚¹$$u$$ã‹ã‚‰$$k$$å€‹é¡ã£ãŸé ‚ç‚¹ã®ç•ªå·ã‚’è¿”ã™
- ã‚‚ã—æ ¹ã‚’è¶…ãˆã¦ã—ã¾ã£ãŸå ´åˆã¯$$-1$$ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(\log k)$$

lca
- $$u$$ã¨$$v$$ã‚’ä¸ãˆã‚‹ã¨é ‚ç‚¹$$u$$ã¨$$v$$ã®LCA(æœ€å°å…±é€šç¥–å…ˆ)ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯æœ¨ã®é ‚ç‚¹æ•°$$N$$ã‚’ç”¨ã„ã¦ã€$$ÎŸ(\log N)$$

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/lowest%20common%20ancestor.cpp)

```cpp
class lowest_common_ancestor{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int V,LOG;
    std::vector<std::vector<long long>> G,table;
    std::vector<long long> depth;
    
    void dfs(long long v,long long p,long long d){
        depth[v] = d;
        table[v][0] = p;
        for(long long e:G[v]){
            if(e!=p){
                dfs(e,v,d+1);
            }
        }
    }
    
    public:
    void init(long long root,std::vector<std::pair<long long,long long>> edge){
        V = 1+edge.size();
        LOG = 1;
        while((1<<LOG)<V)LOG++;

        G.clear();
        G.resize(V);
        for(int i=0;i<edge.size();i++){
            G[edge[i].first].push_back(edge[i].second);
            G[edge[i].second].push_back(edge[i].first);
        }
        
        table.resize(V);
        for(int i=0;i<V;i++){
            table[i].resize(LOG);
        }
        depth.resize(V);
        dfs(root,-1,0);
        
        for(int j=0;j<LOG-1;j++){
            for(int i=0;i<V;i++){
                if(table[i][j]==-1){
                    table[i][j+1] = -1;
                }else{
                    table[i][j+1] = table[table[i][j]][j];
                }
                
            }
        }
        
    }
    
    lowest_common_ancestor(long long root,std::vector<std::pair<long long,long long>> edge){
        init(root,edge);
    }
    
    
    long long climb(long long u,long long k = 1){
        for(int i=0;k>0;k>>=1,i++){
            if(u==-1)return -1;
            if(k&1)u = table[u][i];
        }
        return u;
    }
    
    long long lca(long long u,long long v){
        if(depth[u]>depth[v])std::swap(u,v);
        v = climb(v,depth[v]-depth[u]);
        if(u==v)return u;
        
        for(int i=LOG-1;i>=0;i--){
            if(table[u][i]!=table[v][i]){
                u = table[u][i];
                v = table[v][i];
            }
        }
        return table[u][0];
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class lowest_common_ancestor{/*çœç•¥*/};

int main(void){
    
    int N = 8;
    
    std::vector<std::pair<long long,long long>> edge;
    
    edge.push_back({0,1});
    edge.push_back({0,2});
    edge.push_back({0,3});
    edge.push_back({1,4});
    edge.push_back({1,5});
    edge.push_back({5,6});
    edge.push_back({5,7});
    
    //0ã‚’æ ¹ã¨ã—ã¦å‰è¨ˆç®—ã™ã‚‹
    lowest_common_ancestor LCA(0,edge);
    
    //é ‚ç‚¹6ã‹ã‚‰ä¸€ã¤ãšã¤é¡ã£ãŸã‚‰6â†’5â†’1â†’0ã«ãªã‚Šã€ãã‚Œã‚’è¶…ãˆã‚‹ã¨-1
    for(int i=0;i<5;i++){
        std::cout << LCA.climb(6,i) << " ";
    }
    std::cout << std::endl;
    
    //é ‚ç‚¹6ã¨é ‚ç‚¹7ã®LCAã¯5
    std::cout << LCA.lca(6,7) << std::endl;
    
    //é ‚ç‚¹6ã¨é ‚ç‚¹1ã®LCAã¯1
    std::cout << LCA.lca(6,1) << std::endl;
    
    //é ‚ç‚¹6ã¨é ‚ç‚¹3ã®LCAã¯0
    std::cout << LCA.lca(6,3) << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
6 5 1 0 -1 
5
1
0
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2020/10/10 | æœ€å°å…±é€šç¥–å…ˆã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ‡ã‚£ãƒ‹ãƒƒãƒ„æ³• ğŸ”´

Dinicã®èª­ã¿æ–¹ã“ã‚Œã§ã„ã„ã®ã‹ãª

init
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€é ‚ç‚¹ã‚’$$N$$å€‹ç”Ÿæˆã—ãƒ•ãƒ­ãƒ¼ã®è¨ˆç®—ã«å¿…è¦ãªãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

Dinic
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

add
- é ‚ç‚¹$$from$$ã‹ã‚‰$$end$$ã«ã‹ã‘ã¦å®¹é‡$$cap$$ã®æœ‰å‘è¾ºã‚’å¼µã‚‹
- è¨ˆç®—é‡ã¯$$O(1)$$

solve
- é ‚ç‚¹$$s$$ã‚’å§‹ç‚¹ã€é ‚ç‚¹$$t$$ã‚’çµ‚ç‚¹ã¨ã—ã¦ãƒ•ãƒ­ãƒ¼ã®æœ€å¤§å€¤ã‚’æ±‚ã‚ã‚‹
- è¨ˆç®—é‡ã¯initã§ä¸ãˆãŸé ‚ç‚¹ã®æ•°ã‚’$$V$$ã€addã§ä¸ãˆãŸè¾ºã®æ•°ã‚’$$E$$ã¨ã—ã¦$$ÎŸ(E V^2)$$
- å®Ÿéš›ã¯ã“ã‚Œã‚ˆã‚Šã‚‚é«˜é€Ÿã«å‹•ä½œã™ã‚‹

[github](https://github.com/0214sh7/procon-library/blob/master/algorithm/dinic.cpp)

```cpp
class Dinic{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    struct edge{
        int end;
        long long cap,rev;
        
    };
    
    const long long INF = (1LL<<61);
    int V;
    std::vector<std::vector<edge>> G;
    std::vector<long long> level;
    std::vector<int> iter;
    
    void Dinic_bfs(int s){
        for(int i=0;i<V;i++){
            level[i]=-1;
        }
        std::queue<int> que;
        level[s]=0;
        que.push(s);
        while(!que.empty()){
            int v=que.front();
            que.pop();
            for(unsigned int i=0;i<G[v].size();i++){
                edge &e = G[v][i];
                if(e.cap>0 && level[e.end]<0){
                    level[e.end]=level[v]+1;
                    que.push(e.end);
                }
            }
        }
    }
    
    long long Dinic_dfs(int v,int t,long long f){
        if(v==t)return f;
        for(int &i=iter[v];i<G[v].size();i++){
            edge &e = G[v][i];
            if(e.cap>0 && level[v]<level[e.end]){
                long long d = Dinic_dfs(e.end,t,std::min(f,e.cap));
                if(d>0){
                    e.cap -= d;
                    G[e.end][e.rev].cap+=d;
                    return d;
                }
            }
        }
        return 0;
    }
    
    public:
    
    void init(int N){
        V = N;
        G.clear();
        G.resize(V);
        level.resize(V);
        iter.resize(V);
    }
    
    Dinic(int N){
        init(N);
    }
    
    void add(int from,int end,long long cap){
        G[from].push_back((edge){end,cap,(long long)G[end].size()});
        G[end].push_back((edge){from,0,(long long)G[from].size()-1});
    }
    
    long long solve(int s,int t){
        long long flow=0;
        while(1){
            Dinic_bfs(s);
            if(level[t]<0){return flow;}
            for(int i=0;i<V;i++){
                iter[i]=0;
            }
            long long f;
            while((f=Dinic_dfs(s,t,INF))>0){
                flow+=f;
            }
        }
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class Dinic{/*çœç•¥*/};


int main(void){
    
    Dinic dinitz(5);
    dinitz.add(0,1,4);
    dinitz.add(0,2,2);
    dinitz.add(1,2,1);
    dinitz.add(1,3,2);
    dinitz.add(2,3,4);
    dinitz.add(2,4,2);
    dinitz.add(3,4,4);
    
    //ã“ã®ã‚°ãƒ©ãƒ•ã§ã¯é ‚ç‚¹0ã‹ã‚‰é ‚ç‚¹4ã¸ã¯æœ€å¤§ã§5ã¤æµã‚Œã‚‹
    //ä¾‹ãˆã°0->2->4ã«2ã¤ã€0->1->2->3->4ã«1ã¤ã€0->1->3->4ã«2ã¤ãªã©ãŒè€ƒãˆã‚‰ã‚Œã‚‹
    long long R = dinitz.solve(0,4);
    std::cout << R << std::endl;
    
    return 0;
}

```

### å‡ºåŠ›
```
5
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/11/01 | githubãƒªãƒ³ã‚¯ã‚’è¿½åŠ  |
| 2021/11/01 | ãƒ‡ã‚£ãƒ‹ãƒƒãƒ„æ³•ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ ğŸ”´

å˜ã«ã‚»ã‚°æœ¨ã¨è¨€ãˆã°ã“ã‚Œã‚’æŒ‡ã™ã€æœ€ã‚‚å˜ç´”ãªã‚»ã‚°æœ¨

init
- ç¬¬ä¸€å¼•æ•°ã§æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€è¦ç´ ãŒ$$N$$å€‹å…¥ã‚‹æœ€å°ã‚µã‚¤ã‚ºã®å®Œå…¨äºŒåˆ†æœ¨ã‚’æ§‹æˆã—ã€ã™ã¹ã¦ã®è¦ç´ ã‚’å˜ä½å…ƒã§åˆæœŸåŒ–ã™ã‚‹
- ã¾ãŸç¬¬äºŒï½¥ç¬¬ä¸‰å¼•æ•°ã§ã‚»ã‚°æœ¨ã«ä¹—ã›ã‚‹æ¼”ç®—ã¨ãã®å˜ä½å…ƒã‚’ä¸ãˆã‚‹ã¨ãã®æ¼”ç®—ã‚’ä¹—ã›ã‚‹
- æ¼”ç®—ãŒãƒ¢ãƒã‚¤ãƒ‰ã§ãªã„å ´åˆã®å‹•ä½œã¯ä¿è¨¼ã—ãªã„
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

segmenttree
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

update
- $$k$$ç•ªç›®(0-indexed)ã®è¦ç´ ã‚’$$a$$ã§æ›´æ–°ã—ã€ãã‚ŒãŒå½±éŸ¿ã™ã‚‹ãƒãƒ¼ãƒ‰ã‚’å…¨ã¦æ›´æ–°ã™ã‚‹
- è¨ˆç®—é‡ã¯initã®$$N$$ã‚’ç”¨ã„ã¦ã€$$ÎŸ(logN)$$

query
- $$[a,b)$$ã®ç¯„å›²å†…ã«ã‚ã‚‹è¦ç´ ã‚’calcã§è¨ˆç®—ã—ãŸçµæœã‚’long longã§è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(log(b-a))$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/segment%20tree.cpp)

```cpp
template<typename T>
class segmenttree{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    int n;
    
    std::vector<T> dat;
    std::function<T(T,T)> calc;
    T identity;
    public:
    
    void init(int N,std::function<T(T,T)> func,T Identity){
        n=1;
        while(n<N)n*=2;
        dat.resize(2*n-1);
        for(int i=0;i<2*n-1;++i){
            dat[i]=Identity;
        }
        calc = func;
        identity = Identity;
    }
    
    segmenttree(int N,std::function<T(T,T)> func,T Identity){
        init(N,func,Identity);
    }
    
    void update(int k,T a){
        k+=n-1;
        dat[k]=a;
        while(k>0){
            k=(k-1)/2;
            dat[k]=calc(dat[2*k+1],dat[2*k+2]);
        }
    }
    
    T query(int a,int b){
        a+=n-1;
        b+=n-1;
        T L= identity,R = identity;
        while(a < b){
            if(a % 2 == 0){
                L = calc(L,dat[a]);
                a++;
            }
            a = (a-1)/2;
            if(b % 2 == 0){
                R = calc(dat[b-1],R);
                b--;
            }
            b = (b-1)/2;
        }
        R = calc(L,R);
        return R;
    }
    
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

template<typename T>
class segmenttree{/*çœç•¥*/};

int main(void){
    
    long long N = 6;
    std::vector<long long> A = {100000,20000,3000,400,50,6};
    std::function<long long(long long,long long)> func = [](long long a,long long b){
        return a+b;
    };
    
    segmenttree<long long> segtree(N,func,0);
    for(int i=0;i<N;i++){
        segtree.update(i,A[i]);
    }
    
    std::cout << segtree.query(0,3) << std::endl;
    std::cout << segtree.query(0,6) << std::endl;
    std::cout << segtree.query(2,6) << std::endl;
    std::cout << segtree.query(3,5) << std::endl;
    std::cout << segtree.query(5,6) << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
123000
123456
3456
450
6
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2022/01/30 | ãƒã‚°ã‚’ä¿®æ­£ |
| 2022/01/30 | ä»»æ„ã®å‹ã«å¯¾å¿œ |
| 2021/10/10 | ãƒã‚°ã‚’ä¿®æ­£ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2020/04/06 | ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒ•ã‚§ãƒ‹ãƒƒã‚¯æœ¨ ğŸ”´

BIT(Binary Indexed Tree)ã¨ã‚‚

init
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€è¦ç´ ãŒ$$N$$å€‹ã®ãƒ•ã‚§ãƒ‹ãƒƒã‚¯æœ¨ã‚’æ§‹æˆã—ã€ã™ã¹ã¦ã®è¦ç´ ã‚’$$0$$ã§åˆæœŸåŒ–ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

Fenwick_tree
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

add
- $$a$$ç•ªç›®(0-indexed)ã®è¦ç´ ã«$$w$$ã‚’åŠ ç®—ã™ã‚‹
- è¨ˆç®—é‡ã¯initã®$$N$$ã‚’ç”¨ã„ã¦ã€$$ÎŸ(log(N))$$


sum
- $$[0,a)$$ã®ç¯„å›²å†…ã«ã‚ã‚‹è¦ç´ ã®å’Œã‚’long longã§è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(log(a))$$

inversion
- æ•°åˆ—$$V$$ã‚’ä¸ãˆã‚‹ã¨$$V$$ã®è»¢å€’æ•°ã‚’è¨ˆç®—ã—ã€long longã§è¿”ã™
- ã“ã®éš›ã€initã—ç›´ã™ãŸã‚ä»Šã¾ã§ã®å†…å®¹ã‚’ã™ã¹ã¦å‰Šé™¤ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(\vert V \vert log \vert V \vert)$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/Fenwick%20tree.cpp)

```cpp
class Fenwick_tree{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<long long> BIT;
    
    public:
    
    void add(int a,long long w){
        for(int x=a;x<BIT.size();x|=(x+1)){
            BIT[x]+=w;
        }
    }
    
    void init(int n){
        BIT.clear();
        for(int i=0;i<n;i++){
            BIT.push_back(0);
        }
    }
    
    Fenwick_tree(int n){
        init(n);
    }
    
    long long sum(int a){
        long long r=0;
        for(int x=a-1;x>=0;x=(x&(x+1))-1){
            r+=BIT[x];
        }
        return r;
    }
    
    long long inversion(std::vector<long long> V){
        long long r=0;
        init(V.size());
        for(int i=0;i<V.size();i++){
            add(V[i],1);
            r+=i-sum(V[i]);
        }
        return r;
    }
};
```

## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class Fenwick_tree{/*çœç•¥*/};

int main(void){
    
    long long N = 6;
    std::vector<long long> A = {100000,20000,3000,400,50,6};
    
    Fenwick_tree BIT(N);
    for(int i=0;i<N;i++){
        BIT.add(i,A[i]);
    }
    
    for(int i=0;i<=N;i++){
        std::cout << BIT.sum(i) << std::endl;
    }
    std::cout << std::endl;
    
    std::vector<long long> B = {3,1,4,2};
    std::cout << BIT.inversion(B) << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
0
100000
120000
123000
123400
123450
123456

3
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2020/04/06 | ãƒ•ã‚§ãƒ‹ãƒƒã‚¯æœ¨ã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ UnionFind ğŸ”´

DSU(disjoint set union)ã¨ã‚‚

init
- æ•´æ•°$$N$$ã‚’ä¸ãˆã‚‹ã¨ã€é ‚ç‚¹ã‚’$$N$$å€‹ç”Ÿæˆã—å…¨ã¦ã‚’ç‹¬ç«‹ã«ã—ãŸä¸Šã§å…¨ã¦ã®ãƒ©ãƒ³ã‚¯ã‚’$$0$$ã«ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(N)$$

unionfind
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚initã‚’å‘¼ã¶

root
- é ‚ç‚¹$$k$$ã®ãã®æ™‚ç‚¹ã§ã®æ ¹ã‚’æ±‚ã‚ã‚‹
- ã¨åŒæ™‚ã«çµŒè·¯åœ§ç¸®ã™ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(\alpha (N))$$

$$Î±(x)$$ã¯ã‚¢ãƒƒã‚«ãƒ¼ãƒãƒ³é–¢æ•°$$Ack(x,x)$$ã®é€†é–¢æ•°

$$Ack(4,4)=2^{2^{2^{65536}}}-3$$ã‹ã‚‰ä¼ºãˆã‚‹ã‚ˆã†ã«ã€$$\alpha (x)$$ã¯å®Ÿç”¨ä¸Šå®šæ•°($$4$$)å€ã¨è¦‹ãªã›ã‚‹ã»ã©ã«åæŸãŒé…ã„

same
- é ‚ç‚¹$$p$$ã¨é ‚ç‚¹$$q$$ãŒãã®æ™‚ç‚¹ã§åŒã˜é›†åˆã«å±ã—ã¦ã„ã‚‹ã‹(=æ ¹ãŒåŒä¸€ã‹)ã‚’èª¿ã¹ã€åŒã˜ãªã‚‰trueã€é•ã†ãªã‚‰falseã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(\alpha (N))$$

unite
- é ‚ç‚¹$$p$$ã¨é ‚ç‚¹$$q$$ãŒå±ã—ã¦ã‚‹é›†åˆã‚’åˆä½µã™ã‚‹
- ã™ã§ã«åŒã˜é›†åˆã«å±ã—ã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–ã™ã‚‹
- $$p$$ã®å±ã™ã‚‹é›†åˆã®ãƒ©ãƒ³ã‚¯ãŒ$$q$$ã®ã‚‚ã®ã¨åŒã˜ã‹å¤§ãã„ã¨ã$$p$$å´ãŒæ ¹ã«ã€ãã†ã§ãªã„ã¨ã$$q$$å´ãŒæ ¹ã«ãªã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(\alpha (N))$$

size
- é ‚ç‚¹$$k$$ã¨ãã®æ™‚ç‚¹ã§åŒã˜é›†åˆã«å±ã—ã¦ã„ã‚‹é ‚ç‚¹ã®æ•°ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(1)$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/union%20find.cpp)

```cpp
class unionfind{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> UF,rank,size_;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        size_.clear();
        for(int i=0;i<N;i++){
            UF.push_back(i);
            rank.push_back(0);
            size_.push_back(1);
        }
    }
    
    unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            UF[k]=root(UF[k]);
            return UF[k];
        }
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    void unite(int P,int Q){
        int p=root(P);
        int q=root(Q);
        if(p==q)return;
        if(rank[p]<rank[q])std::swap(p,q);
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        size_[p] += size_[q];
        size_[q] = 0;
    }
    
    int size(int k){
        return size_[root(k)];
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class unionfind{/*çœç•¥*/};

int main(void){
    
    unionfind UF(13);
    UF.unite(1,3);
    UF.unite(1,5);
    UF.unite(1,7);
    UF.unite(1,8);
    UF.unite(1,10);
    UF.unite(1,12);
    UF.unite(4,6);
    UF.unite(4,9);
    UF.unite(4,11);
    
    for(int i=1;i<=12;i++){
        std::cout << UF.root(i) << " ";
    }
    std::cout << std::endl;
    
    //1ã¨åŒã˜é›†åˆã«å±ã—ã¦ã„ã‚‹ãªã‚‰1(true)ã€ãã†ã§ãªã„ãªã‚‰0(false)
    for(int i=1;i<=12;i++){
        std::cout << UF.same(1,i) << " ";
    }
    std::cout << std::endl;
    
    //åŒã˜é›†åˆã«å…¥ã£ã¦ã„ã‚‹é ‚ç‚¹ãŒã„ãã¤ã‚ã‚‹ã‹
    for(int i=1;i<=12;i++){
        std::cout << UF.size(i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
1 2 1 4 1 4 1 1 4 1 4 1 
1 0 1 0 1 0 1 1 0 1 0 1 
7 1 7 4 7 4 7 7 4 7 4 7 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/08/31 | sizeã‚’è¿½åŠ  |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2020/04/06 | UnionFindã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

# ğŸ”´ ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ä»˜ãUnionFind ğŸ”´

é‡ã¿ä»˜ãUnionFindã£ã¦è¨€ã£ãŸã»ã†ãŒã„ã„ã®ã‹ãªï¼Ÿæ­£ç›´ã‚ã‹ã‚‰ãªã„

å¤§ä½“ã®æ©Ÿèƒ½ã¯[UnionFind](./unionfind)ã¨åŒã˜ã§é•ã†ç‚¹ã¯

potential
- é ‚ç‚¹$$k$$ã®ãã®æ™‚ç‚¹ã§ã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚’æ±‚ã‚ã‚‹
- è¨ˆç®—é‡ã¯$$ÎŸ(\alpha (N))$$

unite
- é›†åˆã‚’åˆä½µã™ã‚‹éš›ã«ã€$$(Qã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«)-(Pã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«)=d$$ã«ãªã‚‹ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
- P,QãŒåŒã˜é›†åˆã«ã‚ã‚‹å ´åˆã«falseã‚’è¿”ã™

diff
- $$(Qã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«)-(Pã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«)$$ã‚’è¿”ã™
- è¨ˆç®—é‡ã¯$$ÎŸ(\alpha (N))$$

[github](https://github.com/0214sh7/procon-library/blob/master/data%20structure/potentialized%20unionfind.cpp)

```cpp
class potentialized_unionfind{
    // Copyright (c) 2023 0214sh7
    // https://github.com/0214sh7/library/
    private:
    std::vector<int> UF,rank,pot;
    public:
    
    void init(int N){
        UF.clear();
        rank.clear();
        for(int i=0;i<N;i++){
            UF.push_back(i);
            rank.push_back(0);
            pot.push_back(0);
        }
    }

    potentialized_unionfind(int N){
        init(N);
    }
    
    int root(int k){
        if(UF[k]==k){
            return k;
        }else{
            int r = root(UF[k]);
            pot[k] += pot[UF[k]];
            UF[k] = r;
            return UF[k];
        }
    }
    
    int potential(int k){
        root(k);
        return pot[k];
    }
    
    bool same(int p,int q){
        return root(p)==root(q);
    }
    
    bool unite(int P,int Q,int d){
        //pot(Q)-pot(P)=dã‚’æº€ãŸã™
        d+=potential(P);
        d-=potential(Q);
        int p=root(P), q=root(Q);
        if(p==q)return false;
        if(rank[p]<rank[q]){
            std::swap(p,q);
            d = -d;
        }
        UF[q]=p;
        if(rank[p]==rank[q])rank[p]++;
        pot[q]=d;
        
        return true;
    }
    
    int diff(int P,int Q){
        return potential(Q)-potential(P);
    }
    
};
```


## ä½¿ç”¨ä¾‹
***

### å®Ÿè¡Œã‚³ãƒ¼ãƒ‰
```cpp
#include <bits/stdc++.h>

class potentialized_unionfind{/*çœç•¥*/};

int main(void){
    
    potentialized_unionfind potUF(5);
    
    potUF.unite(0,1,1);
    potUF.unite(1,2,2);
    potUF.unite(2,3,4);
    potUF.unite(2,4,8);
    
    std::cout << "é ‚ç‚¹3ã¨é ‚ç‚¹4ã®çµåˆã¯ã§ãã¦ã„ã‚‹ã‹" << std::endl;
    bool c = potUF.unite(3,4,4);
    if(c==true){
        std::cout << "true" << std::endl;
    }else{
        std::cout << "false" << std::endl;
    }
    std::cout << std::endl;
    
    std::cout << "é ‚ç‚¹0ã¨ã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®å·®ã¯ä½•ã‹" << std::endl;
    for(int i=0;i<5;i++){
        std::cout << potUF.diff(0,i) << " ";
    }
    std::cout << std::endl << std::endl;
    
    std::cout << "é ‚ç‚¹2ã¨ã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®å·®ã¯ä½•ã‹" << std::endl;
    for(int i=0;i<5;i++){
        std::cout << potUF.diff(2,i) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### å‡ºåŠ›
```
é ‚ç‚¹3ã¨é ‚ç‚¹4ã®çµåˆã¯ã§ãã¦ã„ã‚‹ã‹
false

é ‚ç‚¹0ã¨ã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®å·®ã¯ä½•ã‹
0 1 3 7 11 

é ‚ç‚¹2ã¨ã®ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®å·®ã¯ä½•ã‹
-3 -2 0 4 8 
```


## æ›´æ–°å±¥æ­´
***

| æ—¥æ™‚ | å†…å®¹ |
| :---: | :--- |
| 2023/06/29 | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ |
| 2021/03/26 | ä½¿ç”¨ä¾‹ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¿½åŠ  |
| 2020/04/06 | ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ä»˜ãUnionFindã‚’è¿½åŠ  |

<div style="page-break-after: always;"></div>

